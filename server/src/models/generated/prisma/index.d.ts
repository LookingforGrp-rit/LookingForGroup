
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Genres
 * 
 */
export type Genres = $Result.DefaultSelection<Prisma.$GenresPayload>
/**
 * Model JobTitles
 * 
 */
export type JobTitles = $Result.DefaultSelection<Prisma.$JobTitlesPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model Majors
 * 
 */
export type Majors = $Result.DefaultSelection<Prisma.$MajorsPayload>
/**
 * Model Members
 * 
 */
export type Members = $Result.DefaultSelection<Prisma.$MembersPayload>
/**
 * Model ProjectFollowings
 * 
 */
export type ProjectFollowings = $Result.DefaultSelection<Prisma.$ProjectFollowingsPayload>
/**
 * Model ProjectGenres
 * 
 */
export type ProjectGenres = $Result.DefaultSelection<Prisma.$ProjectGenresPayload>
/**
 * Model ProjectImages
 * 
 */
export type ProjectImages = $Result.DefaultSelection<Prisma.$ProjectImagesPayload>
/**
 * Model ProjectSocials
 * 
 */
export type ProjectSocials = $Result.DefaultSelection<Prisma.$ProjectSocialsPayload>
/**
 * Model ProjectTags
 * 
 */
export type ProjectTags = $Result.DefaultSelection<Prisma.$ProjectTagsPayload>
/**
 * Model Projects
 * 
 */
export type Projects = $Result.DefaultSelection<Prisma.$ProjectsPayload>
/**
 * Model Socials
 * 
 */
export type Socials = $Result.DefaultSelection<Prisma.$SocialsPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model UserFollowings
 * 
 */
export type UserFollowings = $Result.DefaultSelection<Prisma.$UserFollowingsPayload>
/**
 * Model UserSkills
 * 
 */
export type UserSkills = $Result.DefaultSelection<Prisma.$UserSkillsPayload>
/**
 * Model UserSocials
 * 
 */
export type UserSocials = $Result.DefaultSelection<Prisma.$UserSocialsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Skills
 * 
 */
export type Skills = $Result.DefaultSelection<Prisma.$SkillsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const JobsAvailability: {
  FullTime: 'FullTime',
  PartTime: 'PartTime',
  Flexible: 'Flexible'
};

export type JobsAvailability = (typeof JobsAvailability)[keyof typeof JobsAvailability]


export const JobsDuration: {
  ShortTerm: 'ShortTerm',
  LongTerm: 'LongTerm'
};

export type JobsDuration = (typeof JobsDuration)[keyof typeof JobsDuration]


export const JobsLocation: {
  OnSite: 'OnSite',
  Remote: 'Remote',
  Hybrid: 'Hybrid'
};

export type JobsLocation = (typeof JobsLocation)[keyof typeof JobsLocation]


export const ProjectsPurpose: {
  Personal: 'Personal',
  PortfolioPiece: 'PortfolioPiece',
  Academic: 'Academic',
  CoOp: 'CoOp'
};

export type ProjectsPurpose = (typeof ProjectsPurpose)[keyof typeof ProjectsPurpose]


export const JobsCompensation: {
  Unpaid: 'Unpaid',
  Paid: 'Paid'
};

export type JobsCompensation = (typeof JobsCompensation)[keyof typeof JobsCompensation]


export const ProjectsStatus: {
  Planning: 'Planning',
  Development: 'Development',
  PostProduction: 'PostProduction',
  Complete: 'Complete'
};

export type ProjectsStatus = (typeof ProjectsStatus)[keyof typeof ProjectsStatus]


export const MembersProfileVisibility: {
  private: 'private',
  public: 'public'
};

export type MembersProfileVisibility = (typeof MembersProfileVisibility)[keyof typeof MembersProfileVisibility]


export const UsersAcademicYear: {
  Freshman: 'Freshman',
  Sophomore: 'Sophomore',
  Junior: 'Junior',
  Senior: 'Senior',
  Grad1: 'Grad1',
  Grad2: 'Grad2'
};

export type UsersAcademicYear = (typeof UsersAcademicYear)[keyof typeof UsersAcademicYear]

}

export type JobsAvailability = $Enums.JobsAvailability

export const JobsAvailability: typeof $Enums.JobsAvailability

export type JobsDuration = $Enums.JobsDuration

export const JobsDuration: typeof $Enums.JobsDuration

export type JobsLocation = $Enums.JobsLocation

export const JobsLocation: typeof $Enums.JobsLocation

export type ProjectsPurpose = $Enums.ProjectsPurpose

export const ProjectsPurpose: typeof $Enums.ProjectsPurpose

export type JobsCompensation = $Enums.JobsCompensation

export const JobsCompensation: typeof $Enums.JobsCompensation

export type ProjectsStatus = $Enums.ProjectsStatus

export const ProjectsStatus: typeof $Enums.ProjectsStatus

export type MembersProfileVisibility = $Enums.MembersProfileVisibility

export const MembersProfileVisibility: typeof $Enums.MembersProfileVisibility

export type UsersAcademicYear = $Enums.UsersAcademicYear

export const UsersAcademicYear: typeof $Enums.UsersAcademicYear

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Genres
 * const genres = await prisma.genres.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Genres
   * const genres = await prisma.genres.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.genres`: Exposes CRUD operations for the **Genres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genres.findMany()
    * ```
    */
  get genres(): Prisma.GenresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobTitles`: Exposes CRUD operations for the **JobTitles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobTitles
    * const jobTitles = await prisma.jobTitles.findMany()
    * ```
    */
  get jobTitles(): Prisma.JobTitlesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.majors`: Exposes CRUD operations for the **Majors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Majors
    * const majors = await prisma.majors.findMany()
    * ```
    */
  get majors(): Prisma.MajorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.members`: Exposes CRUD operations for the **Members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.members.findMany()
    * ```
    */
  get members(): Prisma.MembersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectFollowings`: Exposes CRUD operations for the **ProjectFollowings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectFollowings
    * const projectFollowings = await prisma.projectFollowings.findMany()
    * ```
    */
  get projectFollowings(): Prisma.ProjectFollowingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectGenres`: Exposes CRUD operations for the **ProjectGenres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectGenres
    * const projectGenres = await prisma.projectGenres.findMany()
    * ```
    */
  get projectGenres(): Prisma.ProjectGenresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectImages`: Exposes CRUD operations for the **ProjectImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectImages
    * const projectImages = await prisma.projectImages.findMany()
    * ```
    */
  get projectImages(): Prisma.ProjectImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectSocials`: Exposes CRUD operations for the **ProjectSocials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSocials
    * const projectSocials = await prisma.projectSocials.findMany()
    * ```
    */
  get projectSocials(): Prisma.ProjectSocialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTags`: Exposes CRUD operations for the **ProjectTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTags
    * const projectTags = await prisma.projectTags.findMany()
    * ```
    */
  get projectTags(): Prisma.ProjectTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **Projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.ProjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socials`: Exposes CRUD operations for the **Socials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Socials
    * const socials = await prisma.socials.findMany()
    * ```
    */
  get socials(): Prisma.SocialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFollowings`: Exposes CRUD operations for the **UserFollowings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFollowings
    * const userFollowings = await prisma.userFollowings.findMany()
    * ```
    */
  get userFollowings(): Prisma.UserFollowingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkills`: Exposes CRUD operations for the **UserSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkills
    * const userSkills = await prisma.userSkills.findMany()
    * ```
    */
  get userSkills(): Prisma.UserSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSocials`: Exposes CRUD operations for the **UserSocials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSocials
    * const userSocials = await prisma.userSocials.findMany()
    * ```
    */
  get userSocials(): Prisma.UserSocialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **Skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.SkillsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Genres: 'Genres',
    JobTitles: 'JobTitles',
    Jobs: 'Jobs',
    Majors: 'Majors',
    Members: 'Members',
    ProjectFollowings: 'ProjectFollowings',
    ProjectGenres: 'ProjectGenres',
    ProjectImages: 'ProjectImages',
    ProjectSocials: 'ProjectSocials',
    ProjectTags: 'ProjectTags',
    Projects: 'Projects',
    Socials: 'Socials',
    Tags: 'Tags',
    UserFollowings: 'UserFollowings',
    UserSkills: 'UserSkills',
    UserSocials: 'UserSocials',
    Users: 'Users',
    Skills: 'Skills'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "genres" | "jobTitles" | "jobs" | "majors" | "members" | "projectFollowings" | "projectGenres" | "projectImages" | "projectSocials" | "projectTags" | "projects" | "socials" | "tags" | "userFollowings" | "userSkills" | "userSocials" | "users" | "skills"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Genres: {
        payload: Prisma.$GenresPayload<ExtArgs>
        fields: Prisma.GenresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          findFirst: {
            args: Prisma.GenresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          findMany: {
            args: Prisma.GenresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>[]
          }
          create: {
            args: Prisma.GenresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          createMany: {
            args: Prisma.GenresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GenresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          update: {
            args: Prisma.GenresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          deleteMany: {
            args: Prisma.GenresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GenresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenresPayload>
          }
          aggregate: {
            args: Prisma.GenresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenres>
          }
          groupBy: {
            args: Prisma.GenresGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenresGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenresCountArgs<ExtArgs>
            result: $Utils.Optional<GenresCountAggregateOutputType> | number
          }
        }
      }
      JobTitles: {
        payload: Prisma.$JobTitlesPayload<ExtArgs>
        fields: Prisma.JobTitlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobTitlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobTitlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          findFirst: {
            args: Prisma.JobTitlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobTitlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          findMany: {
            args: Prisma.JobTitlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>[]
          }
          create: {
            args: Prisma.JobTitlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          createMany: {
            args: Prisma.JobTitlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobTitlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          update: {
            args: Prisma.JobTitlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          deleteMany: {
            args: Prisma.JobTitlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobTitlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobTitlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlesPayload>
          }
          aggregate: {
            args: Prisma.JobTitlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobTitles>
          }
          groupBy: {
            args: Prisma.JobTitlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobTitlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobTitlesCountArgs<ExtArgs>
            result: $Utils.Optional<JobTitlesCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      Majors: {
        payload: Prisma.$MajorsPayload<ExtArgs>
        fields: Prisma.MajorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MajorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MajorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          findFirst: {
            args: Prisma.MajorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MajorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          findMany: {
            args: Prisma.MajorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>[]
          }
          create: {
            args: Prisma.MajorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          createMany: {
            args: Prisma.MajorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MajorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          update: {
            args: Prisma.MajorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          deleteMany: {
            args: Prisma.MajorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MajorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MajorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MajorsPayload>
          }
          aggregate: {
            args: Prisma.MajorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMajors>
          }
          groupBy: {
            args: Prisma.MajorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MajorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MajorsCountArgs<ExtArgs>
            result: $Utils.Optional<MajorsCountAggregateOutputType> | number
          }
        }
      }
      Members: {
        payload: Prisma.$MembersPayload<ExtArgs>
        fields: Prisma.MembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          findFirst: {
            args: Prisma.MembersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          findMany: {
            args: Prisma.MembersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>[]
          }
          create: {
            args: Prisma.MembersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          createMany: {
            args: Prisma.MembersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MembersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          update: {
            args: Prisma.MembersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          deleteMany: {
            args: Prisma.MembersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          aggregate: {
            args: Prisma.MembersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembers>
          }
          groupBy: {
            args: Prisma.MembersGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembersCountArgs<ExtArgs>
            result: $Utils.Optional<MembersCountAggregateOutputType> | number
          }
        }
      }
      ProjectFollowings: {
        payload: Prisma.$ProjectFollowingsPayload<ExtArgs>
        fields: Prisma.ProjectFollowingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFollowingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFollowingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          findFirst: {
            args: Prisma.ProjectFollowingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFollowingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          findMany: {
            args: Prisma.ProjectFollowingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>[]
          }
          create: {
            args: Prisma.ProjectFollowingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          createMany: {
            args: Prisma.ProjectFollowingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectFollowingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          update: {
            args: Prisma.ProjectFollowingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectFollowingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectFollowingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectFollowingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFollowingsPayload>
          }
          aggregate: {
            args: Prisma.ProjectFollowingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectFollowings>
          }
          groupBy: {
            args: Prisma.ProjectFollowingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectFollowingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectFollowingsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectFollowingsCountAggregateOutputType> | number
          }
        }
      }
      ProjectGenres: {
        payload: Prisma.$ProjectGenresPayload<ExtArgs>
        fields: Prisma.ProjectGenresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectGenresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectGenresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          findFirst: {
            args: Prisma.ProjectGenresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectGenresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          findMany: {
            args: Prisma.ProjectGenresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>[]
          }
          create: {
            args: Prisma.ProjectGenresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          createMany: {
            args: Prisma.ProjectGenresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectGenresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          update: {
            args: Prisma.ProjectGenresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          deleteMany: {
            args: Prisma.ProjectGenresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectGenresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectGenresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGenresPayload>
          }
          aggregate: {
            args: Prisma.ProjectGenresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectGenres>
          }
          groupBy: {
            args: Prisma.ProjectGenresGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGenresGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectGenresCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectGenresCountAggregateOutputType> | number
          }
        }
      }
      ProjectImages: {
        payload: Prisma.$ProjectImagesPayload<ExtArgs>
        fields: Prisma.ProjectImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          findFirst: {
            args: Prisma.ProjectImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          findMany: {
            args: Prisma.ProjectImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>[]
          }
          create: {
            args: Prisma.ProjectImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          createMany: {
            args: Prisma.ProjectImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          update: {
            args: Prisma.ProjectImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          deleteMany: {
            args: Prisma.ProjectImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectImagesPayload>
          }
          aggregate: {
            args: Prisma.ProjectImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectImages>
          }
          groupBy: {
            args: Prisma.ProjectImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectImagesCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectImagesCountAggregateOutputType> | number
          }
        }
      }
      ProjectSocials: {
        payload: Prisma.$ProjectSocialsPayload<ExtArgs>
        fields: Prisma.ProjectSocialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSocialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSocialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          findFirst: {
            args: Prisma.ProjectSocialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSocialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          findMany: {
            args: Prisma.ProjectSocialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>[]
          }
          create: {
            args: Prisma.ProjectSocialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          createMany: {
            args: Prisma.ProjectSocialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectSocialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          update: {
            args: Prisma.ProjectSocialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSocialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSocialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectSocialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSocialsPayload>
          }
          aggregate: {
            args: Prisma.ProjectSocialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSocials>
          }
          groupBy: {
            args: Prisma.ProjectSocialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSocialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSocialsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSocialsCountAggregateOutputType> | number
          }
        }
      }
      ProjectTags: {
        payload: Prisma.$ProjectTagsPayload<ExtArgs>
        fields: Prisma.ProjectTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          findFirst: {
            args: Prisma.ProjectTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          findMany: {
            args: Prisma.ProjectTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>[]
          }
          create: {
            args: Prisma.ProjectTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          createMany: {
            args: Prisma.ProjectTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          update: {
            args: Prisma.ProjectTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagsPayload>
          }
          aggregate: {
            args: Prisma.ProjectTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTags>
          }
          groupBy: {
            args: Prisma.ProjectTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTagsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTagsCountAggregateOutputType> | number
          }
        }
      }
      Projects: {
        payload: Prisma.$ProjectsPayload<ExtArgs>
        fields: Prisma.ProjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          findFirst: {
            args: Prisma.ProjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          findMany: {
            args: Prisma.ProjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>[]
          }
          create: {
            args: Prisma.ProjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          createMany: {
            args: Prisma.ProjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          update: {
            args: Prisma.ProjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          aggregate: {
            args: Prisma.ProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjects>
          }
          groupBy: {
            args: Prisma.ProjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectsCountAggregateOutputType> | number
          }
        }
      }
      Socials: {
        payload: Prisma.$SocialsPayload<ExtArgs>
        fields: Prisma.SocialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          findFirst: {
            args: Prisma.SocialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          findMany: {
            args: Prisma.SocialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>[]
          }
          create: {
            args: Prisma.SocialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          createMany: {
            args: Prisma.SocialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          update: {
            args: Prisma.SocialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          deleteMany: {
            args: Prisma.SocialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialsPayload>
          }
          aggregate: {
            args: Prisma.SocialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocials>
          }
          groupBy: {
            args: Prisma.SocialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialsCountArgs<ExtArgs>
            result: $Utils.Optional<SocialsCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      UserFollowings: {
        payload: Prisma.$UserFollowingsPayload<ExtArgs>
        fields: Prisma.UserFollowingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFollowingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFollowingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          findFirst: {
            args: Prisma.UserFollowingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFollowingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          findMany: {
            args: Prisma.UserFollowingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>[]
          }
          create: {
            args: Prisma.UserFollowingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          createMany: {
            args: Prisma.UserFollowingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserFollowingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          update: {
            args: Prisma.UserFollowingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          deleteMany: {
            args: Prisma.UserFollowingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFollowingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFollowingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowingsPayload>
          }
          aggregate: {
            args: Prisma.UserFollowingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFollowings>
          }
          groupBy: {
            args: Prisma.UserFollowingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFollowingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFollowingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserFollowingsCountAggregateOutputType> | number
          }
        }
      }
      UserSkills: {
        payload: Prisma.$UserSkillsPayload<ExtArgs>
        fields: Prisma.UserSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          findFirst: {
            args: Prisma.UserSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          findMany: {
            args: Prisma.UserSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>[]
          }
          create: {
            args: Prisma.UserSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          createMany: {
            args: Prisma.UserSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          update: {
            args: Prisma.UserSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          deleteMany: {
            args: Prisma.UserSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          aggregate: {
            args: Prisma.UserSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkills>
          }
          groupBy: {
            args: Prisma.UserSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillsCountAggregateOutputType> | number
          }
        }
      }
      UserSocials: {
        payload: Prisma.$UserSocialsPayload<ExtArgs>
        fields: Prisma.UserSocialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSocialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSocialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          findFirst: {
            args: Prisma.UserSocialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSocialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          findMany: {
            args: Prisma.UserSocialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>[]
          }
          create: {
            args: Prisma.UserSocialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          createMany: {
            args: Prisma.UserSocialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSocialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          update: {
            args: Prisma.UserSocialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          deleteMany: {
            args: Prisma.UserSocialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSocialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSocialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialsPayload>
          }
          aggregate: {
            args: Prisma.UserSocialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSocials>
          }
          groupBy: {
            args: Prisma.UserSocialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSocialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSocialsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSocialsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Skills: {
        payload: Prisma.$SkillsPayload<ExtArgs>
        fields: Prisma.SkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          findFirst: {
            args: Prisma.SkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          findMany: {
            args: Prisma.SkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>[]
          }
          create: {
            args: Prisma.SkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          createMany: {
            args: Prisma.SkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          update: {
            args: Prisma.SkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          deleteMany: {
            args: Prisma.SkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.SkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    genres?: GenresOmit
    jobTitles?: JobTitlesOmit
    jobs?: JobsOmit
    majors?: MajorsOmit
    members?: MembersOmit
    projectFollowings?: ProjectFollowingsOmit
    projectGenres?: ProjectGenresOmit
    projectImages?: ProjectImagesOmit
    projectSocials?: ProjectSocialsOmit
    projectTags?: ProjectTagsOmit
    projects?: ProjectsOmit
    socials?: SocialsOmit
    tags?: TagsOmit
    userFollowings?: UserFollowingsOmit
    userSkills?: UserSkillsOmit
    userSocials?: UserSocialsOmit
    users?: UsersOmit
    skills?: SkillsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GenresCountOutputType
   */

  export type GenresCountOutputType = {
    projectGenres: number
  }

  export type GenresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectGenres?: boolean | GenresCountOutputTypeCountProjectGenresArgs
  }

  // Custom InputTypes
  /**
   * GenresCountOutputType without action
   */
  export type GenresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenresCountOutputType
     */
    select?: GenresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenresCountOutputType without action
   */
  export type GenresCountOutputTypeCountProjectGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGenresWhereInput
  }


  /**
   * Count Type JobTitlesCountOutputType
   */

  export type JobTitlesCountOutputType = {
    jobs: number
    members: number
    users: number
  }

  export type JobTitlesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | JobTitlesCountOutputTypeCountJobsArgs
    members?: boolean | JobTitlesCountOutputTypeCountMembersArgs
    users?: boolean | JobTitlesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * JobTitlesCountOutputType without action
   */
  export type JobTitlesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitlesCountOutputType
     */
    select?: JobTitlesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobTitlesCountOutputType without action
   */
  export type JobTitlesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * JobTitlesCountOutputType without action
   */
  export type JobTitlesCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersWhereInput
  }

  /**
   * JobTitlesCountOutputType without action
   */
  export type JobTitlesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type MajorsCountOutputType
   */

  export type MajorsCountOutputType = {
    users: number
  }

  export type MajorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MajorsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * MajorsCountOutputType without action
   */
  export type MajorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MajorsCountOutputType
     */
    select?: MajorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MajorsCountOutputType without action
   */
  export type MajorsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type ProjectsCountOutputType
   */

  export type ProjectsCountOutputType = {
    jobs: number
    members: number
    projectFollowings: number
    projectGenres: number
    projectImages: number
    projectSocials: number
    projectTags: number
  }

  export type ProjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | ProjectsCountOutputTypeCountJobsArgs
    members?: boolean | ProjectsCountOutputTypeCountMembersArgs
    projectFollowings?: boolean | ProjectsCountOutputTypeCountProjectFollowingsArgs
    projectGenres?: boolean | ProjectsCountOutputTypeCountProjectGenresArgs
    projectImages?: boolean | ProjectsCountOutputTypeCountProjectImagesArgs
    projectSocials?: boolean | ProjectsCountOutputTypeCountProjectSocialsArgs
    projectTags?: boolean | ProjectsCountOutputTypeCountProjectTagsArgs
  }

  // Custom InputTypes
  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectsCountOutputType
     */
    select?: ProjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProjectFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFollowingsWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProjectGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGenresWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProjectImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectImagesWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProjectSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSocialsWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProjectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagsWhereInput
  }


  /**
   * Count Type SocialsCountOutputType
   */

  export type SocialsCountOutputType = {
    projectSocials: number
    userSocials: number
  }

  export type SocialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectSocials?: boolean | SocialsCountOutputTypeCountProjectSocialsArgs
    userSocials?: boolean | SocialsCountOutputTypeCountUserSocialsArgs
  }

  // Custom InputTypes
  /**
   * SocialsCountOutputType without action
   */
  export type SocialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialsCountOutputType
     */
    select?: SocialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialsCountOutputType without action
   */
  export type SocialsCountOutputTypeCountProjectSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSocialsWhereInput
  }

  /**
   * SocialsCountOutputType without action
   */
  export type SocialsCountOutputTypeCountUserSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialsWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    projectTags: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectTags?: boolean | TagsCountOutputTypeCountProjectTagsArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountProjectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    members: number
    projectFollowings: number
    projects: number
    userFollowingsUserFollowingsFollowingIdTousers: number
    userFollowingsUserFollowingsUserIdTousers: number
    userSkills: number
    userSocials: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | UsersCountOutputTypeCountMembersArgs
    projectFollowings?: boolean | UsersCountOutputTypeCountProjectFollowingsArgs
    projects?: boolean | UsersCountOutputTypeCountProjectsArgs
    userFollowingsUserFollowingsFollowingIdTousers?: boolean | UsersCountOutputTypeCountUserFollowingsUserFollowingsFollowingIdTousersArgs
    userFollowingsUserFollowingsUserIdTousers?: boolean | UsersCountOutputTypeCountUserFollowingsUserFollowingsUserIdTousersArgs
    userSkills?: boolean | UsersCountOutputTypeCountUserSkillsArgs
    userSocials?: boolean | UsersCountOutputTypeCountUserSocialsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProjectFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFollowingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserFollowingsUserFollowingsUserIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialsWhereInput
  }


  /**
   * Count Type SkillsCountOutputType
   */

  export type SkillsCountOutputType = {
    userSkills: number
  }

  export type SkillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | SkillsCountOutputTypeCountUserSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsCountOutputType
     */
    select?: SkillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Genres
   */

  export type AggregateGenres = {
    _count: GenresCountAggregateOutputType | null
    _avg: GenresAvgAggregateOutputType | null
    _sum: GenresSumAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  export type GenresAvgAggregateOutputType = {
    typeId: number | null
  }

  export type GenresSumAggregateOutputType = {
    typeId: number | null
  }

  export type GenresMinAggregateOutputType = {
    typeId: number | null
    label: string | null
  }

  export type GenresMaxAggregateOutputType = {
    typeId: number | null
    label: string | null
  }

  export type GenresCountAggregateOutputType = {
    typeId: number
    label: number
    _all: number
  }


  export type GenresAvgAggregateInputType = {
    typeId?: true
  }

  export type GenresSumAggregateInputType = {
    typeId?: true
  }

  export type GenresMinAggregateInputType = {
    typeId?: true
    label?: true
  }

  export type GenresMaxAggregateInputType = {
    typeId?: true
    label?: true
  }

  export type GenresCountAggregateInputType = {
    typeId?: true
    label?: true
    _all?: true
  }

  export type GenresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to aggregate.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenresMaxAggregateInputType
  }

  export type GetGenresAggregateType<T extends GenresAggregateArgs> = {
        [P in keyof T & keyof AggregateGenres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenres[P]>
      : GetScalarType<T[P], AggregateGenres[P]>
  }




  export type GenresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenresWhereInput
    orderBy?: GenresOrderByWithAggregationInput | GenresOrderByWithAggregationInput[]
    by: GenresScalarFieldEnum[] | GenresScalarFieldEnum
    having?: GenresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenresCountAggregateInputType | true
    _avg?: GenresAvgAggregateInputType
    _sum?: GenresSumAggregateInputType
    _min?: GenresMinAggregateInputType
    _max?: GenresMaxAggregateInputType
  }

  export type GenresGroupByOutputType = {
    typeId: number
    label: string
    _count: GenresCountAggregateOutputType | null
    _avg: GenresAvgAggregateOutputType | null
    _sum: GenresSumAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  type GetGenresGroupByPayload<T extends GenresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenresGroupByOutputType[P]>
            : GetScalarType<T[P], GenresGroupByOutputType[P]>
        }
      >
    >


  export type GenresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeId?: boolean
    label?: boolean
    projectGenres?: boolean | Genres$projectGenresArgs<ExtArgs>
    _count?: boolean | GenresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genres"]>



  export type GenresSelectScalar = {
    typeId?: boolean
    label?: boolean
  }

  export type GenresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"typeId" | "label", ExtArgs["result"]["genres"]>
  export type GenresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectGenres?: boolean | Genres$projectGenresArgs<ExtArgs>
    _count?: boolean | GenresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GenresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genres"
    objects: {
      projectGenres: Prisma.$ProjectGenresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      typeId: number
      label: string
    }, ExtArgs["result"]["genres"]>
    composites: {}
  }

  type GenresGetPayload<S extends boolean | null | undefined | GenresDefaultArgs> = $Result.GetResult<Prisma.$GenresPayload, S>

  type GenresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenresCountAggregateInputType | true
    }

  export interface GenresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genres'], meta: { name: 'Genres' } }
    /**
     * Find zero or one Genres that matches the filter.
     * @param {GenresFindUniqueArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenresFindUniqueArgs>(args: SelectSubset<T, GenresFindUniqueArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genres that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenresFindUniqueOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenresFindUniqueOrThrowArgs>(args: SelectSubset<T, GenresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindFirstArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenresFindFirstArgs>(args?: SelectSubset<T, GenresFindFirstArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindFirstOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenresFindFirstOrThrowArgs>(args?: SelectSubset<T, GenresFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genres.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genres.findMany({ take: 10 })
     * 
     * // Only select the `typeId`
     * const genresWithTypeIdOnly = await prisma.genres.findMany({ select: { typeId: true } })
     * 
     */
    findMany<T extends GenresFindManyArgs>(args?: SelectSubset<T, GenresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genres.
     * @param {GenresCreateArgs} args - Arguments to create a Genres.
     * @example
     * // Create one Genres
     * const Genres = await prisma.genres.create({
     *   data: {
     *     // ... data to create a Genres
     *   }
     * })
     * 
     */
    create<T extends GenresCreateArgs>(args: SelectSubset<T, GenresCreateArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenresCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genres = await prisma.genres.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenresCreateManyArgs>(args?: SelectSubset<T, GenresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Genres.
     * @param {GenresDeleteArgs} args - Arguments to delete one Genres.
     * @example
     * // Delete one Genres
     * const Genres = await prisma.genres.delete({
     *   where: {
     *     // ... filter to delete one Genres
     *   }
     * })
     * 
     */
    delete<T extends GenresDeleteArgs>(args: SelectSubset<T, GenresDeleteArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genres.
     * @param {GenresUpdateArgs} args - Arguments to update one Genres.
     * @example
     * // Update one Genres
     * const genres = await prisma.genres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenresUpdateArgs>(args: SelectSubset<T, GenresUpdateArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenresDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenresDeleteManyArgs>(args?: SelectSubset<T, GenresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genres = await prisma.genres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenresUpdateManyArgs>(args: SelectSubset<T, GenresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Genres.
     * @param {GenresUpsertArgs} args - Arguments to update or create a Genres.
     * @example
     * // Update or create a Genres
     * const genres = await prisma.genres.upsert({
     *   create: {
     *     // ... data to create a Genres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genres we want to update
     *   }
     * })
     */
    upsert<T extends GenresUpsertArgs>(args: SelectSubset<T, GenresUpsertArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genres.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenresCountArgs>(
      args?: Subset<T, GenresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenresAggregateArgs>(args: Subset<T, GenresAggregateArgs>): Prisma.PrismaPromise<GetGenresAggregateType<T>>

    /**
     * Group by Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenresGroupByArgs['orderBy'] }
        : { orderBy?: GenresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genres model
   */
  readonly fields: GenresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectGenres<T extends Genres$projectGenresArgs<ExtArgs> = {}>(args?: Subset<T, Genres$projectGenresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genres model
   */
  interface GenresFieldRefs {
    readonly typeId: FieldRef<"Genres", 'Int'>
    readonly label: FieldRef<"Genres", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genres findUnique
   */
  export type GenresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres findUniqueOrThrow
   */
  export type GenresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres findFirst
   */
  export type GenresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres findFirstOrThrow
   */
  export type GenresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres findMany
   */
  export type GenresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenresOrderByWithRelationInput | GenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * Genres create
   */
  export type GenresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The data needed to create a Genres.
     */
    data: XOR<GenresCreateInput, GenresUncheckedCreateInput>
  }

  /**
   * Genres createMany
   */
  export type GenresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenresCreateManyInput | GenresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genres update
   */
  export type GenresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The data needed to update a Genres.
     */
    data: XOR<GenresUpdateInput, GenresUncheckedUpdateInput>
    /**
     * Choose, which Genres to update.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres updateMany
   */
  export type GenresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenresUpdateManyMutationInput, GenresUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenresWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genres upsert
   */
  export type GenresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * The filter to search for the Genres to update in case it exists.
     */
    where: GenresWhereUniqueInput
    /**
     * In case the Genres found by the `where` argument doesn't exist, create a new Genres with this data.
     */
    create: XOR<GenresCreateInput, GenresUncheckedCreateInput>
    /**
     * In case the Genres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenresUpdateInput, GenresUncheckedUpdateInput>
  }

  /**
   * Genres delete
   */
  export type GenresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
    /**
     * Filter which Genres to delete.
     */
    where: GenresWhereUniqueInput
  }

  /**
   * Genres deleteMany
   */
  export type GenresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenresWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genres.projectGenres
   */
  export type Genres$projectGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    where?: ProjectGenresWhereInput
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    cursor?: ProjectGenresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGenresScalarFieldEnum | ProjectGenresScalarFieldEnum[]
  }

  /**
   * Genres without action
   */
  export type GenresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genres
     */
    select?: GenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genres
     */
    omit?: GenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenresInclude<ExtArgs> | null
  }


  /**
   * Model JobTitles
   */

  export type AggregateJobTitles = {
    _count: JobTitlesCountAggregateOutputType | null
    _avg: JobTitlesAvgAggregateOutputType | null
    _sum: JobTitlesSumAggregateOutputType | null
    _min: JobTitlesMinAggregateOutputType | null
    _max: JobTitlesMaxAggregateOutputType | null
  }

  export type JobTitlesAvgAggregateOutputType = {
    titleId: number | null
  }

  export type JobTitlesSumAggregateOutputType = {
    titleId: number | null
  }

  export type JobTitlesMinAggregateOutputType = {
    titleId: number | null
    label: string | null
  }

  export type JobTitlesMaxAggregateOutputType = {
    titleId: number | null
    label: string | null
  }

  export type JobTitlesCountAggregateOutputType = {
    titleId: number
    label: number
    _all: number
  }


  export type JobTitlesAvgAggregateInputType = {
    titleId?: true
  }

  export type JobTitlesSumAggregateInputType = {
    titleId?: true
  }

  export type JobTitlesMinAggregateInputType = {
    titleId?: true
    label?: true
  }

  export type JobTitlesMaxAggregateInputType = {
    titleId?: true
    label?: true
  }

  export type JobTitlesCountAggregateInputType = {
    titleId?: true
    label?: true
    _all?: true
  }

  export type JobTitlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitles to aggregate.
     */
    where?: JobTitlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitlesOrderByWithRelationInput | JobTitlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobTitlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobTitles
    **/
    _count?: true | JobTitlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobTitlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobTitlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobTitlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobTitlesMaxAggregateInputType
  }

  export type GetJobTitlesAggregateType<T extends JobTitlesAggregateArgs> = {
        [P in keyof T & keyof AggregateJobTitles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobTitles[P]>
      : GetScalarType<T[P], AggregateJobTitles[P]>
  }




  export type JobTitlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobTitlesWhereInput
    orderBy?: JobTitlesOrderByWithAggregationInput | JobTitlesOrderByWithAggregationInput[]
    by: JobTitlesScalarFieldEnum[] | JobTitlesScalarFieldEnum
    having?: JobTitlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobTitlesCountAggregateInputType | true
    _avg?: JobTitlesAvgAggregateInputType
    _sum?: JobTitlesSumAggregateInputType
    _min?: JobTitlesMinAggregateInputType
    _max?: JobTitlesMaxAggregateInputType
  }

  export type JobTitlesGroupByOutputType = {
    titleId: number
    label: string
    _count: JobTitlesCountAggregateOutputType | null
    _avg: JobTitlesAvgAggregateOutputType | null
    _sum: JobTitlesSumAggregateOutputType | null
    _min: JobTitlesMinAggregateOutputType | null
    _max: JobTitlesMaxAggregateOutputType | null
  }

  type GetJobTitlesGroupByPayload<T extends JobTitlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobTitlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobTitlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobTitlesGroupByOutputType[P]>
            : GetScalarType<T[P], JobTitlesGroupByOutputType[P]>
        }
      >
    >


  export type JobTitlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    titleId?: boolean
    label?: boolean
    jobs?: boolean | JobTitles$jobsArgs<ExtArgs>
    members?: boolean | JobTitles$membersArgs<ExtArgs>
    users?: boolean | JobTitles$usersArgs<ExtArgs>
    _count?: boolean | JobTitlesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobTitles"]>



  export type JobTitlesSelectScalar = {
    titleId?: boolean
    label?: boolean
  }

  export type JobTitlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"titleId" | "label", ExtArgs["result"]["jobTitles"]>
  export type JobTitlesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | JobTitles$jobsArgs<ExtArgs>
    members?: boolean | JobTitles$membersArgs<ExtArgs>
    users?: boolean | JobTitles$usersArgs<ExtArgs>
    _count?: boolean | JobTitlesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobTitlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobTitles"
    objects: {
      jobs: Prisma.$JobsPayload<ExtArgs>[]
      members: Prisma.$MembersPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      titleId: number
      label: string
    }, ExtArgs["result"]["jobTitles"]>
    composites: {}
  }

  type JobTitlesGetPayload<S extends boolean | null | undefined | JobTitlesDefaultArgs> = $Result.GetResult<Prisma.$JobTitlesPayload, S>

  type JobTitlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobTitlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobTitlesCountAggregateInputType | true
    }

  export interface JobTitlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobTitles'], meta: { name: 'JobTitles' } }
    /**
     * Find zero or one JobTitles that matches the filter.
     * @param {JobTitlesFindUniqueArgs} args - Arguments to find a JobTitles
     * @example
     * // Get one JobTitles
     * const jobTitles = await prisma.jobTitles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobTitlesFindUniqueArgs>(args: SelectSubset<T, JobTitlesFindUniqueArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobTitles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobTitlesFindUniqueOrThrowArgs} args - Arguments to find a JobTitles
     * @example
     * // Get one JobTitles
     * const jobTitles = await prisma.jobTitles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobTitlesFindUniqueOrThrowArgs>(args: SelectSubset<T, JobTitlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesFindFirstArgs} args - Arguments to find a JobTitles
     * @example
     * // Get one JobTitles
     * const jobTitles = await prisma.jobTitles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobTitlesFindFirstArgs>(args?: SelectSubset<T, JobTitlesFindFirstArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobTitles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesFindFirstOrThrowArgs} args - Arguments to find a JobTitles
     * @example
     * // Get one JobTitles
     * const jobTitles = await prisma.jobTitles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobTitlesFindFirstOrThrowArgs>(args?: SelectSubset<T, JobTitlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobTitles
     * const jobTitles = await prisma.jobTitles.findMany()
     * 
     * // Get first 10 JobTitles
     * const jobTitles = await prisma.jobTitles.findMany({ take: 10 })
     * 
     * // Only select the `titleId`
     * const jobTitlesWithTitleIdOnly = await prisma.jobTitles.findMany({ select: { titleId: true } })
     * 
     */
    findMany<T extends JobTitlesFindManyArgs>(args?: SelectSubset<T, JobTitlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobTitles.
     * @param {JobTitlesCreateArgs} args - Arguments to create a JobTitles.
     * @example
     * // Create one JobTitles
     * const JobTitles = await prisma.jobTitles.create({
     *   data: {
     *     // ... data to create a JobTitles
     *   }
     * })
     * 
     */
    create<T extends JobTitlesCreateArgs>(args: SelectSubset<T, JobTitlesCreateArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobTitles.
     * @param {JobTitlesCreateManyArgs} args - Arguments to create many JobTitles.
     * @example
     * // Create many JobTitles
     * const jobTitles = await prisma.jobTitles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobTitlesCreateManyArgs>(args?: SelectSubset<T, JobTitlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobTitles.
     * @param {JobTitlesDeleteArgs} args - Arguments to delete one JobTitles.
     * @example
     * // Delete one JobTitles
     * const JobTitles = await prisma.jobTitles.delete({
     *   where: {
     *     // ... filter to delete one JobTitles
     *   }
     * })
     * 
     */
    delete<T extends JobTitlesDeleteArgs>(args: SelectSubset<T, JobTitlesDeleteArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobTitles.
     * @param {JobTitlesUpdateArgs} args - Arguments to update one JobTitles.
     * @example
     * // Update one JobTitles
     * const jobTitles = await prisma.jobTitles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobTitlesUpdateArgs>(args: SelectSubset<T, JobTitlesUpdateArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobTitles.
     * @param {JobTitlesDeleteManyArgs} args - Arguments to filter JobTitles to delete.
     * @example
     * // Delete a few JobTitles
     * const { count } = await prisma.jobTitles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobTitlesDeleteManyArgs>(args?: SelectSubset<T, JobTitlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobTitles
     * const jobTitles = await prisma.jobTitles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobTitlesUpdateManyArgs>(args: SelectSubset<T, JobTitlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobTitles.
     * @param {JobTitlesUpsertArgs} args - Arguments to update or create a JobTitles.
     * @example
     * // Update or create a JobTitles
     * const jobTitles = await prisma.jobTitles.upsert({
     *   create: {
     *     // ... data to create a JobTitles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobTitles we want to update
     *   }
     * })
     */
    upsert<T extends JobTitlesUpsertArgs>(args: SelectSubset<T, JobTitlesUpsertArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesCountArgs} args - Arguments to filter JobTitles to count.
     * @example
     * // Count the number of JobTitles
     * const count = await prisma.jobTitles.count({
     *   where: {
     *     // ... the filter for the JobTitles we want to count
     *   }
     * })
    **/
    count<T extends JobTitlesCountArgs>(
      args?: Subset<T, JobTitlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobTitlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobTitlesAggregateArgs>(args: Subset<T, JobTitlesAggregateArgs>): Prisma.PrismaPromise<GetJobTitlesAggregateType<T>>

    /**
     * Group by JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobTitlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobTitlesGroupByArgs['orderBy'] }
        : { orderBy?: JobTitlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobTitlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobTitlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobTitles model
   */
  readonly fields: JobTitlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobTitles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobTitlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends JobTitles$jobsArgs<ExtArgs> = {}>(args?: Subset<T, JobTitles$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends JobTitles$membersArgs<ExtArgs> = {}>(args?: Subset<T, JobTitles$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends JobTitles$usersArgs<ExtArgs> = {}>(args?: Subset<T, JobTitles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobTitles model
   */
  interface JobTitlesFieldRefs {
    readonly titleId: FieldRef<"JobTitles", 'Int'>
    readonly label: FieldRef<"JobTitles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobTitles findUnique
   */
  export type JobTitlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where: JobTitlesWhereUniqueInput
  }

  /**
   * JobTitles findUniqueOrThrow
   */
  export type JobTitlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where: JobTitlesWhereUniqueInput
  }

  /**
   * JobTitles findFirst
   */
  export type JobTitlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where?: JobTitlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitlesOrderByWithRelationInput | JobTitlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitlesScalarFieldEnum | JobTitlesScalarFieldEnum[]
  }

  /**
   * JobTitles findFirstOrThrow
   */
  export type JobTitlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where?: JobTitlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitlesOrderByWithRelationInput | JobTitlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitlesScalarFieldEnum | JobTitlesScalarFieldEnum[]
  }

  /**
   * JobTitles findMany
   */
  export type JobTitlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where?: JobTitlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitlesOrderByWithRelationInput | JobTitlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobTitles.
     */
    cursor?: JobTitlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    distinct?: JobTitlesScalarFieldEnum | JobTitlesScalarFieldEnum[]
  }

  /**
   * JobTitles create
   */
  export type JobTitlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * The data needed to create a JobTitles.
     */
    data: XOR<JobTitlesCreateInput, JobTitlesUncheckedCreateInput>
  }

  /**
   * JobTitles createMany
   */
  export type JobTitlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobTitles.
     */
    data: JobTitlesCreateManyInput | JobTitlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobTitles update
   */
  export type JobTitlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * The data needed to update a JobTitles.
     */
    data: XOR<JobTitlesUpdateInput, JobTitlesUncheckedUpdateInput>
    /**
     * Choose, which JobTitles to update.
     */
    where: JobTitlesWhereUniqueInput
  }

  /**
   * JobTitles updateMany
   */
  export type JobTitlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobTitles.
     */
    data: XOR<JobTitlesUpdateManyMutationInput, JobTitlesUncheckedUpdateManyInput>
    /**
     * Filter which JobTitles to update
     */
    where?: JobTitlesWhereInput
    /**
     * Limit how many JobTitles to update.
     */
    limit?: number
  }

  /**
   * JobTitles upsert
   */
  export type JobTitlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * The filter to search for the JobTitles to update in case it exists.
     */
    where: JobTitlesWhereUniqueInput
    /**
     * In case the JobTitles found by the `where` argument doesn't exist, create a new JobTitles with this data.
     */
    create: XOR<JobTitlesCreateInput, JobTitlesUncheckedCreateInput>
    /**
     * In case the JobTitles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobTitlesUpdateInput, JobTitlesUncheckedUpdateInput>
  }

  /**
   * JobTitles delete
   */
  export type JobTitlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    /**
     * Filter which JobTitles to delete.
     */
    where: JobTitlesWhereUniqueInput
  }

  /**
   * JobTitles deleteMany
   */
  export type JobTitlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitles to delete
     */
    where?: JobTitlesWhereInput
    /**
     * Limit how many JobTitles to delete.
     */
    limit?: number
  }

  /**
   * JobTitles.jobs
   */
  export type JobTitles$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * JobTitles.members
   */
  export type JobTitles$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    where?: MembersWhereInput
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    cursor?: MembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * JobTitles.users
   */
  export type JobTitles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * JobTitles without action
   */
  export type JobTitlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
  }


  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    projectId: number | null
    titleId: number | null
  }

  export type JobsSumAggregateOutputType = {
    projectId: number | null
    titleId: number | null
  }

  export type JobsMinAggregateOutputType = {
    projectId: number | null
    titleId: number | null
    availability: $Enums.JobsAvailability | null
    duration: $Enums.JobsDuration | null
    location: $Enums.JobsLocation | null
    compensation: $Enums.JobsCompensation | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobsMaxAggregateOutputType = {
    projectId: number | null
    titleId: number | null
    availability: $Enums.JobsAvailability | null
    duration: $Enums.JobsDuration | null
    location: $Enums.JobsLocation | null
    compensation: $Enums.JobsCompensation | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobsCountAggregateOutputType = {
    projectId: number
    titleId: number
    availability: number
    duration: number
    location: number
    compensation: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    projectId?: true
    titleId?: true
  }

  export type JobsSumAggregateInputType = {
    projectId?: true
    titleId?: true
  }

  export type JobsMinAggregateInputType = {
    projectId?: true
    titleId?: true
    availability?: true
    duration?: true
    location?: true
    compensation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobsMaxAggregateInputType = {
    projectId?: true
    titleId?: true
    availability?: true
    duration?: true
    location?: true
    compensation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobsCountAggregateInputType = {
    projectId?: true
    titleId?: true
    availability?: true
    duration?: true
    location?: true
    compensation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    projectId: number
    titleId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    titleId?: boolean
    availability?: boolean
    duration?: boolean
    location?: boolean
    compensation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    jobTitles?: boolean | JobTitlesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>



  export type JobsSelectScalar = {
    projectId?: boolean
    titleId?: boolean
    availability?: boolean
    duration?: boolean
    location?: boolean
    compensation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "titleId" | "availability" | "duration" | "location" | "compensation" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["jobs"]>
  export type JobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    jobTitles?: boolean | JobTitlesDefaultArgs<ExtArgs>
  }

  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {
      projects: Prisma.$ProjectsPayload<ExtArgs>
      jobTitles: Prisma.$JobTitlesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      titleId: number
      availability: $Enums.JobsAvailability
      duration: $Enums.JobsDuration
      location: $Enums.JobsLocation
      compensation: $Enums.JobsCompensation
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsFindUniqueArgs>(args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsFindFirstArgs>(args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const jobsWithProjectIdOnly = await prisma.jobs.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends JobsFindManyArgs>(args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends JobsCreateArgs>(args: SelectSubset<T, JobsCreateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsCreateManyArgs>(args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends JobsDeleteArgs>(args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsUpdateArgs>(args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsDeleteManyArgs>(args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsUpdateManyArgs>(args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends JobsUpsertArgs>(args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobTitles<T extends JobTitlesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobTitlesDefaultArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobs model
   */
  interface JobsFieldRefs {
    readonly projectId: FieldRef<"Jobs", 'Int'>
    readonly titleId: FieldRef<"Jobs", 'Int'>
    readonly availability: FieldRef<"Jobs", 'JobsAvailability'>
    readonly duration: FieldRef<"Jobs", 'JobsDuration'>
    readonly location: FieldRef<"Jobs", 'JobsLocation'>
    readonly compensation: FieldRef<"Jobs", 'JobsCompensation'>
    readonly description: FieldRef<"Jobs", 'String'>
    readonly createdAt: FieldRef<"Jobs", 'DateTime'>
    readonly updatedAt: FieldRef<"Jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
  }


  /**
   * Model Majors
   */

  export type AggregateMajors = {
    _count: MajorsCountAggregateOutputType | null
    _avg: MajorsAvgAggregateOutputType | null
    _sum: MajorsSumAggregateOutputType | null
    _min: MajorsMinAggregateOutputType | null
    _max: MajorsMaxAggregateOutputType | null
  }

  export type MajorsAvgAggregateOutputType = {
    majorId: number | null
  }

  export type MajorsSumAggregateOutputType = {
    majorId: number | null
  }

  export type MajorsMinAggregateOutputType = {
    majorId: number | null
    label: string | null
  }

  export type MajorsMaxAggregateOutputType = {
    majorId: number | null
    label: string | null
  }

  export type MajorsCountAggregateOutputType = {
    majorId: number
    label: number
    _all: number
  }


  export type MajorsAvgAggregateInputType = {
    majorId?: true
  }

  export type MajorsSumAggregateInputType = {
    majorId?: true
  }

  export type MajorsMinAggregateInputType = {
    majorId?: true
    label?: true
  }

  export type MajorsMaxAggregateInputType = {
    majorId?: true
    label?: true
  }

  export type MajorsCountAggregateInputType = {
    majorId?: true
    label?: true
    _all?: true
  }

  export type MajorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Majors to aggregate.
     */
    where?: MajorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Majors to fetch.
     */
    orderBy?: MajorsOrderByWithRelationInput | MajorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MajorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Majors
    **/
    _count?: true | MajorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MajorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MajorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MajorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MajorsMaxAggregateInputType
  }

  export type GetMajorsAggregateType<T extends MajorsAggregateArgs> = {
        [P in keyof T & keyof AggregateMajors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMajors[P]>
      : GetScalarType<T[P], AggregateMajors[P]>
  }




  export type MajorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MajorsWhereInput
    orderBy?: MajorsOrderByWithAggregationInput | MajorsOrderByWithAggregationInput[]
    by: MajorsScalarFieldEnum[] | MajorsScalarFieldEnum
    having?: MajorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MajorsCountAggregateInputType | true
    _avg?: MajorsAvgAggregateInputType
    _sum?: MajorsSumAggregateInputType
    _min?: MajorsMinAggregateInputType
    _max?: MajorsMaxAggregateInputType
  }

  export type MajorsGroupByOutputType = {
    majorId: number
    label: string
    _count: MajorsCountAggregateOutputType | null
    _avg: MajorsAvgAggregateOutputType | null
    _sum: MajorsSumAggregateOutputType | null
    _min: MajorsMinAggregateOutputType | null
    _max: MajorsMaxAggregateOutputType | null
  }

  type GetMajorsGroupByPayload<T extends MajorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MajorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MajorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MajorsGroupByOutputType[P]>
            : GetScalarType<T[P], MajorsGroupByOutputType[P]>
        }
      >
    >


  export type MajorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    majorId?: boolean
    label?: boolean
    users?: boolean | Majors$usersArgs<ExtArgs>
    _count?: boolean | MajorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["majors"]>



  export type MajorsSelectScalar = {
    majorId?: boolean
    label?: boolean
  }

  export type MajorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"majorId" | "label", ExtArgs["result"]["majors"]>
  export type MajorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Majors$usersArgs<ExtArgs>
    _count?: boolean | MajorsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MajorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Majors"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      majorId: number
      label: string
    }, ExtArgs["result"]["majors"]>
    composites: {}
  }

  type MajorsGetPayload<S extends boolean | null | undefined | MajorsDefaultArgs> = $Result.GetResult<Prisma.$MajorsPayload, S>

  type MajorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MajorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MajorsCountAggregateInputType | true
    }

  export interface MajorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Majors'], meta: { name: 'Majors' } }
    /**
     * Find zero or one Majors that matches the filter.
     * @param {MajorsFindUniqueArgs} args - Arguments to find a Majors
     * @example
     * // Get one Majors
     * const majors = await prisma.majors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MajorsFindUniqueArgs>(args: SelectSubset<T, MajorsFindUniqueArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Majors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MajorsFindUniqueOrThrowArgs} args - Arguments to find a Majors
     * @example
     * // Get one Majors
     * const majors = await prisma.majors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MajorsFindUniqueOrThrowArgs>(args: SelectSubset<T, MajorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Majors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsFindFirstArgs} args - Arguments to find a Majors
     * @example
     * // Get one Majors
     * const majors = await prisma.majors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MajorsFindFirstArgs>(args?: SelectSubset<T, MajorsFindFirstArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Majors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsFindFirstOrThrowArgs} args - Arguments to find a Majors
     * @example
     * // Get one Majors
     * const majors = await prisma.majors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MajorsFindFirstOrThrowArgs>(args?: SelectSubset<T, MajorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Majors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Majors
     * const majors = await prisma.majors.findMany()
     * 
     * // Get first 10 Majors
     * const majors = await prisma.majors.findMany({ take: 10 })
     * 
     * // Only select the `majorId`
     * const majorsWithMajorIdOnly = await prisma.majors.findMany({ select: { majorId: true } })
     * 
     */
    findMany<T extends MajorsFindManyArgs>(args?: SelectSubset<T, MajorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Majors.
     * @param {MajorsCreateArgs} args - Arguments to create a Majors.
     * @example
     * // Create one Majors
     * const Majors = await prisma.majors.create({
     *   data: {
     *     // ... data to create a Majors
     *   }
     * })
     * 
     */
    create<T extends MajorsCreateArgs>(args: SelectSubset<T, MajorsCreateArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Majors.
     * @param {MajorsCreateManyArgs} args - Arguments to create many Majors.
     * @example
     * // Create many Majors
     * const majors = await prisma.majors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MajorsCreateManyArgs>(args?: SelectSubset<T, MajorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Majors.
     * @param {MajorsDeleteArgs} args - Arguments to delete one Majors.
     * @example
     * // Delete one Majors
     * const Majors = await prisma.majors.delete({
     *   where: {
     *     // ... filter to delete one Majors
     *   }
     * })
     * 
     */
    delete<T extends MajorsDeleteArgs>(args: SelectSubset<T, MajorsDeleteArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Majors.
     * @param {MajorsUpdateArgs} args - Arguments to update one Majors.
     * @example
     * // Update one Majors
     * const majors = await prisma.majors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MajorsUpdateArgs>(args: SelectSubset<T, MajorsUpdateArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Majors.
     * @param {MajorsDeleteManyArgs} args - Arguments to filter Majors to delete.
     * @example
     * // Delete a few Majors
     * const { count } = await prisma.majors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MajorsDeleteManyArgs>(args?: SelectSubset<T, MajorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Majors
     * const majors = await prisma.majors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MajorsUpdateManyArgs>(args: SelectSubset<T, MajorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Majors.
     * @param {MajorsUpsertArgs} args - Arguments to update or create a Majors.
     * @example
     * // Update or create a Majors
     * const majors = await prisma.majors.upsert({
     *   create: {
     *     // ... data to create a Majors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Majors we want to update
     *   }
     * })
     */
    upsert<T extends MajorsUpsertArgs>(args: SelectSubset<T, MajorsUpsertArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsCountArgs} args - Arguments to filter Majors to count.
     * @example
     * // Count the number of Majors
     * const count = await prisma.majors.count({
     *   where: {
     *     // ... the filter for the Majors we want to count
     *   }
     * })
    **/
    count<T extends MajorsCountArgs>(
      args?: Subset<T, MajorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MajorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MajorsAggregateArgs>(args: Subset<T, MajorsAggregateArgs>): Prisma.PrismaPromise<GetMajorsAggregateType<T>>

    /**
     * Group by Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MajorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MajorsGroupByArgs['orderBy'] }
        : { orderBy?: MajorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MajorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMajorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Majors model
   */
  readonly fields: MajorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Majors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MajorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Majors$usersArgs<ExtArgs> = {}>(args?: Subset<T, Majors$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Majors model
   */
  interface MajorsFieldRefs {
    readonly majorId: FieldRef<"Majors", 'Int'>
    readonly label: FieldRef<"Majors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Majors findUnique
   */
  export type MajorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter, which Majors to fetch.
     */
    where: MajorsWhereUniqueInput
  }

  /**
   * Majors findUniqueOrThrow
   */
  export type MajorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter, which Majors to fetch.
     */
    where: MajorsWhereUniqueInput
  }

  /**
   * Majors findFirst
   */
  export type MajorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter, which Majors to fetch.
     */
    where?: MajorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Majors to fetch.
     */
    orderBy?: MajorsOrderByWithRelationInput | MajorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Majors.
     */
    cursor?: MajorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Majors.
     */
    distinct?: MajorsScalarFieldEnum | MajorsScalarFieldEnum[]
  }

  /**
   * Majors findFirstOrThrow
   */
  export type MajorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter, which Majors to fetch.
     */
    where?: MajorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Majors to fetch.
     */
    orderBy?: MajorsOrderByWithRelationInput | MajorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Majors.
     */
    cursor?: MajorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Majors.
     */
    distinct?: MajorsScalarFieldEnum | MajorsScalarFieldEnum[]
  }

  /**
   * Majors findMany
   */
  export type MajorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter, which Majors to fetch.
     */
    where?: MajorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Majors to fetch.
     */
    orderBy?: MajorsOrderByWithRelationInput | MajorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Majors.
     */
    cursor?: MajorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Majors.
     */
    skip?: number
    distinct?: MajorsScalarFieldEnum | MajorsScalarFieldEnum[]
  }

  /**
   * Majors create
   */
  export type MajorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Majors.
     */
    data: XOR<MajorsCreateInput, MajorsUncheckedCreateInput>
  }

  /**
   * Majors createMany
   */
  export type MajorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Majors.
     */
    data: MajorsCreateManyInput | MajorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Majors update
   */
  export type MajorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Majors.
     */
    data: XOR<MajorsUpdateInput, MajorsUncheckedUpdateInput>
    /**
     * Choose, which Majors to update.
     */
    where: MajorsWhereUniqueInput
  }

  /**
   * Majors updateMany
   */
  export type MajorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Majors.
     */
    data: XOR<MajorsUpdateManyMutationInput, MajorsUncheckedUpdateManyInput>
    /**
     * Filter which Majors to update
     */
    where?: MajorsWhereInput
    /**
     * Limit how many Majors to update.
     */
    limit?: number
  }

  /**
   * Majors upsert
   */
  export type MajorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Majors to update in case it exists.
     */
    where: MajorsWhereUniqueInput
    /**
     * In case the Majors found by the `where` argument doesn't exist, create a new Majors with this data.
     */
    create: XOR<MajorsCreateInput, MajorsUncheckedCreateInput>
    /**
     * In case the Majors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MajorsUpdateInput, MajorsUncheckedUpdateInput>
  }

  /**
   * Majors delete
   */
  export type MajorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    /**
     * Filter which Majors to delete.
     */
    where: MajorsWhereUniqueInput
  }

  /**
   * Majors deleteMany
   */
  export type MajorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Majors to delete
     */
    where?: MajorsWhereInput
    /**
     * Limit how many Majors to delete.
     */
    limit?: number
  }

  /**
   * Majors.users
   */
  export type Majors$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Majors without action
   */
  export type MajorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
  }


  /**
   * Model Members
   */

  export type AggregateMembers = {
    _count: MembersCountAggregateOutputType | null
    _avg: MembersAvgAggregateOutputType | null
    _sum: MembersSumAggregateOutputType | null
    _min: MembersMinAggregateOutputType | null
    _max: MembersMaxAggregateOutputType | null
  }

  export type MembersAvgAggregateOutputType = {
    projectId: number | null
    userId: number | null
    titleId: number | null
  }

  export type MembersSumAggregateOutputType = {
    projectId: number | null
    userId: number | null
    titleId: number | null
  }

  export type MembersMinAggregateOutputType = {
    projectId: number | null
    userId: number | null
    titleId: number | null
    profileVisibility: $Enums.MembersProfileVisibility | null
    createdAt: Date | null
  }

  export type MembersMaxAggregateOutputType = {
    projectId: number | null
    userId: number | null
    titleId: number | null
    profileVisibility: $Enums.MembersProfileVisibility | null
    createdAt: Date | null
  }

  export type MembersCountAggregateOutputType = {
    projectId: number
    userId: number
    titleId: number
    profileVisibility: number
    createdAt: number
    _all: number
  }


  export type MembersAvgAggregateInputType = {
    projectId?: true
    userId?: true
    titleId?: true
  }

  export type MembersSumAggregateInputType = {
    projectId?: true
    userId?: true
    titleId?: true
  }

  export type MembersMinAggregateInputType = {
    projectId?: true
    userId?: true
    titleId?: true
    profileVisibility?: true
    createdAt?: true
  }

  export type MembersMaxAggregateInputType = {
    projectId?: true
    userId?: true
    titleId?: true
    profileVisibility?: true
    createdAt?: true
  }

  export type MembersCountAggregateInputType = {
    projectId?: true
    userId?: true
    titleId?: true
    profileVisibility?: true
    createdAt?: true
    _all?: true
  }

  export type MembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to aggregate.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembersMaxAggregateInputType
  }

  export type GetMembersAggregateType<T extends MembersAggregateArgs> = {
        [P in keyof T & keyof AggregateMembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembers[P]>
      : GetScalarType<T[P], AggregateMembers[P]>
  }




  export type MembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersWhereInput
    orderBy?: MembersOrderByWithAggregationInput | MembersOrderByWithAggregationInput[]
    by: MembersScalarFieldEnum[] | MembersScalarFieldEnum
    having?: MembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembersCountAggregateInputType | true
    _avg?: MembersAvgAggregateInputType
    _sum?: MembersSumAggregateInputType
    _min?: MembersMinAggregateInputType
    _max?: MembersMaxAggregateInputType
  }

  export type MembersGroupByOutputType = {
    projectId: number
    userId: number
    titleId: number
    profileVisibility: $Enums.MembersProfileVisibility
    createdAt: Date
    _count: MembersCountAggregateOutputType | null
    _avg: MembersAvgAggregateOutputType | null
    _sum: MembersSumAggregateOutputType | null
    _min: MembersMinAggregateOutputType | null
    _max: MembersMaxAggregateOutputType | null
  }

  type GetMembersGroupByPayload<T extends MembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembersGroupByOutputType[P]>
            : GetScalarType<T[P], MembersGroupByOutputType[P]>
        }
      >
    >


  export type MembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    userId?: boolean
    titleId?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
    jobTitles?: boolean | JobTitlesDefaultArgs<ExtArgs>
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["members"]>



  export type MembersSelectScalar = {
    projectId?: boolean
    userId?: boolean
    titleId?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
  }

  export type MembersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "userId" | "titleId" | "profileVisibility" | "createdAt", ExtArgs["result"]["members"]>
  export type MembersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobTitles?: boolean | JobTitlesDefaultArgs<ExtArgs>
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Members"
    objects: {
      jobTitles: Prisma.$JobTitlesPayload<ExtArgs>
      projects: Prisma.$ProjectsPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      userId: number
      titleId: number
      profileVisibility: $Enums.MembersProfileVisibility
      createdAt: Date
    }, ExtArgs["result"]["members"]>
    composites: {}
  }

  type MembersGetPayload<S extends boolean | null | undefined | MembersDefaultArgs> = $Result.GetResult<Prisma.$MembersPayload, S>

  type MembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembersCountAggregateInputType | true
    }

  export interface MembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Members'], meta: { name: 'Members' } }
    /**
     * Find zero or one Members that matches the filter.
     * @param {MembersFindUniqueArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembersFindUniqueArgs>(args: SelectSubset<T, MembersFindUniqueArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembersFindUniqueOrThrowArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembersFindUniqueOrThrowArgs>(args: SelectSubset<T, MembersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindFirstArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembersFindFirstArgs>(args?: SelectSubset<T, MembersFindFirstArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindFirstOrThrowArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembersFindFirstOrThrowArgs>(args?: SelectSubset<T, MembersFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.members.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.members.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const membersWithProjectIdOnly = await prisma.members.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends MembersFindManyArgs>(args?: SelectSubset<T, MembersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Members.
     * @param {MembersCreateArgs} args - Arguments to create a Members.
     * @example
     * // Create one Members
     * const Members = await prisma.members.create({
     *   data: {
     *     // ... data to create a Members
     *   }
     * })
     * 
     */
    create<T extends MembersCreateArgs>(args: SelectSubset<T, MembersCreateArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MembersCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const members = await prisma.members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembersCreateManyArgs>(args?: SelectSubset<T, MembersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Members.
     * @param {MembersDeleteArgs} args - Arguments to delete one Members.
     * @example
     * // Delete one Members
     * const Members = await prisma.members.delete({
     *   where: {
     *     // ... filter to delete one Members
     *   }
     * })
     * 
     */
    delete<T extends MembersDeleteArgs>(args: SelectSubset<T, MembersDeleteArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Members.
     * @param {MembersUpdateArgs} args - Arguments to update one Members.
     * @example
     * // Update one Members
     * const members = await prisma.members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembersUpdateArgs>(args: SelectSubset<T, MembersUpdateArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MembersDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembersDeleteManyArgs>(args?: SelectSubset<T, MembersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const members = await prisma.members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembersUpdateManyArgs>(args: SelectSubset<T, MembersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Members.
     * @param {MembersUpsertArgs} args - Arguments to update or create a Members.
     * @example
     * // Update or create a Members
     * const members = await prisma.members.upsert({
     *   create: {
     *     // ... data to create a Members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Members we want to update
     *   }
     * })
     */
    upsert<T extends MembersUpsertArgs>(args: SelectSubset<T, MembersUpsertArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.members.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MembersCountArgs>(
      args?: Subset<T, MembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembersAggregateArgs>(args: Subset<T, MembersAggregateArgs>): Prisma.PrismaPromise<GetMembersAggregateType<T>>

    /**
     * Group by Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembersGroupByArgs['orderBy'] }
        : { orderBy?: MembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Members model
   */
  readonly fields: MembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobTitles<T extends JobTitlesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobTitlesDefaultArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Members model
   */
  interface MembersFieldRefs {
    readonly projectId: FieldRef<"Members", 'Int'>
    readonly userId: FieldRef<"Members", 'Int'>
    readonly titleId: FieldRef<"Members", 'Int'>
    readonly profileVisibility: FieldRef<"Members", 'MembersProfileVisibility'>
    readonly createdAt: FieldRef<"Members", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Members findUnique
   */
  export type MembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members findUniqueOrThrow
   */
  export type MembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members findFirst
   */
  export type MembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members findFirstOrThrow
   */
  export type MembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members findMany
   */
  export type MembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members create
   */
  export type MembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The data needed to create a Members.
     */
    data: XOR<MembersCreateInput, MembersUncheckedCreateInput>
  }

  /**
   * Members createMany
   */
  export type MembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MembersCreateManyInput | MembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Members update
   */
  export type MembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The data needed to update a Members.
     */
    data: XOR<MembersUpdateInput, MembersUncheckedUpdateInput>
    /**
     * Choose, which Members to update.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members updateMany
   */
  export type MembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MembersUpdateManyMutationInput, MembersUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MembersWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Members upsert
   */
  export type MembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The filter to search for the Members to update in case it exists.
     */
    where: MembersWhereUniqueInput
    /**
     * In case the Members found by the `where` argument doesn't exist, create a new Members with this data.
     */
    create: XOR<MembersCreateInput, MembersUncheckedCreateInput>
    /**
     * In case the Members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembersUpdateInput, MembersUncheckedUpdateInput>
  }

  /**
   * Members delete
   */
  export type MembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter which Members to delete.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members deleteMany
   */
  export type MembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MembersWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Members without action
   */
  export type MembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
  }


  /**
   * Model ProjectFollowings
   */

  export type AggregateProjectFollowings = {
    _count: ProjectFollowingsCountAggregateOutputType | null
    _avg: ProjectFollowingsAvgAggregateOutputType | null
    _sum: ProjectFollowingsSumAggregateOutputType | null
    _min: ProjectFollowingsMinAggregateOutputType | null
    _max: ProjectFollowingsMaxAggregateOutputType | null
  }

  export type ProjectFollowingsAvgAggregateOutputType = {
    userId: number | null
    projectId: number | null
  }

  export type ProjectFollowingsSumAggregateOutputType = {
    userId: number | null
    projectId: number | null
  }

  export type ProjectFollowingsMinAggregateOutputType = {
    userId: number | null
    projectId: number | null
    followedAt: Date | null
  }

  export type ProjectFollowingsMaxAggregateOutputType = {
    userId: number | null
    projectId: number | null
    followedAt: Date | null
  }

  export type ProjectFollowingsCountAggregateOutputType = {
    userId: number
    projectId: number
    followedAt: number
    _all: number
  }


  export type ProjectFollowingsAvgAggregateInputType = {
    userId?: true
    projectId?: true
  }

  export type ProjectFollowingsSumAggregateInputType = {
    userId?: true
    projectId?: true
  }

  export type ProjectFollowingsMinAggregateInputType = {
    userId?: true
    projectId?: true
    followedAt?: true
  }

  export type ProjectFollowingsMaxAggregateInputType = {
    userId?: true
    projectId?: true
    followedAt?: true
  }

  export type ProjectFollowingsCountAggregateInputType = {
    userId?: true
    projectId?: true
    followedAt?: true
    _all?: true
  }

  export type ProjectFollowingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFollowings to aggregate.
     */
    where?: ProjectFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFollowings to fetch.
     */
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectFollowings
    **/
    _count?: true | ProjectFollowingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectFollowingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectFollowingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectFollowingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectFollowingsMaxAggregateInputType
  }

  export type GetProjectFollowingsAggregateType<T extends ProjectFollowingsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectFollowings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectFollowings[P]>
      : GetScalarType<T[P], AggregateProjectFollowings[P]>
  }




  export type ProjectFollowingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFollowingsWhereInput
    orderBy?: ProjectFollowingsOrderByWithAggregationInput | ProjectFollowingsOrderByWithAggregationInput[]
    by: ProjectFollowingsScalarFieldEnum[] | ProjectFollowingsScalarFieldEnum
    having?: ProjectFollowingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectFollowingsCountAggregateInputType | true
    _avg?: ProjectFollowingsAvgAggregateInputType
    _sum?: ProjectFollowingsSumAggregateInputType
    _min?: ProjectFollowingsMinAggregateInputType
    _max?: ProjectFollowingsMaxAggregateInputType
  }

  export type ProjectFollowingsGroupByOutputType = {
    userId: number
    projectId: number
    followedAt: Date
    _count: ProjectFollowingsCountAggregateOutputType | null
    _avg: ProjectFollowingsAvgAggregateOutputType | null
    _sum: ProjectFollowingsSumAggregateOutputType | null
    _min: ProjectFollowingsMinAggregateOutputType | null
    _max: ProjectFollowingsMaxAggregateOutputType | null
  }

  type GetProjectFollowingsGroupByPayload<T extends ProjectFollowingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectFollowingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectFollowingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectFollowingsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectFollowingsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectFollowingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    projectId?: boolean
    followedAt?: boolean
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFollowings"]>



  export type ProjectFollowingsSelectScalar = {
    userId?: boolean
    projectId?: boolean
    followedAt?: boolean
  }

  export type ProjectFollowingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "projectId" | "followedAt", ExtArgs["result"]["projectFollowings"]>
  export type ProjectFollowingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ProjectFollowingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectFollowings"
    objects: {
      projects: Prisma.$ProjectsPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      projectId: number
      followedAt: Date
    }, ExtArgs["result"]["projectFollowings"]>
    composites: {}
  }

  type ProjectFollowingsGetPayload<S extends boolean | null | undefined | ProjectFollowingsDefaultArgs> = $Result.GetResult<Prisma.$ProjectFollowingsPayload, S>

  type ProjectFollowingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFollowingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectFollowingsCountAggregateInputType | true
    }

  export interface ProjectFollowingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectFollowings'], meta: { name: 'ProjectFollowings' } }
    /**
     * Find zero or one ProjectFollowings that matches the filter.
     * @param {ProjectFollowingsFindUniqueArgs} args - Arguments to find a ProjectFollowings
     * @example
     * // Get one ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFollowingsFindUniqueArgs>(args: SelectSubset<T, ProjectFollowingsFindUniqueArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectFollowings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFollowingsFindUniqueOrThrowArgs} args - Arguments to find a ProjectFollowings
     * @example
     * // Get one ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFollowingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFollowingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFollowings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsFindFirstArgs} args - Arguments to find a ProjectFollowings
     * @example
     * // Get one ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFollowingsFindFirstArgs>(args?: SelectSubset<T, ProjectFollowingsFindFirstArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFollowings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsFindFirstOrThrowArgs} args - Arguments to find a ProjectFollowings
     * @example
     * // Get one ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFollowingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFollowingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectFollowings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findMany()
     * 
     * // Get first 10 ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const projectFollowingsWithUserIdOnly = await prisma.projectFollowings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProjectFollowingsFindManyArgs>(args?: SelectSubset<T, ProjectFollowingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectFollowings.
     * @param {ProjectFollowingsCreateArgs} args - Arguments to create a ProjectFollowings.
     * @example
     * // Create one ProjectFollowings
     * const ProjectFollowings = await prisma.projectFollowings.create({
     *   data: {
     *     // ... data to create a ProjectFollowings
     *   }
     * })
     * 
     */
    create<T extends ProjectFollowingsCreateArgs>(args: SelectSubset<T, ProjectFollowingsCreateArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectFollowings.
     * @param {ProjectFollowingsCreateManyArgs} args - Arguments to create many ProjectFollowings.
     * @example
     * // Create many ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectFollowingsCreateManyArgs>(args?: SelectSubset<T, ProjectFollowingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectFollowings.
     * @param {ProjectFollowingsDeleteArgs} args - Arguments to delete one ProjectFollowings.
     * @example
     * // Delete one ProjectFollowings
     * const ProjectFollowings = await prisma.projectFollowings.delete({
     *   where: {
     *     // ... filter to delete one ProjectFollowings
     *   }
     * })
     * 
     */
    delete<T extends ProjectFollowingsDeleteArgs>(args: SelectSubset<T, ProjectFollowingsDeleteArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectFollowings.
     * @param {ProjectFollowingsUpdateArgs} args - Arguments to update one ProjectFollowings.
     * @example
     * // Update one ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectFollowingsUpdateArgs>(args: SelectSubset<T, ProjectFollowingsUpdateArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectFollowings.
     * @param {ProjectFollowingsDeleteManyArgs} args - Arguments to filter ProjectFollowings to delete.
     * @example
     * // Delete a few ProjectFollowings
     * const { count } = await prisma.projectFollowings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectFollowingsDeleteManyArgs>(args?: SelectSubset<T, ProjectFollowingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectFollowingsUpdateManyArgs>(args: SelectSubset<T, ProjectFollowingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectFollowings.
     * @param {ProjectFollowingsUpsertArgs} args - Arguments to update or create a ProjectFollowings.
     * @example
     * // Update or create a ProjectFollowings
     * const projectFollowings = await prisma.projectFollowings.upsert({
     *   create: {
     *     // ... data to create a ProjectFollowings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectFollowings we want to update
     *   }
     * })
     */
    upsert<T extends ProjectFollowingsUpsertArgs>(args: SelectSubset<T, ProjectFollowingsUpsertArgs<ExtArgs>>): Prisma__ProjectFollowingsClient<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsCountArgs} args - Arguments to filter ProjectFollowings to count.
     * @example
     * // Count the number of ProjectFollowings
     * const count = await prisma.projectFollowings.count({
     *   where: {
     *     // ... the filter for the ProjectFollowings we want to count
     *   }
     * })
    **/
    count<T extends ProjectFollowingsCountArgs>(
      args?: Subset<T, ProjectFollowingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectFollowingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectFollowingsAggregateArgs>(args: Subset<T, ProjectFollowingsAggregateArgs>): Prisma.PrismaPromise<GetProjectFollowingsAggregateType<T>>

    /**
     * Group by ProjectFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFollowingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectFollowingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectFollowingsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectFollowingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectFollowingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectFollowingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectFollowings model
   */
  readonly fields: ProjectFollowingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectFollowings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectFollowingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectFollowings model
   */
  interface ProjectFollowingsFieldRefs {
    readonly userId: FieldRef<"ProjectFollowings", 'Int'>
    readonly projectId: FieldRef<"ProjectFollowings", 'Int'>
    readonly followedAt: FieldRef<"ProjectFollowings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectFollowings findUnique
   */
  export type ProjectFollowingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFollowings to fetch.
     */
    where: ProjectFollowingsWhereUniqueInput
  }

  /**
   * ProjectFollowings findUniqueOrThrow
   */
  export type ProjectFollowingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFollowings to fetch.
     */
    where: ProjectFollowingsWhereUniqueInput
  }

  /**
   * ProjectFollowings findFirst
   */
  export type ProjectFollowingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFollowings to fetch.
     */
    where?: ProjectFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFollowings to fetch.
     */
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFollowings.
     */
    cursor?: ProjectFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFollowings.
     */
    distinct?: ProjectFollowingsScalarFieldEnum | ProjectFollowingsScalarFieldEnum[]
  }

  /**
   * ProjectFollowings findFirstOrThrow
   */
  export type ProjectFollowingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFollowings to fetch.
     */
    where?: ProjectFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFollowings to fetch.
     */
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFollowings.
     */
    cursor?: ProjectFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFollowings.
     */
    distinct?: ProjectFollowingsScalarFieldEnum | ProjectFollowingsScalarFieldEnum[]
  }

  /**
   * ProjectFollowings findMany
   */
  export type ProjectFollowingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFollowings to fetch.
     */
    where?: ProjectFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFollowings to fetch.
     */
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectFollowings.
     */
    cursor?: ProjectFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFollowings.
     */
    skip?: number
    distinct?: ProjectFollowingsScalarFieldEnum | ProjectFollowingsScalarFieldEnum[]
  }

  /**
   * ProjectFollowings create
   */
  export type ProjectFollowingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectFollowings.
     */
    data: XOR<ProjectFollowingsCreateInput, ProjectFollowingsUncheckedCreateInput>
  }

  /**
   * ProjectFollowings createMany
   */
  export type ProjectFollowingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectFollowings.
     */
    data: ProjectFollowingsCreateManyInput | ProjectFollowingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectFollowings update
   */
  export type ProjectFollowingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectFollowings.
     */
    data: XOR<ProjectFollowingsUpdateInput, ProjectFollowingsUncheckedUpdateInput>
    /**
     * Choose, which ProjectFollowings to update.
     */
    where: ProjectFollowingsWhereUniqueInput
  }

  /**
   * ProjectFollowings updateMany
   */
  export type ProjectFollowingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectFollowings.
     */
    data: XOR<ProjectFollowingsUpdateManyMutationInput, ProjectFollowingsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFollowings to update
     */
    where?: ProjectFollowingsWhereInput
    /**
     * Limit how many ProjectFollowings to update.
     */
    limit?: number
  }

  /**
   * ProjectFollowings upsert
   */
  export type ProjectFollowingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectFollowings to update in case it exists.
     */
    where: ProjectFollowingsWhereUniqueInput
    /**
     * In case the ProjectFollowings found by the `where` argument doesn't exist, create a new ProjectFollowings with this data.
     */
    create: XOR<ProjectFollowingsCreateInput, ProjectFollowingsUncheckedCreateInput>
    /**
     * In case the ProjectFollowings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectFollowingsUpdateInput, ProjectFollowingsUncheckedUpdateInput>
  }

  /**
   * ProjectFollowings delete
   */
  export type ProjectFollowingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    /**
     * Filter which ProjectFollowings to delete.
     */
    where: ProjectFollowingsWhereUniqueInput
  }

  /**
   * ProjectFollowings deleteMany
   */
  export type ProjectFollowingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFollowings to delete
     */
    where?: ProjectFollowingsWhereInput
    /**
     * Limit how many ProjectFollowings to delete.
     */
    limit?: number
  }

  /**
   * ProjectFollowings without action
   */
  export type ProjectFollowingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
  }


  /**
   * Model ProjectGenres
   */

  export type AggregateProjectGenres = {
    _count: ProjectGenresCountAggregateOutputType | null
    _avg: ProjectGenresAvgAggregateOutputType | null
    _sum: ProjectGenresSumAggregateOutputType | null
    _min: ProjectGenresMinAggregateOutputType | null
    _max: ProjectGenresMaxAggregateOutputType | null
  }

  export type ProjectGenresAvgAggregateOutputType = {
    projectId: number | null
    typeId: number | null
  }

  export type ProjectGenresSumAggregateOutputType = {
    projectId: number | null
    typeId: number | null
  }

  export type ProjectGenresMinAggregateOutputType = {
    projectId: number | null
    typeId: number | null
  }

  export type ProjectGenresMaxAggregateOutputType = {
    projectId: number | null
    typeId: number | null
  }

  export type ProjectGenresCountAggregateOutputType = {
    projectId: number
    typeId: number
    _all: number
  }


  export type ProjectGenresAvgAggregateInputType = {
    projectId?: true
    typeId?: true
  }

  export type ProjectGenresSumAggregateInputType = {
    projectId?: true
    typeId?: true
  }

  export type ProjectGenresMinAggregateInputType = {
    projectId?: true
    typeId?: true
  }

  export type ProjectGenresMaxAggregateInputType = {
    projectId?: true
    typeId?: true
  }

  export type ProjectGenresCountAggregateInputType = {
    projectId?: true
    typeId?: true
    _all?: true
  }

  export type ProjectGenresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGenres to aggregate.
     */
    where?: ProjectGenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGenres to fetch.
     */
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectGenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectGenres
    **/
    _count?: true | ProjectGenresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectGenresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectGenresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectGenresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectGenresMaxAggregateInputType
  }

  export type GetProjectGenresAggregateType<T extends ProjectGenresAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectGenres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectGenres[P]>
      : GetScalarType<T[P], AggregateProjectGenres[P]>
  }




  export type ProjectGenresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGenresWhereInput
    orderBy?: ProjectGenresOrderByWithAggregationInput | ProjectGenresOrderByWithAggregationInput[]
    by: ProjectGenresScalarFieldEnum[] | ProjectGenresScalarFieldEnum
    having?: ProjectGenresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectGenresCountAggregateInputType | true
    _avg?: ProjectGenresAvgAggregateInputType
    _sum?: ProjectGenresSumAggregateInputType
    _min?: ProjectGenresMinAggregateInputType
    _max?: ProjectGenresMaxAggregateInputType
  }

  export type ProjectGenresGroupByOutputType = {
    projectId: number
    typeId: number
    _count: ProjectGenresCountAggregateOutputType | null
    _avg: ProjectGenresAvgAggregateOutputType | null
    _sum: ProjectGenresSumAggregateOutputType | null
    _min: ProjectGenresMinAggregateOutputType | null
    _max: ProjectGenresMaxAggregateOutputType | null
  }

  type GetProjectGenresGroupByPayload<T extends ProjectGenresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGenresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGenresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGenresGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGenresGroupByOutputType[P]>
        }
      >
    >


  export type ProjectGenresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    typeId?: boolean
    genres?: boolean | GenresDefaultArgs<ExtArgs>
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGenres"]>



  export type ProjectGenresSelectScalar = {
    projectId?: boolean
    typeId?: boolean
  }

  export type ProjectGenresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "typeId", ExtArgs["result"]["projectGenres"]>
  export type ProjectGenresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | GenresDefaultArgs<ExtArgs>
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
  }

  export type $ProjectGenresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectGenres"
    objects: {
      genres: Prisma.$GenresPayload<ExtArgs>
      projects: Prisma.$ProjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      typeId: number
    }, ExtArgs["result"]["projectGenres"]>
    composites: {}
  }

  type ProjectGenresGetPayload<S extends boolean | null | undefined | ProjectGenresDefaultArgs> = $Result.GetResult<Prisma.$ProjectGenresPayload, S>

  type ProjectGenresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectGenresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectGenresCountAggregateInputType | true
    }

  export interface ProjectGenresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectGenres'], meta: { name: 'ProjectGenres' } }
    /**
     * Find zero or one ProjectGenres that matches the filter.
     * @param {ProjectGenresFindUniqueArgs} args - Arguments to find a ProjectGenres
     * @example
     * // Get one ProjectGenres
     * const projectGenres = await prisma.projectGenres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectGenresFindUniqueArgs>(args: SelectSubset<T, ProjectGenresFindUniqueArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectGenres that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectGenresFindUniqueOrThrowArgs} args - Arguments to find a ProjectGenres
     * @example
     * // Get one ProjectGenres
     * const projectGenres = await prisma.projectGenres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectGenresFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectGenresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresFindFirstArgs} args - Arguments to find a ProjectGenres
     * @example
     * // Get one ProjectGenres
     * const projectGenres = await prisma.projectGenres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectGenresFindFirstArgs>(args?: SelectSubset<T, ProjectGenresFindFirstArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGenres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresFindFirstOrThrowArgs} args - Arguments to find a ProjectGenres
     * @example
     * // Get one ProjectGenres
     * const projectGenres = await prisma.projectGenres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectGenresFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectGenresFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectGenres
     * const projectGenres = await prisma.projectGenres.findMany()
     * 
     * // Get first 10 ProjectGenres
     * const projectGenres = await prisma.projectGenres.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectGenresWithProjectIdOnly = await prisma.projectGenres.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectGenresFindManyArgs>(args?: SelectSubset<T, ProjectGenresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectGenres.
     * @param {ProjectGenresCreateArgs} args - Arguments to create a ProjectGenres.
     * @example
     * // Create one ProjectGenres
     * const ProjectGenres = await prisma.projectGenres.create({
     *   data: {
     *     // ... data to create a ProjectGenres
     *   }
     * })
     * 
     */
    create<T extends ProjectGenresCreateArgs>(args: SelectSubset<T, ProjectGenresCreateArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectGenres.
     * @param {ProjectGenresCreateManyArgs} args - Arguments to create many ProjectGenres.
     * @example
     * // Create many ProjectGenres
     * const projectGenres = await prisma.projectGenres.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectGenresCreateManyArgs>(args?: SelectSubset<T, ProjectGenresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectGenres.
     * @param {ProjectGenresDeleteArgs} args - Arguments to delete one ProjectGenres.
     * @example
     * // Delete one ProjectGenres
     * const ProjectGenres = await prisma.projectGenres.delete({
     *   where: {
     *     // ... filter to delete one ProjectGenres
     *   }
     * })
     * 
     */
    delete<T extends ProjectGenresDeleteArgs>(args: SelectSubset<T, ProjectGenresDeleteArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectGenres.
     * @param {ProjectGenresUpdateArgs} args - Arguments to update one ProjectGenres.
     * @example
     * // Update one ProjectGenres
     * const projectGenres = await prisma.projectGenres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectGenresUpdateArgs>(args: SelectSubset<T, ProjectGenresUpdateArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectGenres.
     * @param {ProjectGenresDeleteManyArgs} args - Arguments to filter ProjectGenres to delete.
     * @example
     * // Delete a few ProjectGenres
     * const { count } = await prisma.projectGenres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectGenresDeleteManyArgs>(args?: SelectSubset<T, ProjectGenresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectGenres
     * const projectGenres = await prisma.projectGenres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectGenresUpdateManyArgs>(args: SelectSubset<T, ProjectGenresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectGenres.
     * @param {ProjectGenresUpsertArgs} args - Arguments to update or create a ProjectGenres.
     * @example
     * // Update or create a ProjectGenres
     * const projectGenres = await prisma.projectGenres.upsert({
     *   create: {
     *     // ... data to create a ProjectGenres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectGenres we want to update
     *   }
     * })
     */
    upsert<T extends ProjectGenresUpsertArgs>(args: SelectSubset<T, ProjectGenresUpsertArgs<ExtArgs>>): Prisma__ProjectGenresClient<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresCountArgs} args - Arguments to filter ProjectGenres to count.
     * @example
     * // Count the number of ProjectGenres
     * const count = await prisma.projectGenres.count({
     *   where: {
     *     // ... the filter for the ProjectGenres we want to count
     *   }
     * })
    **/
    count<T extends ProjectGenresCountArgs>(
      args?: Subset<T, ProjectGenresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectGenresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectGenresAggregateArgs>(args: Subset<T, ProjectGenresAggregateArgs>): Prisma.PrismaPromise<GetProjectGenresAggregateType<T>>

    /**
     * Group by ProjectGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGenresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGenresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGenresGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGenresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGenresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGenresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectGenres model
   */
  readonly fields: ProjectGenresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectGenres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectGenresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genres<T extends GenresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenresDefaultArgs<ExtArgs>>): Prisma__GenresClient<$Result.GetResult<Prisma.$GenresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectGenres model
   */
  interface ProjectGenresFieldRefs {
    readonly projectId: FieldRef<"ProjectGenres", 'Int'>
    readonly typeId: FieldRef<"ProjectGenres", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectGenres findUnique
   */
  export type ProjectGenresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGenres to fetch.
     */
    where: ProjectGenresWhereUniqueInput
  }

  /**
   * ProjectGenres findUniqueOrThrow
   */
  export type ProjectGenresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGenres to fetch.
     */
    where: ProjectGenresWhereUniqueInput
  }

  /**
   * ProjectGenres findFirst
   */
  export type ProjectGenresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGenres to fetch.
     */
    where?: ProjectGenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGenres to fetch.
     */
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGenres.
     */
    cursor?: ProjectGenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGenres.
     */
    distinct?: ProjectGenresScalarFieldEnum | ProjectGenresScalarFieldEnum[]
  }

  /**
   * ProjectGenres findFirstOrThrow
   */
  export type ProjectGenresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGenres to fetch.
     */
    where?: ProjectGenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGenres to fetch.
     */
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGenres.
     */
    cursor?: ProjectGenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGenres.
     */
    distinct?: ProjectGenresScalarFieldEnum | ProjectGenresScalarFieldEnum[]
  }

  /**
   * ProjectGenres findMany
   */
  export type ProjectGenresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGenres to fetch.
     */
    where?: ProjectGenresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGenres to fetch.
     */
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectGenres.
     */
    cursor?: ProjectGenresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGenres.
     */
    skip?: number
    distinct?: ProjectGenresScalarFieldEnum | ProjectGenresScalarFieldEnum[]
  }

  /**
   * ProjectGenres create
   */
  export type ProjectGenresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectGenres.
     */
    data: XOR<ProjectGenresCreateInput, ProjectGenresUncheckedCreateInput>
  }

  /**
   * ProjectGenres createMany
   */
  export type ProjectGenresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectGenres.
     */
    data: ProjectGenresCreateManyInput | ProjectGenresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectGenres update
   */
  export type ProjectGenresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectGenres.
     */
    data: XOR<ProjectGenresUpdateInput, ProjectGenresUncheckedUpdateInput>
    /**
     * Choose, which ProjectGenres to update.
     */
    where: ProjectGenresWhereUniqueInput
  }

  /**
   * ProjectGenres updateMany
   */
  export type ProjectGenresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectGenres.
     */
    data: XOR<ProjectGenresUpdateManyMutationInput, ProjectGenresUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGenres to update
     */
    where?: ProjectGenresWhereInput
    /**
     * Limit how many ProjectGenres to update.
     */
    limit?: number
  }

  /**
   * ProjectGenres upsert
   */
  export type ProjectGenresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectGenres to update in case it exists.
     */
    where: ProjectGenresWhereUniqueInput
    /**
     * In case the ProjectGenres found by the `where` argument doesn't exist, create a new ProjectGenres with this data.
     */
    create: XOR<ProjectGenresCreateInput, ProjectGenresUncheckedCreateInput>
    /**
     * In case the ProjectGenres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectGenresUpdateInput, ProjectGenresUncheckedUpdateInput>
  }

  /**
   * ProjectGenres delete
   */
  export type ProjectGenresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    /**
     * Filter which ProjectGenres to delete.
     */
    where: ProjectGenresWhereUniqueInput
  }

  /**
   * ProjectGenres deleteMany
   */
  export type ProjectGenresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGenres to delete
     */
    where?: ProjectGenresWhereInput
    /**
     * Limit how many ProjectGenres to delete.
     */
    limit?: number
  }

  /**
   * ProjectGenres without action
   */
  export type ProjectGenresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
  }


  /**
   * Model ProjectImages
   */

  export type AggregateProjectImages = {
    _count: ProjectImagesCountAggregateOutputType | null
    _avg: ProjectImagesAvgAggregateOutputType | null
    _sum: ProjectImagesSumAggregateOutputType | null
    _min: ProjectImagesMinAggregateOutputType | null
    _max: ProjectImagesMaxAggregateOutputType | null
  }

  export type ProjectImagesAvgAggregateOutputType = {
    imageId: number | null
    position: number | null
    projectId: number | null
  }

  export type ProjectImagesSumAggregateOutputType = {
    imageId: number | null
    position: number | null
    projectId: number | null
  }

  export type ProjectImagesMinAggregateOutputType = {
    imageId: number | null
    image: string | null
    position: number | null
    projectId: number | null
  }

  export type ProjectImagesMaxAggregateOutputType = {
    imageId: number | null
    image: string | null
    position: number | null
    projectId: number | null
  }

  export type ProjectImagesCountAggregateOutputType = {
    imageId: number
    image: number
    position: number
    projectId: number
    _all: number
  }


  export type ProjectImagesAvgAggregateInputType = {
    imageId?: true
    position?: true
    projectId?: true
  }

  export type ProjectImagesSumAggregateInputType = {
    imageId?: true
    position?: true
    projectId?: true
  }

  export type ProjectImagesMinAggregateInputType = {
    imageId?: true
    image?: true
    position?: true
    projectId?: true
  }

  export type ProjectImagesMaxAggregateInputType = {
    imageId?: true
    image?: true
    position?: true
    projectId?: true
  }

  export type ProjectImagesCountAggregateInputType = {
    imageId?: true
    image?: true
    position?: true
    projectId?: true
    _all?: true
  }

  export type ProjectImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectImages to aggregate.
     */
    where?: ProjectImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectImages to fetch.
     */
    orderBy?: ProjectImagesOrderByWithRelationInput | ProjectImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectImages
    **/
    _count?: true | ProjectImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectImagesMaxAggregateInputType
  }

  export type GetProjectImagesAggregateType<T extends ProjectImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectImages[P]>
      : GetScalarType<T[P], AggregateProjectImages[P]>
  }




  export type ProjectImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectImagesWhereInput
    orderBy?: ProjectImagesOrderByWithAggregationInput | ProjectImagesOrderByWithAggregationInput[]
    by: ProjectImagesScalarFieldEnum[] | ProjectImagesScalarFieldEnum
    having?: ProjectImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectImagesCountAggregateInputType | true
    _avg?: ProjectImagesAvgAggregateInputType
    _sum?: ProjectImagesSumAggregateInputType
    _min?: ProjectImagesMinAggregateInputType
    _max?: ProjectImagesMaxAggregateInputType
  }

  export type ProjectImagesGroupByOutputType = {
    imageId: number
    image: string
    position: number
    projectId: number
    _count: ProjectImagesCountAggregateOutputType | null
    _avg: ProjectImagesAvgAggregateOutputType | null
    _sum: ProjectImagesSumAggregateOutputType | null
    _min: ProjectImagesMinAggregateOutputType | null
    _max: ProjectImagesMaxAggregateOutputType | null
  }

  type GetProjectImagesGroupByPayload<T extends ProjectImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectImagesGroupByOutputType[P]>
        }
      >
    >


  export type ProjectImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    imageId?: boolean
    image?: boolean
    position?: boolean
    projectId?: boolean
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectImages"]>



  export type ProjectImagesSelectScalar = {
    imageId?: boolean
    image?: boolean
    position?: boolean
    projectId?: boolean
  }

  export type ProjectImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"imageId" | "image" | "position" | "projectId", ExtArgs["result"]["projectImages"]>
  export type ProjectImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
  }

  export type $ProjectImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectImages"
    objects: {
      projects: Prisma.$ProjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      imageId: number
      image: string
      position: number
      projectId: number
    }, ExtArgs["result"]["projectImages"]>
    composites: {}
  }

  type ProjectImagesGetPayload<S extends boolean | null | undefined | ProjectImagesDefaultArgs> = $Result.GetResult<Prisma.$ProjectImagesPayload, S>

  type ProjectImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectImagesCountAggregateInputType | true
    }

  export interface ProjectImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectImages'], meta: { name: 'ProjectImages' } }
    /**
     * Find zero or one ProjectImages that matches the filter.
     * @param {ProjectImagesFindUniqueArgs} args - Arguments to find a ProjectImages
     * @example
     * // Get one ProjectImages
     * const projectImages = await prisma.projectImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectImagesFindUniqueArgs>(args: SelectSubset<T, ProjectImagesFindUniqueArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectImages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectImagesFindUniqueOrThrowArgs} args - Arguments to find a ProjectImages
     * @example
     * // Get one ProjectImages
     * const projectImages = await prisma.projectImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesFindFirstArgs} args - Arguments to find a ProjectImages
     * @example
     * // Get one ProjectImages
     * const projectImages = await prisma.projectImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectImagesFindFirstArgs>(args?: SelectSubset<T, ProjectImagesFindFirstArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesFindFirstOrThrowArgs} args - Arguments to find a ProjectImages
     * @example
     * // Get one ProjectImages
     * const projectImages = await prisma.projectImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectImages
     * const projectImages = await prisma.projectImages.findMany()
     * 
     * // Get first 10 ProjectImages
     * const projectImages = await prisma.projectImages.findMany({ take: 10 })
     * 
     * // Only select the `imageId`
     * const projectImagesWithImageIdOnly = await prisma.projectImages.findMany({ select: { imageId: true } })
     * 
     */
    findMany<T extends ProjectImagesFindManyArgs>(args?: SelectSubset<T, ProjectImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectImages.
     * @param {ProjectImagesCreateArgs} args - Arguments to create a ProjectImages.
     * @example
     * // Create one ProjectImages
     * const ProjectImages = await prisma.projectImages.create({
     *   data: {
     *     // ... data to create a ProjectImages
     *   }
     * })
     * 
     */
    create<T extends ProjectImagesCreateArgs>(args: SelectSubset<T, ProjectImagesCreateArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectImages.
     * @param {ProjectImagesCreateManyArgs} args - Arguments to create many ProjectImages.
     * @example
     * // Create many ProjectImages
     * const projectImages = await prisma.projectImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectImagesCreateManyArgs>(args?: SelectSubset<T, ProjectImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectImages.
     * @param {ProjectImagesDeleteArgs} args - Arguments to delete one ProjectImages.
     * @example
     * // Delete one ProjectImages
     * const ProjectImages = await prisma.projectImages.delete({
     *   where: {
     *     // ... filter to delete one ProjectImages
     *   }
     * })
     * 
     */
    delete<T extends ProjectImagesDeleteArgs>(args: SelectSubset<T, ProjectImagesDeleteArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectImages.
     * @param {ProjectImagesUpdateArgs} args - Arguments to update one ProjectImages.
     * @example
     * // Update one ProjectImages
     * const projectImages = await prisma.projectImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectImagesUpdateArgs>(args: SelectSubset<T, ProjectImagesUpdateArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectImages.
     * @param {ProjectImagesDeleteManyArgs} args - Arguments to filter ProjectImages to delete.
     * @example
     * // Delete a few ProjectImages
     * const { count } = await prisma.projectImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectImagesDeleteManyArgs>(args?: SelectSubset<T, ProjectImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectImages
     * const projectImages = await prisma.projectImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectImagesUpdateManyArgs>(args: SelectSubset<T, ProjectImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectImages.
     * @param {ProjectImagesUpsertArgs} args - Arguments to update or create a ProjectImages.
     * @example
     * // Update or create a ProjectImages
     * const projectImages = await prisma.projectImages.upsert({
     *   create: {
     *     // ... data to create a ProjectImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectImages we want to update
     *   }
     * })
     */
    upsert<T extends ProjectImagesUpsertArgs>(args: SelectSubset<T, ProjectImagesUpsertArgs<ExtArgs>>): Prisma__ProjectImagesClient<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesCountArgs} args - Arguments to filter ProjectImages to count.
     * @example
     * // Count the number of ProjectImages
     * const count = await prisma.projectImages.count({
     *   where: {
     *     // ... the filter for the ProjectImages we want to count
     *   }
     * })
    **/
    count<T extends ProjectImagesCountArgs>(
      args?: Subset<T, ProjectImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectImagesAggregateArgs>(args: Subset<T, ProjectImagesAggregateArgs>): Prisma.PrismaPromise<GetProjectImagesAggregateType<T>>

    /**
     * Group by ProjectImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectImagesGroupByArgs['orderBy'] }
        : { orderBy?: ProjectImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectImages model
   */
  readonly fields: ProjectImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectImages model
   */
  interface ProjectImagesFieldRefs {
    readonly imageId: FieldRef<"ProjectImages", 'Int'>
    readonly image: FieldRef<"ProjectImages", 'String'>
    readonly position: FieldRef<"ProjectImages", 'Int'>
    readonly projectId: FieldRef<"ProjectImages", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectImages findUnique
   */
  export type ProjectImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectImages to fetch.
     */
    where: ProjectImagesWhereUniqueInput
  }

  /**
   * ProjectImages findUniqueOrThrow
   */
  export type ProjectImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectImages to fetch.
     */
    where: ProjectImagesWhereUniqueInput
  }

  /**
   * ProjectImages findFirst
   */
  export type ProjectImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectImages to fetch.
     */
    where?: ProjectImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectImages to fetch.
     */
    orderBy?: ProjectImagesOrderByWithRelationInput | ProjectImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectImages.
     */
    cursor?: ProjectImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectImages.
     */
    distinct?: ProjectImagesScalarFieldEnum | ProjectImagesScalarFieldEnum[]
  }

  /**
   * ProjectImages findFirstOrThrow
   */
  export type ProjectImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectImages to fetch.
     */
    where?: ProjectImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectImages to fetch.
     */
    orderBy?: ProjectImagesOrderByWithRelationInput | ProjectImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectImages.
     */
    cursor?: ProjectImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectImages.
     */
    distinct?: ProjectImagesScalarFieldEnum | ProjectImagesScalarFieldEnum[]
  }

  /**
   * ProjectImages findMany
   */
  export type ProjectImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectImages to fetch.
     */
    where?: ProjectImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectImages to fetch.
     */
    orderBy?: ProjectImagesOrderByWithRelationInput | ProjectImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectImages.
     */
    cursor?: ProjectImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectImages.
     */
    skip?: number
    distinct?: ProjectImagesScalarFieldEnum | ProjectImagesScalarFieldEnum[]
  }

  /**
   * ProjectImages create
   */
  export type ProjectImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectImages.
     */
    data: XOR<ProjectImagesCreateInput, ProjectImagesUncheckedCreateInput>
  }

  /**
   * ProjectImages createMany
   */
  export type ProjectImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectImages.
     */
    data: ProjectImagesCreateManyInput | ProjectImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectImages update
   */
  export type ProjectImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectImages.
     */
    data: XOR<ProjectImagesUpdateInput, ProjectImagesUncheckedUpdateInput>
    /**
     * Choose, which ProjectImages to update.
     */
    where: ProjectImagesWhereUniqueInput
  }

  /**
   * ProjectImages updateMany
   */
  export type ProjectImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectImages.
     */
    data: XOR<ProjectImagesUpdateManyMutationInput, ProjectImagesUncheckedUpdateManyInput>
    /**
     * Filter which ProjectImages to update
     */
    where?: ProjectImagesWhereInput
    /**
     * Limit how many ProjectImages to update.
     */
    limit?: number
  }

  /**
   * ProjectImages upsert
   */
  export type ProjectImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectImages to update in case it exists.
     */
    where: ProjectImagesWhereUniqueInput
    /**
     * In case the ProjectImages found by the `where` argument doesn't exist, create a new ProjectImages with this data.
     */
    create: XOR<ProjectImagesCreateInput, ProjectImagesUncheckedCreateInput>
    /**
     * In case the ProjectImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectImagesUpdateInput, ProjectImagesUncheckedUpdateInput>
  }

  /**
   * ProjectImages delete
   */
  export type ProjectImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    /**
     * Filter which ProjectImages to delete.
     */
    where: ProjectImagesWhereUniqueInput
  }

  /**
   * ProjectImages deleteMany
   */
  export type ProjectImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectImages to delete
     */
    where?: ProjectImagesWhereInput
    /**
     * Limit how many ProjectImages to delete.
     */
    limit?: number
  }

  /**
   * ProjectImages without action
   */
  export type ProjectImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSocials
   */

  export type AggregateProjectSocials = {
    _count: ProjectSocialsCountAggregateOutputType | null
    _avg: ProjectSocialsAvgAggregateOutputType | null
    _sum: ProjectSocialsSumAggregateOutputType | null
    _min: ProjectSocialsMinAggregateOutputType | null
    _max: ProjectSocialsMaxAggregateOutputType | null
  }

  export type ProjectSocialsAvgAggregateOutputType = {
    projectId: number | null
    websiteId: number | null
  }

  export type ProjectSocialsSumAggregateOutputType = {
    projectId: number | null
    websiteId: number | null
  }

  export type ProjectSocialsMinAggregateOutputType = {
    projectId: number | null
    websiteId: number | null
    url: string | null
  }

  export type ProjectSocialsMaxAggregateOutputType = {
    projectId: number | null
    websiteId: number | null
    url: string | null
  }

  export type ProjectSocialsCountAggregateOutputType = {
    projectId: number
    websiteId: number
    url: number
    _all: number
  }


  export type ProjectSocialsAvgAggregateInputType = {
    projectId?: true
    websiteId?: true
  }

  export type ProjectSocialsSumAggregateInputType = {
    projectId?: true
    websiteId?: true
  }

  export type ProjectSocialsMinAggregateInputType = {
    projectId?: true
    websiteId?: true
    url?: true
  }

  export type ProjectSocialsMaxAggregateInputType = {
    projectId?: true
    websiteId?: true
    url?: true
  }

  export type ProjectSocialsCountAggregateInputType = {
    projectId?: true
    websiteId?: true
    url?: true
    _all?: true
  }

  export type ProjectSocialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSocials to aggregate.
     */
    where?: ProjectSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSocials to fetch.
     */
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSocials
    **/
    _count?: true | ProjectSocialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectSocialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSocialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSocialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSocialsMaxAggregateInputType
  }

  export type GetProjectSocialsAggregateType<T extends ProjectSocialsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSocials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSocials[P]>
      : GetScalarType<T[P], AggregateProjectSocials[P]>
  }




  export type ProjectSocialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSocialsWhereInput
    orderBy?: ProjectSocialsOrderByWithAggregationInput | ProjectSocialsOrderByWithAggregationInput[]
    by: ProjectSocialsScalarFieldEnum[] | ProjectSocialsScalarFieldEnum
    having?: ProjectSocialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSocialsCountAggregateInputType | true
    _avg?: ProjectSocialsAvgAggregateInputType
    _sum?: ProjectSocialsSumAggregateInputType
    _min?: ProjectSocialsMinAggregateInputType
    _max?: ProjectSocialsMaxAggregateInputType
  }

  export type ProjectSocialsGroupByOutputType = {
    projectId: number
    websiteId: number
    url: string
    _count: ProjectSocialsCountAggregateOutputType | null
    _avg: ProjectSocialsAvgAggregateOutputType | null
    _sum: ProjectSocialsSumAggregateOutputType | null
    _min: ProjectSocialsMinAggregateOutputType | null
    _max: ProjectSocialsMaxAggregateOutputType | null
  }

  type GetProjectSocialsGroupByPayload<T extends ProjectSocialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSocialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSocialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSocialsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSocialsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSocialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    websiteId?: boolean
    url?: boolean
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    socials?: boolean | SocialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSocials"]>



  export type ProjectSocialsSelectScalar = {
    projectId?: boolean
    websiteId?: boolean
    url?: boolean
  }

  export type ProjectSocialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "websiteId" | "url", ExtArgs["result"]["projectSocials"]>
  export type ProjectSocialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    socials?: boolean | SocialsDefaultArgs<ExtArgs>
  }

  export type $ProjectSocialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSocials"
    objects: {
      projects: Prisma.$ProjectsPayload<ExtArgs>
      socials: Prisma.$SocialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      websiteId: number
      url: string
    }, ExtArgs["result"]["projectSocials"]>
    composites: {}
  }

  type ProjectSocialsGetPayload<S extends boolean | null | undefined | ProjectSocialsDefaultArgs> = $Result.GetResult<Prisma.$ProjectSocialsPayload, S>

  type ProjectSocialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectSocialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectSocialsCountAggregateInputType | true
    }

  export interface ProjectSocialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSocials'], meta: { name: 'ProjectSocials' } }
    /**
     * Find zero or one ProjectSocials that matches the filter.
     * @param {ProjectSocialsFindUniqueArgs} args - Arguments to find a ProjectSocials
     * @example
     * // Get one ProjectSocials
     * const projectSocials = await prisma.projectSocials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSocialsFindUniqueArgs>(args: SelectSubset<T, ProjectSocialsFindUniqueArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectSocials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectSocialsFindUniqueOrThrowArgs} args - Arguments to find a ProjectSocials
     * @example
     * // Get one ProjectSocials
     * const projectSocials = await prisma.projectSocials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSocialsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSocialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsFindFirstArgs} args - Arguments to find a ProjectSocials
     * @example
     * // Get one ProjectSocials
     * const projectSocials = await prisma.projectSocials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSocialsFindFirstArgs>(args?: SelectSubset<T, ProjectSocialsFindFirstArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSocials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsFindFirstOrThrowArgs} args - Arguments to find a ProjectSocials
     * @example
     * // Get one ProjectSocials
     * const projectSocials = await prisma.projectSocials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSocialsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSocialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSocials
     * const projectSocials = await prisma.projectSocials.findMany()
     * 
     * // Get first 10 ProjectSocials
     * const projectSocials = await prisma.projectSocials.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectSocialsWithProjectIdOnly = await prisma.projectSocials.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectSocialsFindManyArgs>(args?: SelectSubset<T, ProjectSocialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectSocials.
     * @param {ProjectSocialsCreateArgs} args - Arguments to create a ProjectSocials.
     * @example
     * // Create one ProjectSocials
     * const ProjectSocials = await prisma.projectSocials.create({
     *   data: {
     *     // ... data to create a ProjectSocials
     *   }
     * })
     * 
     */
    create<T extends ProjectSocialsCreateArgs>(args: SelectSubset<T, ProjectSocialsCreateArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectSocials.
     * @param {ProjectSocialsCreateManyArgs} args - Arguments to create many ProjectSocials.
     * @example
     * // Create many ProjectSocials
     * const projectSocials = await prisma.projectSocials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSocialsCreateManyArgs>(args?: SelectSubset<T, ProjectSocialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectSocials.
     * @param {ProjectSocialsDeleteArgs} args - Arguments to delete one ProjectSocials.
     * @example
     * // Delete one ProjectSocials
     * const ProjectSocials = await prisma.projectSocials.delete({
     *   where: {
     *     // ... filter to delete one ProjectSocials
     *   }
     * })
     * 
     */
    delete<T extends ProjectSocialsDeleteArgs>(args: SelectSubset<T, ProjectSocialsDeleteArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectSocials.
     * @param {ProjectSocialsUpdateArgs} args - Arguments to update one ProjectSocials.
     * @example
     * // Update one ProjectSocials
     * const projectSocials = await prisma.projectSocials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSocialsUpdateArgs>(args: SelectSubset<T, ProjectSocialsUpdateArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectSocials.
     * @param {ProjectSocialsDeleteManyArgs} args - Arguments to filter ProjectSocials to delete.
     * @example
     * // Delete a few ProjectSocials
     * const { count } = await prisma.projectSocials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSocialsDeleteManyArgs>(args?: SelectSubset<T, ProjectSocialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSocials
     * const projectSocials = await prisma.projectSocials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSocialsUpdateManyArgs>(args: SelectSubset<T, ProjectSocialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectSocials.
     * @param {ProjectSocialsUpsertArgs} args - Arguments to update or create a ProjectSocials.
     * @example
     * // Update or create a ProjectSocials
     * const projectSocials = await prisma.projectSocials.upsert({
     *   create: {
     *     // ... data to create a ProjectSocials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSocials we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSocialsUpsertArgs>(args: SelectSubset<T, ProjectSocialsUpsertArgs<ExtArgs>>): Prisma__ProjectSocialsClient<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsCountArgs} args - Arguments to filter ProjectSocials to count.
     * @example
     * // Count the number of ProjectSocials
     * const count = await prisma.projectSocials.count({
     *   where: {
     *     // ... the filter for the ProjectSocials we want to count
     *   }
     * })
    **/
    count<T extends ProjectSocialsCountArgs>(
      args?: Subset<T, ProjectSocialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSocialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSocialsAggregateArgs>(args: Subset<T, ProjectSocialsAggregateArgs>): Prisma.PrismaPromise<GetProjectSocialsAggregateType<T>>

    /**
     * Group by ProjectSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSocialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSocialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSocialsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSocialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSocialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSocialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSocials model
   */
  readonly fields: ProjectSocialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSocials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSocialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    socials<T extends SocialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialsDefaultArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSocials model
   */
  interface ProjectSocialsFieldRefs {
    readonly projectId: FieldRef<"ProjectSocials", 'Int'>
    readonly websiteId: FieldRef<"ProjectSocials", 'Int'>
    readonly url: FieldRef<"ProjectSocials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSocials findUnique
   */
  export type ProjectSocialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSocials to fetch.
     */
    where: ProjectSocialsWhereUniqueInput
  }

  /**
   * ProjectSocials findUniqueOrThrow
   */
  export type ProjectSocialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSocials to fetch.
     */
    where: ProjectSocialsWhereUniqueInput
  }

  /**
   * ProjectSocials findFirst
   */
  export type ProjectSocialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSocials to fetch.
     */
    where?: ProjectSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSocials to fetch.
     */
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSocials.
     */
    cursor?: ProjectSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSocials.
     */
    distinct?: ProjectSocialsScalarFieldEnum | ProjectSocialsScalarFieldEnum[]
  }

  /**
   * ProjectSocials findFirstOrThrow
   */
  export type ProjectSocialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSocials to fetch.
     */
    where?: ProjectSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSocials to fetch.
     */
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSocials.
     */
    cursor?: ProjectSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSocials.
     */
    distinct?: ProjectSocialsScalarFieldEnum | ProjectSocialsScalarFieldEnum[]
  }

  /**
   * ProjectSocials findMany
   */
  export type ProjectSocialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSocials to fetch.
     */
    where?: ProjectSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSocials to fetch.
     */
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSocials.
     */
    cursor?: ProjectSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSocials.
     */
    skip?: number
    distinct?: ProjectSocialsScalarFieldEnum | ProjectSocialsScalarFieldEnum[]
  }

  /**
   * ProjectSocials create
   */
  export type ProjectSocialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSocials.
     */
    data: XOR<ProjectSocialsCreateInput, ProjectSocialsUncheckedCreateInput>
  }

  /**
   * ProjectSocials createMany
   */
  export type ProjectSocialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSocials.
     */
    data: ProjectSocialsCreateManyInput | ProjectSocialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSocials update
   */
  export type ProjectSocialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSocials.
     */
    data: XOR<ProjectSocialsUpdateInput, ProjectSocialsUncheckedUpdateInput>
    /**
     * Choose, which ProjectSocials to update.
     */
    where: ProjectSocialsWhereUniqueInput
  }

  /**
   * ProjectSocials updateMany
   */
  export type ProjectSocialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSocials.
     */
    data: XOR<ProjectSocialsUpdateManyMutationInput, ProjectSocialsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSocials to update
     */
    where?: ProjectSocialsWhereInput
    /**
     * Limit how many ProjectSocials to update.
     */
    limit?: number
  }

  /**
   * ProjectSocials upsert
   */
  export type ProjectSocialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSocials to update in case it exists.
     */
    where: ProjectSocialsWhereUniqueInput
    /**
     * In case the ProjectSocials found by the `where` argument doesn't exist, create a new ProjectSocials with this data.
     */
    create: XOR<ProjectSocialsCreateInput, ProjectSocialsUncheckedCreateInput>
    /**
     * In case the ProjectSocials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSocialsUpdateInput, ProjectSocialsUncheckedUpdateInput>
  }

  /**
   * ProjectSocials delete
   */
  export type ProjectSocialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    /**
     * Filter which ProjectSocials to delete.
     */
    where: ProjectSocialsWhereUniqueInput
  }

  /**
   * ProjectSocials deleteMany
   */
  export type ProjectSocialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSocials to delete
     */
    where?: ProjectSocialsWhereInput
    /**
     * Limit how many ProjectSocials to delete.
     */
    limit?: number
  }

  /**
   * ProjectSocials without action
   */
  export type ProjectSocialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTags
   */

  export type AggregateProjectTags = {
    _count: ProjectTagsCountAggregateOutputType | null
    _avg: ProjectTagsAvgAggregateOutputType | null
    _sum: ProjectTagsSumAggregateOutputType | null
    _min: ProjectTagsMinAggregateOutputType | null
    _max: ProjectTagsMaxAggregateOutputType | null
  }

  export type ProjectTagsAvgAggregateOutputType = {
    projectId: number | null
    tagId: number | null
    position: number | null
  }

  export type ProjectTagsSumAggregateOutputType = {
    projectId: number | null
    tagId: number | null
    position: number | null
  }

  export type ProjectTagsMinAggregateOutputType = {
    projectId: number | null
    tagId: number | null
    position: number | null
  }

  export type ProjectTagsMaxAggregateOutputType = {
    projectId: number | null
    tagId: number | null
    position: number | null
  }

  export type ProjectTagsCountAggregateOutputType = {
    projectId: number
    tagId: number
    position: number
    _all: number
  }


  export type ProjectTagsAvgAggregateInputType = {
    projectId?: true
    tagId?: true
    position?: true
  }

  export type ProjectTagsSumAggregateInputType = {
    projectId?: true
    tagId?: true
    position?: true
  }

  export type ProjectTagsMinAggregateInputType = {
    projectId?: true
    tagId?: true
    position?: true
  }

  export type ProjectTagsMaxAggregateInputType = {
    projectId?: true
    tagId?: true
    position?: true
  }

  export type ProjectTagsCountAggregateInputType = {
    projectId?: true
    tagId?: true
    position?: true
    _all?: true
  }

  export type ProjectTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTags to aggregate.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTags
    **/
    _count?: true | ProjectTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTagsMaxAggregateInputType
  }

  export type GetProjectTagsAggregateType<T extends ProjectTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTags[P]>
      : GetScalarType<T[P], AggregateProjectTags[P]>
  }




  export type ProjectTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagsWhereInput
    orderBy?: ProjectTagsOrderByWithAggregationInput | ProjectTagsOrderByWithAggregationInput[]
    by: ProjectTagsScalarFieldEnum[] | ProjectTagsScalarFieldEnum
    having?: ProjectTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTagsCountAggregateInputType | true
    _avg?: ProjectTagsAvgAggregateInputType
    _sum?: ProjectTagsSumAggregateInputType
    _min?: ProjectTagsMinAggregateInputType
    _max?: ProjectTagsMaxAggregateInputType
  }

  export type ProjectTagsGroupByOutputType = {
    projectId: number
    tagId: number
    position: number
    _count: ProjectTagsCountAggregateOutputType | null
    _avg: ProjectTagsAvgAggregateOutputType | null
    _sum: ProjectTagsSumAggregateOutputType | null
    _min: ProjectTagsMinAggregateOutputType | null
    _max: ProjectTagsMaxAggregateOutputType | null
  }

  type GetProjectTagsGroupByPayload<T extends ProjectTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTagsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTagsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    tagId?: boolean
    position?: boolean
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    tags?: boolean | TagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTags"]>



  export type ProjectTagsSelectScalar = {
    projectId?: boolean
    tagId?: boolean
    position?: boolean
  }

  export type ProjectTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "tagId" | "position", ExtArgs["result"]["projectTags"]>
  export type ProjectTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectsDefaultArgs<ExtArgs>
    tags?: boolean | TagsDefaultArgs<ExtArgs>
  }

  export type $ProjectTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTags"
    objects: {
      projects: Prisma.$ProjectsPayload<ExtArgs>
      tags: Prisma.$TagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      tagId: number
      position: number
    }, ExtArgs["result"]["projectTags"]>
    composites: {}
  }

  type ProjectTagsGetPayload<S extends boolean | null | undefined | ProjectTagsDefaultArgs> = $Result.GetResult<Prisma.$ProjectTagsPayload, S>

  type ProjectTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTagsCountAggregateInputType | true
    }

  export interface ProjectTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTags'], meta: { name: 'ProjectTags' } }
    /**
     * Find zero or one ProjectTags that matches the filter.
     * @param {ProjectTagsFindUniqueArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTagsFindUniqueArgs>(args: SelectSubset<T, ProjectTagsFindUniqueArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTagsFindUniqueOrThrowArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindFirstArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTagsFindFirstArgs>(args?: SelectSubset<T, ProjectTagsFindFirstArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindFirstOrThrowArgs} args - Arguments to find a ProjectTags
     * @example
     * // Get one ProjectTags
     * const projectTags = await prisma.projectTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTags
     * const projectTags = await prisma.projectTags.findMany()
     * 
     * // Get first 10 ProjectTags
     * const projectTags = await prisma.projectTags.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectTagsWithProjectIdOnly = await prisma.projectTags.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectTagsFindManyArgs>(args?: SelectSubset<T, ProjectTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTags.
     * @param {ProjectTagsCreateArgs} args - Arguments to create a ProjectTags.
     * @example
     * // Create one ProjectTags
     * const ProjectTags = await prisma.projectTags.create({
     *   data: {
     *     // ... data to create a ProjectTags
     *   }
     * })
     * 
     */
    create<T extends ProjectTagsCreateArgs>(args: SelectSubset<T, ProjectTagsCreateArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTags.
     * @param {ProjectTagsCreateManyArgs} args - Arguments to create many ProjectTags.
     * @example
     * // Create many ProjectTags
     * const projectTags = await prisma.projectTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTagsCreateManyArgs>(args?: SelectSubset<T, ProjectTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTags.
     * @param {ProjectTagsDeleteArgs} args - Arguments to delete one ProjectTags.
     * @example
     * // Delete one ProjectTags
     * const ProjectTags = await prisma.projectTags.delete({
     *   where: {
     *     // ... filter to delete one ProjectTags
     *   }
     * })
     * 
     */
    delete<T extends ProjectTagsDeleteArgs>(args: SelectSubset<T, ProjectTagsDeleteArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTags.
     * @param {ProjectTagsUpdateArgs} args - Arguments to update one ProjectTags.
     * @example
     * // Update one ProjectTags
     * const projectTags = await prisma.projectTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTagsUpdateArgs>(args: SelectSubset<T, ProjectTagsUpdateArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTags.
     * @param {ProjectTagsDeleteManyArgs} args - Arguments to filter ProjectTags to delete.
     * @example
     * // Delete a few ProjectTags
     * const { count } = await prisma.projectTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTagsDeleteManyArgs>(args?: SelectSubset<T, ProjectTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTags
     * const projectTags = await prisma.projectTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTagsUpdateManyArgs>(args: SelectSubset<T, ProjectTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTags.
     * @param {ProjectTagsUpsertArgs} args - Arguments to update or create a ProjectTags.
     * @example
     * // Update or create a ProjectTags
     * const projectTags = await prisma.projectTags.upsert({
     *   create: {
     *     // ... data to create a ProjectTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTags we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTagsUpsertArgs>(args: SelectSubset<T, ProjectTagsUpsertArgs<ExtArgs>>): Prisma__ProjectTagsClient<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsCountArgs} args - Arguments to filter ProjectTags to count.
     * @example
     * // Count the number of ProjectTags
     * const count = await prisma.projectTags.count({
     *   where: {
     *     // ... the filter for the ProjectTags we want to count
     *   }
     * })
    **/
    count<T extends ProjectTagsCountArgs>(
      args?: Subset<T, ProjectTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTagsAggregateArgs>(args: Subset<T, ProjectTagsAggregateArgs>): Prisma.PrismaPromise<GetProjectTagsAggregateType<T>>

    /**
     * Group by ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTagsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTags model
   */
  readonly fields: ProjectTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends TagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagsDefaultArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTags model
   */
  interface ProjectTagsFieldRefs {
    readonly projectId: FieldRef<"ProjectTags", 'Int'>
    readonly tagId: FieldRef<"ProjectTags", 'Int'>
    readonly position: FieldRef<"ProjectTags", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTags findUnique
   */
  export type ProjectTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where: ProjectTagsWhereUniqueInput
  }

  /**
   * ProjectTags findUniqueOrThrow
   */
  export type ProjectTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where: ProjectTagsWhereUniqueInput
  }

  /**
   * ProjectTags findFirst
   */
  export type ProjectTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: ProjectTagsScalarFieldEnum | ProjectTagsScalarFieldEnum[]
  }

  /**
   * ProjectTags findFirstOrThrow
   */
  export type ProjectTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: ProjectTagsScalarFieldEnum | ProjectTagsScalarFieldEnum[]
  }

  /**
   * ProjectTags findMany
   */
  export type ProjectTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTags.
     */
    cursor?: ProjectTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    distinct?: ProjectTagsScalarFieldEnum | ProjectTagsScalarFieldEnum[]
  }

  /**
   * ProjectTags create
   */
  export type ProjectTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTags.
     */
    data: XOR<ProjectTagsCreateInput, ProjectTagsUncheckedCreateInput>
  }

  /**
   * ProjectTags createMany
   */
  export type ProjectTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTags.
     */
    data: ProjectTagsCreateManyInput | ProjectTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTags update
   */
  export type ProjectTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTags.
     */
    data: XOR<ProjectTagsUpdateInput, ProjectTagsUncheckedUpdateInput>
    /**
     * Choose, which ProjectTags to update.
     */
    where: ProjectTagsWhereUniqueInput
  }

  /**
   * ProjectTags updateMany
   */
  export type ProjectTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTags.
     */
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTags to update
     */
    where?: ProjectTagsWhereInput
    /**
     * Limit how many ProjectTags to update.
     */
    limit?: number
  }

  /**
   * ProjectTags upsert
   */
  export type ProjectTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTags to update in case it exists.
     */
    where: ProjectTagsWhereUniqueInput
    /**
     * In case the ProjectTags found by the `where` argument doesn't exist, create a new ProjectTags with this data.
     */
    create: XOR<ProjectTagsCreateInput, ProjectTagsUncheckedCreateInput>
    /**
     * In case the ProjectTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTagsUpdateInput, ProjectTagsUncheckedUpdateInput>
  }

  /**
   * ProjectTags delete
   */
  export type ProjectTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    /**
     * Filter which ProjectTags to delete.
     */
    where: ProjectTagsWhereUniqueInput
  }

  /**
   * ProjectTags deleteMany
   */
  export type ProjectTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTags to delete
     */
    where?: ProjectTagsWhereInput
    /**
     * Limit how many ProjectTags to delete.
     */
    limit?: number
  }

  /**
   * ProjectTags without action
   */
  export type ProjectTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
  }


  /**
   * Model Projects
   */

  export type AggregateProjects = {
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsAvgAggregateOutputType = {
    projectId: number | null
    userId: number | null
  }

  export type ProjectsSumAggregateOutputType = {
    projectId: number | null
    userId: number | null
  }

  export type ProjectsMinAggregateOutputType = {
    projectId: number | null
    title: string | null
    hook: string | null
    description: string | null
    thumbnail: string | null
    purpose: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus | null
    audience: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectsMaxAggregateOutputType = {
    projectId: number | null
    title: string | null
    hook: string | null
    description: string | null
    thumbnail: string | null
    purpose: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus | null
    audience: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectsCountAggregateOutputType = {
    projectId: number
    title: number
    hook: number
    description: number
    thumbnail: number
    purpose: number
    status: number
    audience: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectsAvgAggregateInputType = {
    projectId?: true
    userId?: true
  }

  export type ProjectsSumAggregateInputType = {
    projectId?: true
    userId?: true
  }

  export type ProjectsMinAggregateInputType = {
    projectId?: true
    title?: true
    hook?: true
    description?: true
    thumbnail?: true
    purpose?: true
    status?: true
    audience?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectsMaxAggregateInputType = {
    projectId?: true
    title?: true
    hook?: true
    description?: true
    thumbnail?: true
    purpose?: true
    status?: true
    audience?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectsCountAggregateInputType = {
    projectId?: true
    title?: true
    hook?: true
    description?: true
    thumbnail?: true
    purpose?: true
    status?: true
    audience?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to aggregate.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }




  export type ProjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectsWhereInput
    orderBy?: ProjectsOrderByWithAggregationInput | ProjectsOrderByWithAggregationInput[]
    by: ProjectsScalarFieldEnum[] | ProjectsScalarFieldEnum
    having?: ProjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsCountAggregateInputType | true
    _avg?: ProjectsAvgAggregateInputType
    _sum?: ProjectsSumAggregateInputType
    _min?: ProjectsMinAggregateInputType
    _max?: ProjectsMaxAggregateInputType
  }

  export type ProjectsGroupByOutputType = {
    projectId: number
    title: string
    hook: string
    description: string
    thumbnail: string | null
    purpose: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience: string | null
    userId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  type GetProjectsGroupByPayload<T extends ProjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectId?: boolean
    title?: boolean
    hook?: boolean
    description?: boolean
    thumbnail?: boolean
    purpose?: boolean
    status?: boolean
    audience?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobs?: boolean | Projects$jobsArgs<ExtArgs>
    members?: boolean | Projects$membersArgs<ExtArgs>
    projectFollowings?: boolean | Projects$projectFollowingsArgs<ExtArgs>
    projectGenres?: boolean | Projects$projectGenresArgs<ExtArgs>
    projectImages?: boolean | Projects$projectImagesArgs<ExtArgs>
    projectSocials?: boolean | Projects$projectSocialsArgs<ExtArgs>
    projectTags?: boolean | Projects$projectTagsArgs<ExtArgs>
    users?: boolean | Projects$usersArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>



  export type ProjectsSelectScalar = {
    projectId?: boolean
    title?: boolean
    hook?: boolean
    description?: boolean
    thumbnail?: boolean
    purpose?: boolean
    status?: boolean
    audience?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"projectId" | "title" | "hook" | "description" | "thumbnail" | "purpose" | "status" | "audience" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["projects"]>
  export type ProjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Projects$jobsArgs<ExtArgs>
    members?: boolean | Projects$membersArgs<ExtArgs>
    projectFollowings?: boolean | Projects$projectFollowingsArgs<ExtArgs>
    projectGenres?: boolean | Projects$projectGenresArgs<ExtArgs>
    projectImages?: boolean | Projects$projectImagesArgs<ExtArgs>
    projectSocials?: boolean | Projects$projectSocialsArgs<ExtArgs>
    projectTags?: boolean | Projects$projectTagsArgs<ExtArgs>
    users?: boolean | Projects$usersArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Projects"
    objects: {
      jobs: Prisma.$JobsPayload<ExtArgs>[]
      members: Prisma.$MembersPayload<ExtArgs>[]
      projectFollowings: Prisma.$ProjectFollowingsPayload<ExtArgs>[]
      projectGenres: Prisma.$ProjectGenresPayload<ExtArgs>[]
      projectImages: Prisma.$ProjectImagesPayload<ExtArgs>[]
      projectSocials: Prisma.$ProjectSocialsPayload<ExtArgs>[]
      projectTags: Prisma.$ProjectTagsPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      projectId: number
      title: string
      hook: string
      description: string
      thumbnail: string | null
      purpose: $Enums.ProjectsPurpose | null
      status: $Enums.ProjectsStatus
      audience: string | null
      userId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projects"]>
    composites: {}
  }

  type ProjectsGetPayload<S extends boolean | null | undefined | ProjectsDefaultArgs> = $Result.GetResult<Prisma.$ProjectsPayload, S>

  type ProjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectsCountAggregateInputType | true
    }

  export interface ProjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Projects'], meta: { name: 'Projects' } }
    /**
     * Find zero or one Projects that matches the filter.
     * @param {ProjectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectsFindUniqueArgs>(args: SelectSubset<T, ProjectsFindUniqueArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectsFindUniqueOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectsFindFirstArgs>(args?: SelectSubset<T, ProjectsFindFirstArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindFirstOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `projectId`
     * const projectsWithProjectIdOnly = await prisma.projects.findMany({ select: { projectId: true } })
     * 
     */
    findMany<T extends ProjectsFindManyArgs>(args?: SelectSubset<T, ProjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projects.
     * @param {ProjectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
     */
    create<T extends ProjectsCreateArgs>(args: SelectSubset<T, ProjectsCreateArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectsCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectsCreateManyArgs>(args?: SelectSubset<T, ProjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projects.
     * @param {ProjectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
     */
    delete<T extends ProjectsDeleteArgs>(args: SelectSubset<T, ProjectsDeleteArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projects.
     * @param {ProjectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectsUpdateArgs>(args: SelectSubset<T, ProjectsUpdateArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectsDeleteManyArgs>(args?: SelectSubset<T, ProjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectsUpdateManyArgs>(args: SelectSubset<T, ProjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projects.
     * @param {ProjectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
     */
    upsert<T extends ProjectsUpsertArgs>(args: SelectSubset<T, ProjectsUpsertArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectsCountArgs>(
      args?: Subset<T, ProjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Prisma.PrismaPromise<GetProjectsAggregateType<T>>

    /**
     * Group by Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Projects model
   */
  readonly fields: ProjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Projects$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Projects$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Projects$membersArgs<ExtArgs> = {}>(args?: Subset<T, Projects$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectFollowings<T extends Projects$projectFollowingsArgs<ExtArgs> = {}>(args?: Subset<T, Projects$projectFollowingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectGenres<T extends Projects$projectGenresArgs<ExtArgs> = {}>(args?: Subset<T, Projects$projectGenresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGenresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectImages<T extends Projects$projectImagesArgs<ExtArgs> = {}>(args?: Subset<T, Projects$projectImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectSocials<T extends Projects$projectSocialsArgs<ExtArgs> = {}>(args?: Subset<T, Projects$projectSocialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectTags<T extends Projects$projectTagsArgs<ExtArgs> = {}>(args?: Subset<T, Projects$projectTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Projects$usersArgs<ExtArgs> = {}>(args?: Subset<T, Projects$usersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Projects model
   */
  interface ProjectsFieldRefs {
    readonly projectId: FieldRef<"Projects", 'Int'>
    readonly title: FieldRef<"Projects", 'String'>
    readonly hook: FieldRef<"Projects", 'String'>
    readonly description: FieldRef<"Projects", 'String'>
    readonly thumbnail: FieldRef<"Projects", 'String'>
    readonly purpose: FieldRef<"Projects", 'ProjectsPurpose'>
    readonly status: FieldRef<"Projects", 'ProjectsStatus'>
    readonly audience: FieldRef<"Projects", 'String'>
    readonly userId: FieldRef<"Projects", 'Int'>
    readonly createdAt: FieldRef<"Projects", 'DateTime'>
    readonly updatedAt: FieldRef<"Projects", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Projects findUnique
   */
  export type ProjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects findUniqueOrThrow
   */
  export type ProjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects findFirst
   */
  export type ProjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects findFirstOrThrow
   */
  export type ProjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects findMany
   */
  export type ProjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects create
   */
  export type ProjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a Projects.
     */
    data: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
  }

  /**
   * Projects createMany
   */
  export type ProjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectsCreateManyInput | ProjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Projects update
   */
  export type ProjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a Projects.
     */
    data: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
    /**
     * Choose, which Projects to update.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects updateMany
   */
  export type ProjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectsWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Projects upsert
   */
  export type ProjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the Projects to update in case it exists.
     */
    where: ProjectsWhereUniqueInput
    /**
     * In case the Projects found by the `where` argument doesn't exist, create a new Projects with this data.
     */
    create: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
    /**
     * In case the Projects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
  }

  /**
   * Projects delete
   */
  export type ProjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter which Projects to delete.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects deleteMany
   */
  export type ProjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectsWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Projects.jobs
   */
  export type Projects$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Projects.members
   */
  export type Projects$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    where?: MembersWhereInput
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    cursor?: MembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Projects.projectFollowings
   */
  export type Projects$projectFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    where?: ProjectFollowingsWhereInput
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    cursor?: ProjectFollowingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFollowingsScalarFieldEnum | ProjectFollowingsScalarFieldEnum[]
  }

  /**
   * Projects.projectGenres
   */
  export type Projects$projectGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGenres
     */
    select?: ProjectGenresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGenres
     */
    omit?: ProjectGenresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGenresInclude<ExtArgs> | null
    where?: ProjectGenresWhereInput
    orderBy?: ProjectGenresOrderByWithRelationInput | ProjectGenresOrderByWithRelationInput[]
    cursor?: ProjectGenresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGenresScalarFieldEnum | ProjectGenresScalarFieldEnum[]
  }

  /**
   * Projects.projectImages
   */
  export type Projects$projectImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectImages
     */
    select?: ProjectImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectImages
     */
    omit?: ProjectImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectImagesInclude<ExtArgs> | null
    where?: ProjectImagesWhereInput
    orderBy?: ProjectImagesOrderByWithRelationInput | ProjectImagesOrderByWithRelationInput[]
    cursor?: ProjectImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectImagesScalarFieldEnum | ProjectImagesScalarFieldEnum[]
  }

  /**
   * Projects.projectSocials
   */
  export type Projects$projectSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    where?: ProjectSocialsWhereInput
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    cursor?: ProjectSocialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSocialsScalarFieldEnum | ProjectSocialsScalarFieldEnum[]
  }

  /**
   * Projects.projectTags
   */
  export type Projects$projectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    where?: ProjectTagsWhereInput
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    cursor?: ProjectTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTagsScalarFieldEnum | ProjectTagsScalarFieldEnum[]
  }

  /**
   * Projects.users
   */
  export type Projects$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Projects without action
   */
  export type ProjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
  }


  /**
   * Model Socials
   */

  export type AggregateSocials = {
    _count: SocialsCountAggregateOutputType | null
    _avg: SocialsAvgAggregateOutputType | null
    _sum: SocialsSumAggregateOutputType | null
    _min: SocialsMinAggregateOutputType | null
    _max: SocialsMaxAggregateOutputType | null
  }

  export type SocialsAvgAggregateOutputType = {
    websiteId: number | null
  }

  export type SocialsSumAggregateOutputType = {
    websiteId: number | null
  }

  export type SocialsMinAggregateOutputType = {
    websiteId: number | null
    label: string | null
  }

  export type SocialsMaxAggregateOutputType = {
    websiteId: number | null
    label: string | null
  }

  export type SocialsCountAggregateOutputType = {
    websiteId: number
    label: number
    _all: number
  }


  export type SocialsAvgAggregateInputType = {
    websiteId?: true
  }

  export type SocialsSumAggregateInputType = {
    websiteId?: true
  }

  export type SocialsMinAggregateInputType = {
    websiteId?: true
    label?: true
  }

  export type SocialsMaxAggregateInputType = {
    websiteId?: true
    label?: true
  }

  export type SocialsCountAggregateInputType = {
    websiteId?: true
    label?: true
    _all?: true
  }

  export type SocialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Socials to aggregate.
     */
    where?: SocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialsOrderByWithRelationInput | SocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Socials
    **/
    _count?: true | SocialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialsMaxAggregateInputType
  }

  export type GetSocialsAggregateType<T extends SocialsAggregateArgs> = {
        [P in keyof T & keyof AggregateSocials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocials[P]>
      : GetScalarType<T[P], AggregateSocials[P]>
  }




  export type SocialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialsWhereInput
    orderBy?: SocialsOrderByWithAggregationInput | SocialsOrderByWithAggregationInput[]
    by: SocialsScalarFieldEnum[] | SocialsScalarFieldEnum
    having?: SocialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialsCountAggregateInputType | true
    _avg?: SocialsAvgAggregateInputType
    _sum?: SocialsSumAggregateInputType
    _min?: SocialsMinAggregateInputType
    _max?: SocialsMaxAggregateInputType
  }

  export type SocialsGroupByOutputType = {
    websiteId: number
    label: string
    _count: SocialsCountAggregateOutputType | null
    _avg: SocialsAvgAggregateOutputType | null
    _sum: SocialsSumAggregateOutputType | null
    _min: SocialsMinAggregateOutputType | null
    _max: SocialsMaxAggregateOutputType | null
  }

  type GetSocialsGroupByPayload<T extends SocialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialsGroupByOutputType[P]>
            : GetScalarType<T[P], SocialsGroupByOutputType[P]>
        }
      >
    >


  export type SocialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    websiteId?: boolean
    label?: boolean
    projectSocials?: boolean | Socials$projectSocialsArgs<ExtArgs>
    userSocials?: boolean | Socials$userSocialsArgs<ExtArgs>
    _count?: boolean | SocialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socials"]>



  export type SocialsSelectScalar = {
    websiteId?: boolean
    label?: boolean
  }

  export type SocialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"websiteId" | "label", ExtArgs["result"]["socials"]>
  export type SocialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectSocials?: boolean | Socials$projectSocialsArgs<ExtArgs>
    userSocials?: boolean | Socials$userSocialsArgs<ExtArgs>
    _count?: boolean | SocialsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SocialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Socials"
    objects: {
      projectSocials: Prisma.$ProjectSocialsPayload<ExtArgs>[]
      userSocials: Prisma.$UserSocialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      websiteId: number
      label: string
    }, ExtArgs["result"]["socials"]>
    composites: {}
  }

  type SocialsGetPayload<S extends boolean | null | undefined | SocialsDefaultArgs> = $Result.GetResult<Prisma.$SocialsPayload, S>

  type SocialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialsCountAggregateInputType | true
    }

  export interface SocialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Socials'], meta: { name: 'Socials' } }
    /**
     * Find zero or one Socials that matches the filter.
     * @param {SocialsFindUniqueArgs} args - Arguments to find a Socials
     * @example
     * // Get one Socials
     * const socials = await prisma.socials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialsFindUniqueArgs>(args: SelectSubset<T, SocialsFindUniqueArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Socials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialsFindUniqueOrThrowArgs} args - Arguments to find a Socials
     * @example
     * // Get one Socials
     * const socials = await prisma.socials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialsFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Socials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsFindFirstArgs} args - Arguments to find a Socials
     * @example
     * // Get one Socials
     * const socials = await prisma.socials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialsFindFirstArgs>(args?: SelectSubset<T, SocialsFindFirstArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Socials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsFindFirstOrThrowArgs} args - Arguments to find a Socials
     * @example
     * // Get one Socials
     * const socials = await prisma.socials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialsFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Socials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Socials
     * const socials = await prisma.socials.findMany()
     * 
     * // Get first 10 Socials
     * const socials = await prisma.socials.findMany({ take: 10 })
     * 
     * // Only select the `websiteId`
     * const socialsWithWebsiteIdOnly = await prisma.socials.findMany({ select: { websiteId: true } })
     * 
     */
    findMany<T extends SocialsFindManyArgs>(args?: SelectSubset<T, SocialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Socials.
     * @param {SocialsCreateArgs} args - Arguments to create a Socials.
     * @example
     * // Create one Socials
     * const Socials = await prisma.socials.create({
     *   data: {
     *     // ... data to create a Socials
     *   }
     * })
     * 
     */
    create<T extends SocialsCreateArgs>(args: SelectSubset<T, SocialsCreateArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Socials.
     * @param {SocialsCreateManyArgs} args - Arguments to create many Socials.
     * @example
     * // Create many Socials
     * const socials = await prisma.socials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialsCreateManyArgs>(args?: SelectSubset<T, SocialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Socials.
     * @param {SocialsDeleteArgs} args - Arguments to delete one Socials.
     * @example
     * // Delete one Socials
     * const Socials = await prisma.socials.delete({
     *   where: {
     *     // ... filter to delete one Socials
     *   }
     * })
     * 
     */
    delete<T extends SocialsDeleteArgs>(args: SelectSubset<T, SocialsDeleteArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Socials.
     * @param {SocialsUpdateArgs} args - Arguments to update one Socials.
     * @example
     * // Update one Socials
     * const socials = await prisma.socials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialsUpdateArgs>(args: SelectSubset<T, SocialsUpdateArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Socials.
     * @param {SocialsDeleteManyArgs} args - Arguments to filter Socials to delete.
     * @example
     * // Delete a few Socials
     * const { count } = await prisma.socials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialsDeleteManyArgs>(args?: SelectSubset<T, SocialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Socials
     * const socials = await prisma.socials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialsUpdateManyArgs>(args: SelectSubset<T, SocialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Socials.
     * @param {SocialsUpsertArgs} args - Arguments to update or create a Socials.
     * @example
     * // Update or create a Socials
     * const socials = await prisma.socials.upsert({
     *   create: {
     *     // ... data to create a Socials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Socials we want to update
     *   }
     * })
     */
    upsert<T extends SocialsUpsertArgs>(args: SelectSubset<T, SocialsUpsertArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsCountArgs} args - Arguments to filter Socials to count.
     * @example
     * // Count the number of Socials
     * const count = await prisma.socials.count({
     *   where: {
     *     // ... the filter for the Socials we want to count
     *   }
     * })
    **/
    count<T extends SocialsCountArgs>(
      args?: Subset<T, SocialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialsAggregateArgs>(args: Subset<T, SocialsAggregateArgs>): Prisma.PrismaPromise<GetSocialsAggregateType<T>>

    /**
     * Group by Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialsGroupByArgs['orderBy'] }
        : { orderBy?: SocialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Socials model
   */
  readonly fields: SocialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Socials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectSocials<T extends Socials$projectSocialsArgs<ExtArgs> = {}>(args?: Subset<T, Socials$projectSocialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSocials<T extends Socials$userSocialsArgs<ExtArgs> = {}>(args?: Subset<T, Socials$userSocialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Socials model
   */
  interface SocialsFieldRefs {
    readonly websiteId: FieldRef<"Socials", 'Int'>
    readonly label: FieldRef<"Socials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Socials findUnique
   */
  export type SocialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where: SocialsWhereUniqueInput
  }

  /**
   * Socials findUniqueOrThrow
   */
  export type SocialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where: SocialsWhereUniqueInput
  }

  /**
   * Socials findFirst
   */
  export type SocialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where?: SocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialsOrderByWithRelationInput | SocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Socials.
     */
    cursor?: SocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Socials.
     */
    distinct?: SocialsScalarFieldEnum | SocialsScalarFieldEnum[]
  }

  /**
   * Socials findFirstOrThrow
   */
  export type SocialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where?: SocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialsOrderByWithRelationInput | SocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Socials.
     */
    cursor?: SocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Socials.
     */
    distinct?: SocialsScalarFieldEnum | SocialsScalarFieldEnum[]
  }

  /**
   * Socials findMany
   */
  export type SocialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where?: SocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialsOrderByWithRelationInput | SocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Socials.
     */
    cursor?: SocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    distinct?: SocialsScalarFieldEnum | SocialsScalarFieldEnum[]
  }

  /**
   * Socials create
   */
  export type SocialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * The data needed to create a Socials.
     */
    data: XOR<SocialsCreateInput, SocialsUncheckedCreateInput>
  }

  /**
   * Socials createMany
   */
  export type SocialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Socials.
     */
    data: SocialsCreateManyInput | SocialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Socials update
   */
  export type SocialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * The data needed to update a Socials.
     */
    data: XOR<SocialsUpdateInput, SocialsUncheckedUpdateInput>
    /**
     * Choose, which Socials to update.
     */
    where: SocialsWhereUniqueInput
  }

  /**
   * Socials updateMany
   */
  export type SocialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Socials.
     */
    data: XOR<SocialsUpdateManyMutationInput, SocialsUncheckedUpdateManyInput>
    /**
     * Filter which Socials to update
     */
    where?: SocialsWhereInput
    /**
     * Limit how many Socials to update.
     */
    limit?: number
  }

  /**
   * Socials upsert
   */
  export type SocialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * The filter to search for the Socials to update in case it exists.
     */
    where: SocialsWhereUniqueInput
    /**
     * In case the Socials found by the `where` argument doesn't exist, create a new Socials with this data.
     */
    create: XOR<SocialsCreateInput, SocialsUncheckedCreateInput>
    /**
     * In case the Socials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialsUpdateInput, SocialsUncheckedUpdateInput>
  }

  /**
   * Socials delete
   */
  export type SocialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
    /**
     * Filter which Socials to delete.
     */
    where: SocialsWhereUniqueInput
  }

  /**
   * Socials deleteMany
   */
  export type SocialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Socials to delete
     */
    where?: SocialsWhereInput
    /**
     * Limit how many Socials to delete.
     */
    limit?: number
  }

  /**
   * Socials.projectSocials
   */
  export type Socials$projectSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSocials
     */
    select?: ProjectSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSocials
     */
    omit?: ProjectSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSocialsInclude<ExtArgs> | null
    where?: ProjectSocialsWhereInput
    orderBy?: ProjectSocialsOrderByWithRelationInput | ProjectSocialsOrderByWithRelationInput[]
    cursor?: ProjectSocialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSocialsScalarFieldEnum | ProjectSocialsScalarFieldEnum[]
  }

  /**
   * Socials.userSocials
   */
  export type Socials$userSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    where?: UserSocialsWhereInput
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    cursor?: UserSocialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSocialsScalarFieldEnum | UserSocialsScalarFieldEnum[]
  }

  /**
   * Socials without action
   */
  export type SocialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Socials
     */
    select?: SocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Socials
     */
    omit?: SocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialsInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    tagId: number | null
  }

  export type TagsSumAggregateOutputType = {
    tagId: number | null
  }

  export type TagsMinAggregateOutputType = {
    tagId: number | null
    label: string | null
    type: string | null
  }

  export type TagsMaxAggregateOutputType = {
    tagId: number | null
    label: string | null
    type: string | null
  }

  export type TagsCountAggregateOutputType = {
    tagId: number
    label: number
    type: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    tagId?: true
  }

  export type TagsSumAggregateInputType = {
    tagId?: true
  }

  export type TagsMinAggregateInputType = {
    tagId?: true
    label?: true
    type?: true
  }

  export type TagsMaxAggregateInputType = {
    tagId?: true
    label?: true
    type?: true
  }

  export type TagsCountAggregateInputType = {
    tagId?: true
    label?: true
    type?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    tagId: number
    label: string
    type: string
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    label?: boolean
    type?: boolean
    projectTags?: boolean | Tags$projectTagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>



  export type TagsSelectScalar = {
    tagId?: boolean
    label?: boolean
    type?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tagId" | "label" | "type", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectTags?: boolean | Tags$projectTagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      projectTags: Prisma.$ProjectTagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tagId: number
      label: string
      type: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const tagsWithTagIdOnly = await prisma.tags.findMany({ select: { tagId: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectTags<T extends Tags$projectTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tags$projectTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly tagId: FieldRef<"Tags", 'Int'>
    readonly label: FieldRef<"Tags", 'String'>
    readonly type: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags.projectTags
   */
  export type Tags$projectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTags
     */
    select?: ProjectTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTags
     */
    omit?: ProjectTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagsInclude<ExtArgs> | null
    where?: ProjectTagsWhereInput
    orderBy?: ProjectTagsOrderByWithRelationInput | ProjectTagsOrderByWithRelationInput[]
    cursor?: ProjectTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTagsScalarFieldEnum | ProjectTagsScalarFieldEnum[]
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model UserFollowings
   */

  export type AggregateUserFollowings = {
    _count: UserFollowingsCountAggregateOutputType | null
    _avg: UserFollowingsAvgAggregateOutputType | null
    _sum: UserFollowingsSumAggregateOutputType | null
    _min: UserFollowingsMinAggregateOutputType | null
    _max: UserFollowingsMaxAggregateOutputType | null
  }

  export type UserFollowingsAvgAggregateOutputType = {
    userId: number | null
    followingId: number | null
  }

  export type UserFollowingsSumAggregateOutputType = {
    userId: number | null
    followingId: number | null
  }

  export type UserFollowingsMinAggregateOutputType = {
    userId: number | null
    followingId: number | null
    followedAt: Date | null
  }

  export type UserFollowingsMaxAggregateOutputType = {
    userId: number | null
    followingId: number | null
    followedAt: Date | null
  }

  export type UserFollowingsCountAggregateOutputType = {
    userId: number
    followingId: number
    followedAt: number
    _all: number
  }


  export type UserFollowingsAvgAggregateInputType = {
    userId?: true
    followingId?: true
  }

  export type UserFollowingsSumAggregateInputType = {
    userId?: true
    followingId?: true
  }

  export type UserFollowingsMinAggregateInputType = {
    userId?: true
    followingId?: true
    followedAt?: true
  }

  export type UserFollowingsMaxAggregateInputType = {
    userId?: true
    followingId?: true
    followedAt?: true
  }

  export type UserFollowingsCountAggregateInputType = {
    userId?: true
    followingId?: true
    followedAt?: true
    _all?: true
  }

  export type UserFollowingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollowings to aggregate.
     */
    where?: UserFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollowings to fetch.
     */
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFollowings
    **/
    _count?: true | UserFollowingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFollowingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFollowingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFollowingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFollowingsMaxAggregateInputType
  }

  export type GetUserFollowingsAggregateType<T extends UserFollowingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFollowings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFollowings[P]>
      : GetScalarType<T[P], AggregateUserFollowings[P]>
  }




  export type UserFollowingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowingsWhereInput
    orderBy?: UserFollowingsOrderByWithAggregationInput | UserFollowingsOrderByWithAggregationInput[]
    by: UserFollowingsScalarFieldEnum[] | UserFollowingsScalarFieldEnum
    having?: UserFollowingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFollowingsCountAggregateInputType | true
    _avg?: UserFollowingsAvgAggregateInputType
    _sum?: UserFollowingsSumAggregateInputType
    _min?: UserFollowingsMinAggregateInputType
    _max?: UserFollowingsMaxAggregateInputType
  }

  export type UserFollowingsGroupByOutputType = {
    userId: number
    followingId: number
    followedAt: Date
    _count: UserFollowingsCountAggregateOutputType | null
    _avg: UserFollowingsAvgAggregateOutputType | null
    _sum: UserFollowingsSumAggregateOutputType | null
    _min: UserFollowingsMinAggregateOutputType | null
    _max: UserFollowingsMaxAggregateOutputType | null
  }

  type GetUserFollowingsGroupByPayload<T extends UserFollowingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFollowingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFollowingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFollowingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserFollowingsGroupByOutputType[P]>
        }
      >
    >


  export type UserFollowingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    followingId?: boolean
    followedAt?: boolean
    usersUserFollowingsFollowingIdTousers?: boolean | UsersDefaultArgs<ExtArgs>
    usersUserFollowingsUserIdTousers?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollowings"]>



  export type UserFollowingsSelectScalar = {
    userId?: boolean
    followingId?: boolean
    followedAt?: boolean
  }

  export type UserFollowingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "followingId" | "followedAt", ExtArgs["result"]["userFollowings"]>
  export type UserFollowingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usersUserFollowingsFollowingIdTousers?: boolean | UsersDefaultArgs<ExtArgs>
    usersUserFollowingsUserIdTousers?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserFollowingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFollowings"
    objects: {
      usersUserFollowingsFollowingIdTousers: Prisma.$UsersPayload<ExtArgs>
      usersUserFollowingsUserIdTousers: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      followingId: number
      followedAt: Date
    }, ExtArgs["result"]["userFollowings"]>
    composites: {}
  }

  type UserFollowingsGetPayload<S extends boolean | null | undefined | UserFollowingsDefaultArgs> = $Result.GetResult<Prisma.$UserFollowingsPayload, S>

  type UserFollowingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFollowingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFollowingsCountAggregateInputType | true
    }

  export interface UserFollowingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFollowings'], meta: { name: 'UserFollowings' } }
    /**
     * Find zero or one UserFollowings that matches the filter.
     * @param {UserFollowingsFindUniqueArgs} args - Arguments to find a UserFollowings
     * @example
     * // Get one UserFollowings
     * const userFollowings = await prisma.userFollowings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFollowingsFindUniqueArgs>(args: SelectSubset<T, UserFollowingsFindUniqueArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFollowings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFollowingsFindUniqueOrThrowArgs} args - Arguments to find a UserFollowings
     * @example
     * // Get one UserFollowings
     * const userFollowings = await prisma.userFollowings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFollowingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFollowingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollowings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsFindFirstArgs} args - Arguments to find a UserFollowings
     * @example
     * // Get one UserFollowings
     * const userFollowings = await prisma.userFollowings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFollowingsFindFirstArgs>(args?: SelectSubset<T, UserFollowingsFindFirstArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollowings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsFindFirstOrThrowArgs} args - Arguments to find a UserFollowings
     * @example
     * // Get one UserFollowings
     * const userFollowings = await prisma.userFollowings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFollowingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFollowingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFollowings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFollowings
     * const userFollowings = await prisma.userFollowings.findMany()
     * 
     * // Get first 10 UserFollowings
     * const userFollowings = await prisma.userFollowings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userFollowingsWithUserIdOnly = await prisma.userFollowings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserFollowingsFindManyArgs>(args?: SelectSubset<T, UserFollowingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFollowings.
     * @param {UserFollowingsCreateArgs} args - Arguments to create a UserFollowings.
     * @example
     * // Create one UserFollowings
     * const UserFollowings = await prisma.userFollowings.create({
     *   data: {
     *     // ... data to create a UserFollowings
     *   }
     * })
     * 
     */
    create<T extends UserFollowingsCreateArgs>(args: SelectSubset<T, UserFollowingsCreateArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFollowings.
     * @param {UserFollowingsCreateManyArgs} args - Arguments to create many UserFollowings.
     * @example
     * // Create many UserFollowings
     * const userFollowings = await prisma.userFollowings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFollowingsCreateManyArgs>(args?: SelectSubset<T, UserFollowingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserFollowings.
     * @param {UserFollowingsDeleteArgs} args - Arguments to delete one UserFollowings.
     * @example
     * // Delete one UserFollowings
     * const UserFollowings = await prisma.userFollowings.delete({
     *   where: {
     *     // ... filter to delete one UserFollowings
     *   }
     * })
     * 
     */
    delete<T extends UserFollowingsDeleteArgs>(args: SelectSubset<T, UserFollowingsDeleteArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFollowings.
     * @param {UserFollowingsUpdateArgs} args - Arguments to update one UserFollowings.
     * @example
     * // Update one UserFollowings
     * const userFollowings = await prisma.userFollowings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFollowingsUpdateArgs>(args: SelectSubset<T, UserFollowingsUpdateArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFollowings.
     * @param {UserFollowingsDeleteManyArgs} args - Arguments to filter UserFollowings to delete.
     * @example
     * // Delete a few UserFollowings
     * const { count } = await prisma.userFollowings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFollowingsDeleteManyArgs>(args?: SelectSubset<T, UserFollowingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFollowings
     * const userFollowings = await prisma.userFollowings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFollowingsUpdateManyArgs>(args: SelectSubset<T, UserFollowingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFollowings.
     * @param {UserFollowingsUpsertArgs} args - Arguments to update or create a UserFollowings.
     * @example
     * // Update or create a UserFollowings
     * const userFollowings = await prisma.userFollowings.upsert({
     *   create: {
     *     // ... data to create a UserFollowings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFollowings we want to update
     *   }
     * })
     */
    upsert<T extends UserFollowingsUpsertArgs>(args: SelectSubset<T, UserFollowingsUpsertArgs<ExtArgs>>): Prisma__UserFollowingsClient<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsCountArgs} args - Arguments to filter UserFollowings to count.
     * @example
     * // Count the number of UserFollowings
     * const count = await prisma.userFollowings.count({
     *   where: {
     *     // ... the filter for the UserFollowings we want to count
     *   }
     * })
    **/
    count<T extends UserFollowingsCountArgs>(
      args?: Subset<T, UserFollowingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFollowingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFollowingsAggregateArgs>(args: Subset<T, UserFollowingsAggregateArgs>): Prisma.PrismaPromise<GetUserFollowingsAggregateType<T>>

    /**
     * Group by UserFollowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFollowingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFollowingsGroupByArgs['orderBy'] }
        : { orderBy?: UserFollowingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFollowingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFollowingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFollowings model
   */
  readonly fields: UserFollowingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFollowings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFollowingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usersUserFollowingsFollowingIdTousers<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usersUserFollowingsUserIdTousers<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFollowings model
   */
  interface UserFollowingsFieldRefs {
    readonly userId: FieldRef<"UserFollowings", 'Int'>
    readonly followingId: FieldRef<"UserFollowings", 'Int'>
    readonly followedAt: FieldRef<"UserFollowings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFollowings findUnique
   */
  export type UserFollowingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which UserFollowings to fetch.
     */
    where: UserFollowingsWhereUniqueInput
  }

  /**
   * UserFollowings findUniqueOrThrow
   */
  export type UserFollowingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which UserFollowings to fetch.
     */
    where: UserFollowingsWhereUniqueInput
  }

  /**
   * UserFollowings findFirst
   */
  export type UserFollowingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which UserFollowings to fetch.
     */
    where?: UserFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollowings to fetch.
     */
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollowings.
     */
    cursor?: UserFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollowings.
     */
    distinct?: UserFollowingsScalarFieldEnum | UserFollowingsScalarFieldEnum[]
  }

  /**
   * UserFollowings findFirstOrThrow
   */
  export type UserFollowingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which UserFollowings to fetch.
     */
    where?: UserFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollowings to fetch.
     */
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollowings.
     */
    cursor?: UserFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollowings.
     */
    distinct?: UserFollowingsScalarFieldEnum | UserFollowingsScalarFieldEnum[]
  }

  /**
   * UserFollowings findMany
   */
  export type UserFollowingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter, which UserFollowings to fetch.
     */
    where?: UserFollowingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollowings to fetch.
     */
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFollowings.
     */
    cursor?: UserFollowingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollowings.
     */
    skip?: number
    distinct?: UserFollowingsScalarFieldEnum | UserFollowingsScalarFieldEnum[]
  }

  /**
   * UserFollowings create
   */
  export type UserFollowingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFollowings.
     */
    data: XOR<UserFollowingsCreateInput, UserFollowingsUncheckedCreateInput>
  }

  /**
   * UserFollowings createMany
   */
  export type UserFollowingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFollowings.
     */
    data: UserFollowingsCreateManyInput | UserFollowingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFollowings update
   */
  export type UserFollowingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFollowings.
     */
    data: XOR<UserFollowingsUpdateInput, UserFollowingsUncheckedUpdateInput>
    /**
     * Choose, which UserFollowings to update.
     */
    where: UserFollowingsWhereUniqueInput
  }

  /**
   * UserFollowings updateMany
   */
  export type UserFollowingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFollowings.
     */
    data: XOR<UserFollowingsUpdateManyMutationInput, UserFollowingsUncheckedUpdateManyInput>
    /**
     * Filter which UserFollowings to update
     */
    where?: UserFollowingsWhereInput
    /**
     * Limit how many UserFollowings to update.
     */
    limit?: number
  }

  /**
   * UserFollowings upsert
   */
  export type UserFollowingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFollowings to update in case it exists.
     */
    where: UserFollowingsWhereUniqueInput
    /**
     * In case the UserFollowings found by the `where` argument doesn't exist, create a new UserFollowings with this data.
     */
    create: XOR<UserFollowingsCreateInput, UserFollowingsUncheckedCreateInput>
    /**
     * In case the UserFollowings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFollowingsUpdateInput, UserFollowingsUncheckedUpdateInput>
  }

  /**
   * UserFollowings delete
   */
  export type UserFollowingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    /**
     * Filter which UserFollowings to delete.
     */
    where: UserFollowingsWhereUniqueInput
  }

  /**
   * UserFollowings deleteMany
   */
  export type UserFollowingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollowings to delete
     */
    where?: UserFollowingsWhereInput
    /**
     * Limit how many UserFollowings to delete.
     */
    limit?: number
  }

  /**
   * UserFollowings without action
   */
  export type UserFollowingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
  }


  /**
   * Model UserSkills
   */

  export type AggregateUserSkills = {
    _count: UserSkillsCountAggregateOutputType | null
    _avg: UserSkillsAvgAggregateOutputType | null
    _sum: UserSkillsSumAggregateOutputType | null
    _min: UserSkillsMinAggregateOutputType | null
    _max: UserSkillsMaxAggregateOutputType | null
  }

  export type UserSkillsAvgAggregateOutputType = {
    userId: number | null
    skillId: number | null
    position: number | null
  }

  export type UserSkillsSumAggregateOutputType = {
    userId: number | null
    skillId: number | null
    position: number | null
  }

  export type UserSkillsMinAggregateOutputType = {
    userId: number | null
    skillId: number | null
    position: number | null
  }

  export type UserSkillsMaxAggregateOutputType = {
    userId: number | null
    skillId: number | null
    position: number | null
  }

  export type UserSkillsCountAggregateOutputType = {
    userId: number
    skillId: number
    position: number
    _all: number
  }


  export type UserSkillsAvgAggregateInputType = {
    userId?: true
    skillId?: true
    position?: true
  }

  export type UserSkillsSumAggregateInputType = {
    userId?: true
    skillId?: true
    position?: true
  }

  export type UserSkillsMinAggregateInputType = {
    userId?: true
    skillId?: true
    position?: true
  }

  export type UserSkillsMaxAggregateInputType = {
    userId?: true
    skillId?: true
    position?: true
  }

  export type UserSkillsCountAggregateInputType = {
    userId?: true
    skillId?: true
    position?: true
    _all?: true
  }

  export type UserSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to aggregate.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkills
    **/
    _count?: true | UserSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillsMaxAggregateInputType
  }

  export type GetUserSkillsAggregateType<T extends UserSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkills[P]>
      : GetScalarType<T[P], AggregateUserSkills[P]>
  }




  export type UserSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithAggregationInput | UserSkillsOrderByWithAggregationInput[]
    by: UserSkillsScalarFieldEnum[] | UserSkillsScalarFieldEnum
    having?: UserSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillsCountAggregateInputType | true
    _avg?: UserSkillsAvgAggregateInputType
    _sum?: UserSkillsSumAggregateInputType
    _min?: UserSkillsMinAggregateInputType
    _max?: UserSkillsMaxAggregateInputType
  }

  export type UserSkillsGroupByOutputType = {
    userId: number
    skillId: number
    position: number
    _count: UserSkillsCountAggregateOutputType | null
    _avg: UserSkillsAvgAggregateOutputType | null
    _sum: UserSkillsSumAggregateOutputType | null
    _min: UserSkillsMinAggregateOutputType | null
    _max: UserSkillsMaxAggregateOutputType | null
  }

  type GetUserSkillsGroupByPayload<T extends UserSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillsGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillId?: boolean
    position?: boolean
    skills?: boolean | SkillsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkills"]>



  export type UserSkillsSelectScalar = {
    userId?: boolean
    skillId?: boolean
    position?: boolean
  }

  export type UserSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "skillId" | "position", ExtArgs["result"]["userSkills"]>
  export type UserSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | SkillsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkills"
    objects: {
      skills: Prisma.$SkillsPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      skillId: number
      position: number
    }, ExtArgs["result"]["userSkills"]>
    composites: {}
  }

  type UserSkillsGetPayload<S extends boolean | null | undefined | UserSkillsDefaultArgs> = $Result.GetResult<Prisma.$UserSkillsPayload, S>

  type UserSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillsCountAggregateInputType | true
    }

  export interface UserSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkills'], meta: { name: 'UserSkills' } }
    /**
     * Find zero or one UserSkills that matches the filter.
     * @param {UserSkillsFindUniqueArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillsFindUniqueArgs>(args: SelectSubset<T, UserSkillsFindUniqueArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSkillsFindUniqueOrThrowArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindFirstArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillsFindFirstArgs>(args?: SelectSubset<T, UserSkillsFindFirstArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindFirstOrThrowArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkills
     * const userSkills = await prisma.userSkills.findMany()
     * 
     * // Get first 10 UserSkills
     * const userSkills = await prisma.userSkills.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSkillsWithUserIdOnly = await prisma.userSkills.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSkillsFindManyArgs>(args?: SelectSubset<T, UserSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkills.
     * @param {UserSkillsCreateArgs} args - Arguments to create a UserSkills.
     * @example
     * // Create one UserSkills
     * const UserSkills = await prisma.userSkills.create({
     *   data: {
     *     // ... data to create a UserSkills
     *   }
     * })
     * 
     */
    create<T extends UserSkillsCreateArgs>(args: SelectSubset<T, UserSkillsCreateArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkills.
     * @param {UserSkillsCreateManyArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkills = await prisma.userSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillsCreateManyArgs>(args?: SelectSubset<T, UserSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSkills.
     * @param {UserSkillsDeleteArgs} args - Arguments to delete one UserSkills.
     * @example
     * // Delete one UserSkills
     * const UserSkills = await prisma.userSkills.delete({
     *   where: {
     *     // ... filter to delete one UserSkills
     *   }
     * })
     * 
     */
    delete<T extends UserSkillsDeleteArgs>(args: SelectSubset<T, UserSkillsDeleteArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkills.
     * @param {UserSkillsUpdateArgs} args - Arguments to update one UserSkills.
     * @example
     * // Update one UserSkills
     * const userSkills = await prisma.userSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillsUpdateArgs>(args: SelectSubset<T, UserSkillsUpdateArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkills.
     * @param {UserSkillsDeleteManyArgs} args - Arguments to filter UserSkills to delete.
     * @example
     * // Delete a few UserSkills
     * const { count } = await prisma.userSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillsDeleteManyArgs>(args?: SelectSubset<T, UserSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkills
     * const userSkills = await prisma.userSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillsUpdateManyArgs>(args: SelectSubset<T, UserSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSkills.
     * @param {UserSkillsUpsertArgs} args - Arguments to update or create a UserSkills.
     * @example
     * // Update or create a UserSkills
     * const userSkills = await prisma.userSkills.upsert({
     *   create: {
     *     // ... data to create a UserSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkills we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillsUpsertArgs>(args: SelectSubset<T, UserSkillsUpsertArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsCountArgs} args - Arguments to filter UserSkills to count.
     * @example
     * // Count the number of UserSkills
     * const count = await prisma.userSkills.count({
     *   where: {
     *     // ... the filter for the UserSkills we want to count
     *   }
     * })
    **/
    count<T extends UserSkillsCountArgs>(
      args?: Subset<T, UserSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillsAggregateArgs>(args: Subset<T, UserSkillsAggregateArgs>): Prisma.PrismaPromise<GetUserSkillsAggregateType<T>>

    /**
     * Group by UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillsGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkills model
   */
  readonly fields: UserSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends SkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsDefaultArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkills model
   */
  interface UserSkillsFieldRefs {
    readonly userId: FieldRef<"UserSkills", 'Int'>
    readonly skillId: FieldRef<"UserSkills", 'Int'>
    readonly position: FieldRef<"UserSkills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserSkills findUnique
   */
  export type UserSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills findUniqueOrThrow
   */
  export type UserSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills findFirst
   */
  export type UserSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills findFirstOrThrow
   */
  export type UserSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills findMany
   */
  export type UserSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills create
   */
  export type UserSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkills.
     */
    data: XOR<UserSkillsCreateInput, UserSkillsUncheckedCreateInput>
  }

  /**
   * UserSkills createMany
   */
  export type UserSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillsCreateManyInput | UserSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkills update
   */
  export type UserSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkills.
     */
    data: XOR<UserSkillsUpdateInput, UserSkillsUncheckedUpdateInput>
    /**
     * Choose, which UserSkills to update.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills updateMany
   */
  export type UserSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillsWhereInput
    /**
     * Limit how many UserSkills to update.
     */
    limit?: number
  }

  /**
   * UserSkills upsert
   */
  export type UserSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkills to update in case it exists.
     */
    where: UserSkillsWhereUniqueInput
    /**
     * In case the UserSkills found by the `where` argument doesn't exist, create a new UserSkills with this data.
     */
    create: XOR<UserSkillsCreateInput, UserSkillsUncheckedCreateInput>
    /**
     * In case the UserSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillsUpdateInput, UserSkillsUncheckedUpdateInput>
  }

  /**
   * UserSkills delete
   */
  export type UserSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter which UserSkills to delete.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills deleteMany
   */
  export type UserSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to delete
     */
    where?: UserSkillsWhereInput
    /**
     * Limit how many UserSkills to delete.
     */
    limit?: number
  }

  /**
   * UserSkills without action
   */
  export type UserSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
  }


  /**
   * Model UserSocials
   */

  export type AggregateUserSocials = {
    _count: UserSocialsCountAggregateOutputType | null
    _avg: UserSocialsAvgAggregateOutputType | null
    _sum: UserSocialsSumAggregateOutputType | null
    _min: UserSocialsMinAggregateOutputType | null
    _max: UserSocialsMaxAggregateOutputType | null
  }

  export type UserSocialsAvgAggregateOutputType = {
    userId: number | null
    websiteId: number | null
  }

  export type UserSocialsSumAggregateOutputType = {
    userId: number | null
    websiteId: number | null
  }

  export type UserSocialsMinAggregateOutputType = {
    userId: number | null
    websiteId: number | null
    url: string | null
  }

  export type UserSocialsMaxAggregateOutputType = {
    userId: number | null
    websiteId: number | null
    url: string | null
  }

  export type UserSocialsCountAggregateOutputType = {
    userId: number
    websiteId: number
    url: number
    _all: number
  }


  export type UserSocialsAvgAggregateInputType = {
    userId?: true
    websiteId?: true
  }

  export type UserSocialsSumAggregateInputType = {
    userId?: true
    websiteId?: true
  }

  export type UserSocialsMinAggregateInputType = {
    userId?: true
    websiteId?: true
    url?: true
  }

  export type UserSocialsMaxAggregateInputType = {
    userId?: true
    websiteId?: true
    url?: true
  }

  export type UserSocialsCountAggregateInputType = {
    userId?: true
    websiteId?: true
    url?: true
    _all?: true
  }

  export type UserSocialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocials to aggregate.
     */
    where?: UserSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSocials
    **/
    _count?: true | UserSocialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSocialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSocialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSocialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSocialsMaxAggregateInputType
  }

  export type GetUserSocialsAggregateType<T extends UserSocialsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSocials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSocials[P]>
      : GetScalarType<T[P], AggregateUserSocials[P]>
  }




  export type UserSocialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialsWhereInput
    orderBy?: UserSocialsOrderByWithAggregationInput | UserSocialsOrderByWithAggregationInput[]
    by: UserSocialsScalarFieldEnum[] | UserSocialsScalarFieldEnum
    having?: UserSocialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSocialsCountAggregateInputType | true
    _avg?: UserSocialsAvgAggregateInputType
    _sum?: UserSocialsSumAggregateInputType
    _min?: UserSocialsMinAggregateInputType
    _max?: UserSocialsMaxAggregateInputType
  }

  export type UserSocialsGroupByOutputType = {
    userId: number
    websiteId: number
    url: string
    _count: UserSocialsCountAggregateOutputType | null
    _avg: UserSocialsAvgAggregateOutputType | null
    _sum: UserSocialsSumAggregateOutputType | null
    _min: UserSocialsMinAggregateOutputType | null
    _max: UserSocialsMaxAggregateOutputType | null
  }

  type GetUserSocialsGroupByPayload<T extends UserSocialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSocialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSocialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSocialsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSocialsGroupByOutputType[P]>
        }
      >
    >


  export type UserSocialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    websiteId?: boolean
    url?: boolean
    socials?: boolean | SocialsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocials"]>



  export type UserSocialsSelectScalar = {
    userId?: boolean
    websiteId?: boolean
    url?: boolean
  }

  export type UserSocialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "websiteId" | "url", ExtArgs["result"]["userSocials"]>
  export type UserSocialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socials?: boolean | SocialsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserSocialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSocials"
    objects: {
      socials: Prisma.$SocialsPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      websiteId: number
      url: string
    }, ExtArgs["result"]["userSocials"]>
    composites: {}
  }

  type UserSocialsGetPayload<S extends boolean | null | undefined | UserSocialsDefaultArgs> = $Result.GetResult<Prisma.$UserSocialsPayload, S>

  type UserSocialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSocialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSocialsCountAggregateInputType | true
    }

  export interface UserSocialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSocials'], meta: { name: 'UserSocials' } }
    /**
     * Find zero or one UserSocials that matches the filter.
     * @param {UserSocialsFindUniqueArgs} args - Arguments to find a UserSocials
     * @example
     * // Get one UserSocials
     * const userSocials = await prisma.userSocials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSocialsFindUniqueArgs>(args: SelectSubset<T, UserSocialsFindUniqueArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSocials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSocialsFindUniqueOrThrowArgs} args - Arguments to find a UserSocials
     * @example
     * // Get one UserSocials
     * const userSocials = await prisma.userSocials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSocialsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSocialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsFindFirstArgs} args - Arguments to find a UserSocials
     * @example
     * // Get one UserSocials
     * const userSocials = await prisma.userSocials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSocialsFindFirstArgs>(args?: SelectSubset<T, UserSocialsFindFirstArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsFindFirstOrThrowArgs} args - Arguments to find a UserSocials
     * @example
     * // Get one UserSocials
     * const userSocials = await prisma.userSocials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSocialsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSocialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSocials
     * const userSocials = await prisma.userSocials.findMany()
     * 
     * // Get first 10 UserSocials
     * const userSocials = await prisma.userSocials.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSocialsWithUserIdOnly = await prisma.userSocials.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSocialsFindManyArgs>(args?: SelectSubset<T, UserSocialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSocials.
     * @param {UserSocialsCreateArgs} args - Arguments to create a UserSocials.
     * @example
     * // Create one UserSocials
     * const UserSocials = await prisma.userSocials.create({
     *   data: {
     *     // ... data to create a UserSocials
     *   }
     * })
     * 
     */
    create<T extends UserSocialsCreateArgs>(args: SelectSubset<T, UserSocialsCreateArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSocials.
     * @param {UserSocialsCreateManyArgs} args - Arguments to create many UserSocials.
     * @example
     * // Create many UserSocials
     * const userSocials = await prisma.userSocials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSocialsCreateManyArgs>(args?: SelectSubset<T, UserSocialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSocials.
     * @param {UserSocialsDeleteArgs} args - Arguments to delete one UserSocials.
     * @example
     * // Delete one UserSocials
     * const UserSocials = await prisma.userSocials.delete({
     *   where: {
     *     // ... filter to delete one UserSocials
     *   }
     * })
     * 
     */
    delete<T extends UserSocialsDeleteArgs>(args: SelectSubset<T, UserSocialsDeleteArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSocials.
     * @param {UserSocialsUpdateArgs} args - Arguments to update one UserSocials.
     * @example
     * // Update one UserSocials
     * const userSocials = await prisma.userSocials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSocialsUpdateArgs>(args: SelectSubset<T, UserSocialsUpdateArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSocials.
     * @param {UserSocialsDeleteManyArgs} args - Arguments to filter UserSocials to delete.
     * @example
     * // Delete a few UserSocials
     * const { count } = await prisma.userSocials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSocialsDeleteManyArgs>(args?: SelectSubset<T, UserSocialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSocials
     * const userSocials = await prisma.userSocials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSocialsUpdateManyArgs>(args: SelectSubset<T, UserSocialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSocials.
     * @param {UserSocialsUpsertArgs} args - Arguments to update or create a UserSocials.
     * @example
     * // Update or create a UserSocials
     * const userSocials = await prisma.userSocials.upsert({
     *   create: {
     *     // ... data to create a UserSocials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSocials we want to update
     *   }
     * })
     */
    upsert<T extends UserSocialsUpsertArgs>(args: SelectSubset<T, UserSocialsUpsertArgs<ExtArgs>>): Prisma__UserSocialsClient<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsCountArgs} args - Arguments to filter UserSocials to count.
     * @example
     * // Count the number of UserSocials
     * const count = await prisma.userSocials.count({
     *   where: {
     *     // ... the filter for the UserSocials we want to count
     *   }
     * })
    **/
    count<T extends UserSocialsCountArgs>(
      args?: Subset<T, UserSocialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSocialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSocialsAggregateArgs>(args: Subset<T, UserSocialsAggregateArgs>): Prisma.PrismaPromise<GetUserSocialsAggregateType<T>>

    /**
     * Group by UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSocialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSocialsGroupByArgs['orderBy'] }
        : { orderBy?: UserSocialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSocialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSocialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSocials model
   */
  readonly fields: UserSocialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSocials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSocialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    socials<T extends SocialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialsDefaultArgs<ExtArgs>>): Prisma__SocialsClient<$Result.GetResult<Prisma.$SocialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSocials model
   */
  interface UserSocialsFieldRefs {
    readonly userId: FieldRef<"UserSocials", 'Int'>
    readonly websiteId: FieldRef<"UserSocials", 'Int'>
    readonly url: FieldRef<"UserSocials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSocials findUnique
   */
  export type UserSocialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where: UserSocialsWhereUniqueInput
  }

  /**
   * UserSocials findUniqueOrThrow
   */
  export type UserSocialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where: UserSocialsWhereUniqueInput
  }

  /**
   * UserSocials findFirst
   */
  export type UserSocialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where?: UserSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocials.
     */
    cursor?: UserSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocials.
     */
    distinct?: UserSocialsScalarFieldEnum | UserSocialsScalarFieldEnum[]
  }

  /**
   * UserSocials findFirstOrThrow
   */
  export type UserSocialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where?: UserSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocials.
     */
    cursor?: UserSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocials.
     */
    distinct?: UserSocialsScalarFieldEnum | UserSocialsScalarFieldEnum[]
  }

  /**
   * UserSocials findMany
   */
  export type UserSocialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where?: UserSocialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSocials.
     */
    cursor?: UserSocialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    distinct?: UserSocialsScalarFieldEnum | UserSocialsScalarFieldEnum[]
  }

  /**
   * UserSocials create
   */
  export type UserSocialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSocials.
     */
    data: XOR<UserSocialsCreateInput, UserSocialsUncheckedCreateInput>
  }

  /**
   * UserSocials createMany
   */
  export type UserSocialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSocials.
     */
    data: UserSocialsCreateManyInput | UserSocialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSocials update
   */
  export type UserSocialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSocials.
     */
    data: XOR<UserSocialsUpdateInput, UserSocialsUncheckedUpdateInput>
    /**
     * Choose, which UserSocials to update.
     */
    where: UserSocialsWhereUniqueInput
  }

  /**
   * UserSocials updateMany
   */
  export type UserSocialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSocials.
     */
    data: XOR<UserSocialsUpdateManyMutationInput, UserSocialsUncheckedUpdateManyInput>
    /**
     * Filter which UserSocials to update
     */
    where?: UserSocialsWhereInput
    /**
     * Limit how many UserSocials to update.
     */
    limit?: number
  }

  /**
   * UserSocials upsert
   */
  export type UserSocialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSocials to update in case it exists.
     */
    where: UserSocialsWhereUniqueInput
    /**
     * In case the UserSocials found by the `where` argument doesn't exist, create a new UserSocials with this data.
     */
    create: XOR<UserSocialsCreateInput, UserSocialsUncheckedCreateInput>
    /**
     * In case the UserSocials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSocialsUpdateInput, UserSocialsUncheckedUpdateInput>
  }

  /**
   * UserSocials delete
   */
  export type UserSocialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    /**
     * Filter which UserSocials to delete.
     */
    where: UserSocialsWhereUniqueInput
  }

  /**
   * UserSocials deleteMany
   */
  export type UserSocialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocials to delete
     */
    where?: UserSocialsWhereInput
    /**
     * Limit how many UserSocials to delete.
     */
    limit?: number
  }

  /**
   * UserSocials without action
   */
  export type UserSocialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    userId: number | null
    jobTitleId: number | null
    majorId: number | null
    visibility: number | null
    phoneNumber: number | null
  }

  export type UsersSumAggregateOutputType = {
    userId: number | null
    jobTitleId: number | null
    majorId: number | null
    visibility: number | null
    phoneNumber: number | null
  }

  export type UsersMinAggregateOutputType = {
    userId: number | null
    username: string | null
    ritEmail: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    headline: string | null
    pronouns: string | null
    jobTitleId: number | null
    majorId: number | null
    academicYear: $Enums.UsersAcademicYear | null
    location: string | null
    funFact: string | null
    bio: string | null
    visibility: number | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: number | null
    universityId: string | null
  }

  export type UsersMaxAggregateOutputType = {
    userId: number | null
    username: string | null
    ritEmail: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    headline: string | null
    pronouns: string | null
    jobTitleId: number | null
    majorId: number | null
    academicYear: $Enums.UsersAcademicYear | null
    location: string | null
    funFact: string | null
    bio: string | null
    visibility: number | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: number | null
    universityId: string | null
  }

  export type UsersCountAggregateOutputType = {
    userId: number
    username: number
    ritEmail: number
    firstName: number
    lastName: number
    profileImage: number
    headline: number
    pronouns: number
    jobTitleId: number
    majorId: number
    academicYear: number
    location: number
    funFact: number
    bio: number
    visibility: number
    createdAt: number
    updatedAt: number
    phoneNumber: number
    universityId: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    userId?: true
    jobTitleId?: true
    majorId?: true
    visibility?: true
    phoneNumber?: true
  }

  export type UsersSumAggregateInputType = {
    userId?: true
    jobTitleId?: true
    majorId?: true
    visibility?: true
    phoneNumber?: true
  }

  export type UsersMinAggregateInputType = {
    userId?: true
    username?: true
    ritEmail?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    headline?: true
    pronouns?: true
    jobTitleId?: true
    majorId?: true
    academicYear?: true
    location?: true
    funFact?: true
    bio?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    universityId?: true
  }

  export type UsersMaxAggregateInputType = {
    userId?: true
    username?: true
    ritEmail?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    headline?: true
    pronouns?: true
    jobTitleId?: true
    majorId?: true
    academicYear?: true
    location?: true
    funFact?: true
    bio?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    universityId?: true
  }

  export type UsersCountAggregateInputType = {
    userId?: true
    username?: true
    ritEmail?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    headline?: true
    pronouns?: true
    jobTitleId?: true
    majorId?: true
    academicYear?: true
    location?: true
    funFact?: true
    bio?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    universityId?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    userId: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage: string | null
    headline: string | null
    pronouns: string | null
    jobTitleId: number | null
    majorId: number | null
    academicYear: $Enums.UsersAcademicYear | null
    location: string | null
    funFact: string | null
    bio: string | null
    visibility: number
    createdAt: Date
    updatedAt: Date
    phoneNumber: number | null
    universityId: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    username?: boolean
    ritEmail?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    headline?: boolean
    pronouns?: boolean
    jobTitleId?: boolean
    majorId?: boolean
    academicYear?: boolean
    location?: boolean
    funFact?: boolean
    bio?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    universityId?: boolean
    members?: boolean | Users$membersArgs<ExtArgs>
    projectFollowings?: boolean | Users$projectFollowingsArgs<ExtArgs>
    projects?: boolean | Users$projectsArgs<ExtArgs>
    userFollowingsUserFollowingsFollowingIdTousers?: boolean | Users$userFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs>
    userFollowingsUserFollowingsUserIdTousers?: boolean | Users$userFollowingsUserFollowingsUserIdTousersArgs<ExtArgs>
    userSkills?: boolean | Users$userSkillsArgs<ExtArgs>
    userSocials?: boolean | Users$userSocialsArgs<ExtArgs>
    jobTitles?: boolean | Users$jobTitlesArgs<ExtArgs>
    majors?: boolean | Users$majorsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    userId?: boolean
    username?: boolean
    ritEmail?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    headline?: boolean
    pronouns?: boolean
    jobTitleId?: boolean
    majorId?: boolean
    academicYear?: boolean
    location?: boolean
    funFact?: boolean
    bio?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    universityId?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "username" | "ritEmail" | "firstName" | "lastName" | "profileImage" | "headline" | "pronouns" | "jobTitleId" | "majorId" | "academicYear" | "location" | "funFact" | "bio" | "visibility" | "createdAt" | "updatedAt" | "phoneNumber" | "universityId", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Users$membersArgs<ExtArgs>
    projectFollowings?: boolean | Users$projectFollowingsArgs<ExtArgs>
    projects?: boolean | Users$projectsArgs<ExtArgs>
    userFollowingsUserFollowingsFollowingIdTousers?: boolean | Users$userFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs>
    userFollowingsUserFollowingsUserIdTousers?: boolean | Users$userFollowingsUserFollowingsUserIdTousersArgs<ExtArgs>
    userSkills?: boolean | Users$userSkillsArgs<ExtArgs>
    userSocials?: boolean | Users$userSocialsArgs<ExtArgs>
    jobTitles?: boolean | Users$jobTitlesArgs<ExtArgs>
    majors?: boolean | Users$majorsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      members: Prisma.$MembersPayload<ExtArgs>[]
      projectFollowings: Prisma.$ProjectFollowingsPayload<ExtArgs>[]
      projects: Prisma.$ProjectsPayload<ExtArgs>[]
      userFollowingsUserFollowingsFollowingIdTousers: Prisma.$UserFollowingsPayload<ExtArgs>[]
      userFollowingsUserFollowingsUserIdTousers: Prisma.$UserFollowingsPayload<ExtArgs>[]
      userSkills: Prisma.$UserSkillsPayload<ExtArgs>[]
      userSocials: Prisma.$UserSocialsPayload<ExtArgs>[]
      jobTitles: Prisma.$JobTitlesPayload<ExtArgs> | null
      majors: Prisma.$MajorsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      username: string
      ritEmail: string
      firstName: string
      lastName: string
      profileImage: string | null
      headline: string | null
      pronouns: string | null
      jobTitleId: number | null
      majorId: number | null
      academicYear: $Enums.UsersAcademicYear | null
      location: string | null
      funFact: string | null
      bio: string | null
      visibility: number
      createdAt: Date
      updatedAt: Date
      phoneNumber: number | null
      universityId: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersWithUserIdOnly = await prisma.users.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Users$membersArgs<ExtArgs> = {}>(args?: Subset<T, Users$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectFollowings<T extends Users$projectFollowingsArgs<ExtArgs> = {}>(args?: Subset<T, Users$projectFollowingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Users$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Users$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFollowingsUserFollowingsFollowingIdTousers<T extends Users$userFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, Users$userFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFollowingsUserFollowingsUserIdTousers<T extends Users$userFollowingsUserFollowingsUserIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, Users$userFollowingsUserFollowingsUserIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSkills<T extends Users$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Users$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSocials<T extends Users$userSocialsArgs<ExtArgs> = {}>(args?: Subset<T, Users$userSocialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobTitles<T extends Users$jobTitlesArgs<ExtArgs> = {}>(args?: Subset<T, Users$jobTitlesArgs<ExtArgs>>): Prisma__JobTitlesClient<$Result.GetResult<Prisma.$JobTitlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    majors<T extends Users$majorsArgs<ExtArgs> = {}>(args?: Subset<T, Users$majorsArgs<ExtArgs>>): Prisma__MajorsClient<$Result.GetResult<Prisma.$MajorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly userId: FieldRef<"Users", 'Int'>
    readonly username: FieldRef<"Users", 'String'>
    readonly ritEmail: FieldRef<"Users", 'String'>
    readonly firstName: FieldRef<"Users", 'String'>
    readonly lastName: FieldRef<"Users", 'String'>
    readonly profileImage: FieldRef<"Users", 'String'>
    readonly headline: FieldRef<"Users", 'String'>
    readonly pronouns: FieldRef<"Users", 'String'>
    readonly jobTitleId: FieldRef<"Users", 'Int'>
    readonly majorId: FieldRef<"Users", 'Int'>
    readonly academicYear: FieldRef<"Users", 'UsersAcademicYear'>
    readonly location: FieldRef<"Users", 'String'>
    readonly funFact: FieldRef<"Users", 'String'>
    readonly bio: FieldRef<"Users", 'String'>
    readonly visibility: FieldRef<"Users", 'Int'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly phoneNumber: FieldRef<"Users", 'Int'>
    readonly universityId: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.members
   */
  export type Users$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Members
     */
    omit?: MembersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    where?: MembersWhereInput
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    cursor?: MembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Users.projectFollowings
   */
  export type Users$projectFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFollowings
     */
    select?: ProjectFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFollowings
     */
    omit?: ProjectFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFollowingsInclude<ExtArgs> | null
    where?: ProjectFollowingsWhereInput
    orderBy?: ProjectFollowingsOrderByWithRelationInput | ProjectFollowingsOrderByWithRelationInput[]
    cursor?: ProjectFollowingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFollowingsScalarFieldEnum | ProjectFollowingsScalarFieldEnum[]
  }

  /**
   * Users.projects
   */
  export type Users$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Projects
     */
    omit?: ProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    where?: ProjectsWhereInput
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    cursor?: ProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Users.userFollowingsUserFollowingsFollowingIdTousers
   */
  export type Users$userFollowingsUserFollowingsFollowingIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    where?: UserFollowingsWhereInput
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    cursor?: UserFollowingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowingsScalarFieldEnum | UserFollowingsScalarFieldEnum[]
  }

  /**
   * Users.userFollowingsUserFollowingsUserIdTousers
   */
  export type Users$userFollowingsUserFollowingsUserIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollowings
     */
    select?: UserFollowingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollowings
     */
    omit?: UserFollowingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowingsInclude<ExtArgs> | null
    where?: UserFollowingsWhereInput
    orderBy?: UserFollowingsOrderByWithRelationInput | UserFollowingsOrderByWithRelationInput[]
    cursor?: UserFollowingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowingsScalarFieldEnum | UserFollowingsScalarFieldEnum[]
  }

  /**
   * Users.userSkills
   */
  export type Users$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    cursor?: UserSkillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * Users.userSocials
   */
  export type Users$userSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocials
     */
    select?: UserSocialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocials
     */
    omit?: UserSocialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialsInclude<ExtArgs> | null
    where?: UserSocialsWhereInput
    orderBy?: UserSocialsOrderByWithRelationInput | UserSocialsOrderByWithRelationInput[]
    cursor?: UserSocialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSocialsScalarFieldEnum | UserSocialsScalarFieldEnum[]
  }

  /**
   * Users.jobTitles
   */
  export type Users$jobTitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitles
     */
    select?: JobTitlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobTitles
     */
    omit?: JobTitlesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitlesInclude<ExtArgs> | null
    where?: JobTitlesWhereInput
  }

  /**
   * Users.majors
   */
  export type Users$majorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Majors
     */
    select?: MajorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Majors
     */
    omit?: MajorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MajorsInclude<ExtArgs> | null
    where?: MajorsWhereInput
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsAvgAggregateOutputType = {
    skillId: number | null
  }

  export type SkillsSumAggregateOutputType = {
    skillId: number | null
  }

  export type SkillsMinAggregateOutputType = {
    skillId: number | null
    label: string | null
    type: string | null
  }

  export type SkillsMaxAggregateOutputType = {
    skillId: number | null
    label: string | null
    type: string | null
  }

  export type SkillsCountAggregateOutputType = {
    skillId: number
    label: number
    type: number
    _all: number
  }


  export type SkillsAvgAggregateInputType = {
    skillId?: true
  }

  export type SkillsSumAggregateInputType = {
    skillId?: true
  }

  export type SkillsMinAggregateInputType = {
    skillId?: true
    label?: true
    type?: true
  }

  export type SkillsMaxAggregateInputType = {
    skillId?: true
    label?: true
    type?: true
  }

  export type SkillsCountAggregateInputType = {
    skillId?: true
    label?: true
    type?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to aggregate.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type SkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillsWhereInput
    orderBy?: SkillsOrderByWithAggregationInput | SkillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: SkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _avg?: SkillsAvgAggregateInputType
    _sum?: SkillsSumAggregateInputType
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    skillId: number
    label: string
    type: string
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends SkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type SkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skillId?: boolean
    label?: boolean
    type?: boolean
    userSkills?: boolean | Skills$userSkillsArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>



  export type SkillsSelectScalar = {
    skillId?: boolean
    label?: boolean
    type?: boolean
  }

  export type SkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"skillId" | "label" | "type", ExtArgs["result"]["skills"]>
  export type SkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSkills?: boolean | Skills$userSkillsArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skills"
    objects: {
      userSkills: Prisma.$UserSkillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      skillId: number
      label: string
      type: string
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type SkillsGetPayload<S extends boolean | null | undefined | SkillsDefaultArgs> = $Result.GetResult<Prisma.$SkillsPayload, S>

  type SkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface SkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skills'], meta: { name: 'Skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {SkillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillsFindUniqueArgs>(args: SelectSubset<T, SkillsFindUniqueArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillsFindFirstArgs>(args?: SelectSubset<T, SkillsFindFirstArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `skillId`
     * const skillsWithSkillIdOnly = await prisma.skills.findMany({ select: { skillId: true } })
     * 
     */
    findMany<T extends SkillsFindManyArgs>(args?: SelectSubset<T, SkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skills.
     * @param {SkillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends SkillsCreateArgs>(args: SelectSubset<T, SkillsCreateArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillsCreateManyArgs>(args?: SelectSubset<T, SkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skills.
     * @param {SkillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends SkillsDeleteArgs>(args: SelectSubset<T, SkillsDeleteArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skills.
     * @param {SkillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillsUpdateArgs>(args: SelectSubset<T, SkillsUpdateArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillsDeleteManyArgs>(args?: SelectSubset<T, SkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillsUpdateManyArgs>(args: SelectSubset<T, SkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skills.
     * @param {SkillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends SkillsUpsertArgs>(args: SelectSubset<T, SkillsUpsertArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillsCountArgs>(
      args?: Subset<T, SkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillsGroupByArgs['orderBy'] }
        : { orderBy?: SkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skills model
   */
  readonly fields: SkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userSkills<T extends Skills$userSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skills$userSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skills model
   */
  interface SkillsFieldRefs {
    readonly skillId: FieldRef<"Skills", 'Int'>
    readonly label: FieldRef<"Skills", 'String'>
    readonly type: FieldRef<"Skills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skills findUnique
   */
  export type SkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills findUniqueOrThrow
   */
  export type SkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills findFirst
   */
  export type SkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills findFirstOrThrow
   */
  export type SkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills findMany
   */
  export type SkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills create
   */
  export type SkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a Skills.
     */
    data: XOR<SkillsCreateInput, SkillsUncheckedCreateInput>
  }

  /**
   * Skills createMany
   */
  export type SkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillsCreateManyInput | SkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skills update
   */
  export type SkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a Skills.
     */
    data: XOR<SkillsUpdateInput, SkillsUncheckedUpdateInput>
    /**
     * Choose, which Skills to update.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills updateMany
   */
  export type SkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillsUpdateManyMutationInput, SkillsUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillsWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skills upsert
   */
  export type SkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the Skills to update in case it exists.
     */
    where: SkillsWhereUniqueInput
    /**
     * In case the Skills found by the `where` argument doesn't exist, create a new Skills with this data.
     */
    create: XOR<SkillsCreateInput, SkillsUncheckedCreateInput>
    /**
     * In case the Skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillsUpdateInput, SkillsUncheckedUpdateInput>
  }

  /**
   * Skills delete
   */
  export type SkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter which Skills to delete.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills deleteMany
   */
  export type SkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillsWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skills.userSkills
   */
  export type Skills$userSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    cursor?: UserSkillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * Skills without action
   */
  export type SkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skills
     */
    omit?: SkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GenresScalarFieldEnum: {
    typeId: 'typeId',
    label: 'label'
  };

  export type GenresScalarFieldEnum = (typeof GenresScalarFieldEnum)[keyof typeof GenresScalarFieldEnum]


  export const JobTitlesScalarFieldEnum: {
    titleId: 'titleId',
    label: 'label'
  };

  export type JobTitlesScalarFieldEnum = (typeof JobTitlesScalarFieldEnum)[keyof typeof JobTitlesScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    projectId: 'projectId',
    titleId: 'titleId',
    availability: 'availability',
    duration: 'duration',
    location: 'location',
    compensation: 'compensation',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const MajorsScalarFieldEnum: {
    majorId: 'majorId',
    label: 'label'
  };

  export type MajorsScalarFieldEnum = (typeof MajorsScalarFieldEnum)[keyof typeof MajorsScalarFieldEnum]


  export const MembersScalarFieldEnum: {
    projectId: 'projectId',
    userId: 'userId',
    titleId: 'titleId',
    profileVisibility: 'profileVisibility',
    createdAt: 'createdAt'
  };

  export type MembersScalarFieldEnum = (typeof MembersScalarFieldEnum)[keyof typeof MembersScalarFieldEnum]


  export const ProjectFollowingsScalarFieldEnum: {
    userId: 'userId',
    projectId: 'projectId',
    followedAt: 'followedAt'
  };

  export type ProjectFollowingsScalarFieldEnum = (typeof ProjectFollowingsScalarFieldEnum)[keyof typeof ProjectFollowingsScalarFieldEnum]


  export const ProjectGenresScalarFieldEnum: {
    projectId: 'projectId',
    typeId: 'typeId'
  };

  export type ProjectGenresScalarFieldEnum = (typeof ProjectGenresScalarFieldEnum)[keyof typeof ProjectGenresScalarFieldEnum]


  export const ProjectImagesScalarFieldEnum: {
    imageId: 'imageId',
    image: 'image',
    position: 'position',
    projectId: 'projectId'
  };

  export type ProjectImagesScalarFieldEnum = (typeof ProjectImagesScalarFieldEnum)[keyof typeof ProjectImagesScalarFieldEnum]


  export const ProjectSocialsScalarFieldEnum: {
    projectId: 'projectId',
    websiteId: 'websiteId',
    url: 'url'
  };

  export type ProjectSocialsScalarFieldEnum = (typeof ProjectSocialsScalarFieldEnum)[keyof typeof ProjectSocialsScalarFieldEnum]


  export const ProjectTagsScalarFieldEnum: {
    projectId: 'projectId',
    tagId: 'tagId',
    position: 'position'
  };

  export type ProjectTagsScalarFieldEnum = (typeof ProjectTagsScalarFieldEnum)[keyof typeof ProjectTagsScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    projectId: 'projectId',
    title: 'title',
    hook: 'hook',
    description: 'description',
    thumbnail: 'thumbnail',
    purpose: 'purpose',
    status: 'status',
    audience: 'audience',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const SocialsScalarFieldEnum: {
    websiteId: 'websiteId',
    label: 'label'
  };

  export type SocialsScalarFieldEnum = (typeof SocialsScalarFieldEnum)[keyof typeof SocialsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    tagId: 'tagId',
    label: 'label',
    type: 'type'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const UserFollowingsScalarFieldEnum: {
    userId: 'userId',
    followingId: 'followingId',
    followedAt: 'followedAt'
  };

  export type UserFollowingsScalarFieldEnum = (typeof UserFollowingsScalarFieldEnum)[keyof typeof UserFollowingsScalarFieldEnum]


  export const UserSkillsScalarFieldEnum: {
    userId: 'userId',
    skillId: 'skillId',
    position: 'position'
  };

  export type UserSkillsScalarFieldEnum = (typeof UserSkillsScalarFieldEnum)[keyof typeof UserSkillsScalarFieldEnum]


  export const UserSocialsScalarFieldEnum: {
    userId: 'userId',
    websiteId: 'websiteId',
    url: 'url'
  };

  export type UserSocialsScalarFieldEnum = (typeof UserSocialsScalarFieldEnum)[keyof typeof UserSocialsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    userId: 'userId',
    username: 'username',
    ritEmail: 'ritEmail',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    headline: 'headline',
    pronouns: 'pronouns',
    jobTitleId: 'jobTitleId',
    majorId: 'majorId',
    academicYear: 'academicYear',
    location: 'location',
    funFact: 'funFact',
    bio: 'bio',
    visibility: 'visibility',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phoneNumber: 'phoneNumber',
    universityId: 'universityId'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    skillId: 'skillId',
    label: 'label',
    type: 'type'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const GenresOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type GenresOrderByRelevanceFieldEnum = (typeof GenresOrderByRelevanceFieldEnum)[keyof typeof GenresOrderByRelevanceFieldEnum]


  export const JobTitlesOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type JobTitlesOrderByRelevanceFieldEnum = (typeof JobTitlesOrderByRelevanceFieldEnum)[keyof typeof JobTitlesOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JobsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type JobsOrderByRelevanceFieldEnum = (typeof JobsOrderByRelevanceFieldEnum)[keyof typeof JobsOrderByRelevanceFieldEnum]


  export const MajorsOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type MajorsOrderByRelevanceFieldEnum = (typeof MajorsOrderByRelevanceFieldEnum)[keyof typeof MajorsOrderByRelevanceFieldEnum]


  export const ProjectImagesOrderByRelevanceFieldEnum: {
    image: 'image'
  };

  export type ProjectImagesOrderByRelevanceFieldEnum = (typeof ProjectImagesOrderByRelevanceFieldEnum)[keyof typeof ProjectImagesOrderByRelevanceFieldEnum]


  export const ProjectSocialsOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type ProjectSocialsOrderByRelevanceFieldEnum = (typeof ProjectSocialsOrderByRelevanceFieldEnum)[keyof typeof ProjectSocialsOrderByRelevanceFieldEnum]


  export const ProjectsOrderByRelevanceFieldEnum: {
    title: 'title',
    hook: 'hook',
    description: 'description',
    thumbnail: 'thumbnail',
    audience: 'audience'
  };

  export type ProjectsOrderByRelevanceFieldEnum = (typeof ProjectsOrderByRelevanceFieldEnum)[keyof typeof ProjectsOrderByRelevanceFieldEnum]


  export const SocialsOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type SocialsOrderByRelevanceFieldEnum = (typeof SocialsOrderByRelevanceFieldEnum)[keyof typeof SocialsOrderByRelevanceFieldEnum]


  export const TagsOrderByRelevanceFieldEnum: {
    label: 'label',
    type: 'type'
  };

  export type TagsOrderByRelevanceFieldEnum = (typeof TagsOrderByRelevanceFieldEnum)[keyof typeof TagsOrderByRelevanceFieldEnum]


  export const UserSocialsOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type UserSocialsOrderByRelevanceFieldEnum = (typeof UserSocialsOrderByRelevanceFieldEnum)[keyof typeof UserSocialsOrderByRelevanceFieldEnum]


  export const UsersOrderByRelevanceFieldEnum: {
    username: 'username',
    ritEmail: 'ritEmail',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    headline: 'headline',
    pronouns: 'pronouns',
    location: 'location',
    funFact: 'funFact',
    bio: 'bio',
    universityId: 'universityId'
  };

  export type UsersOrderByRelevanceFieldEnum = (typeof UsersOrderByRelevanceFieldEnum)[keyof typeof UsersOrderByRelevanceFieldEnum]


  export const SkillsOrderByRelevanceFieldEnum: {
    label: 'label',
    type: 'type'
  };

  export type SkillsOrderByRelevanceFieldEnum = (typeof SkillsOrderByRelevanceFieldEnum)[keyof typeof SkillsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'JobsAvailability'
   */
  export type EnumJobsAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsAvailability'>
    


  /**
   * Reference to a field of type 'JobsDuration'
   */
  export type EnumJobsDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsDuration'>
    


  /**
   * Reference to a field of type 'JobsLocation'
   */
  export type EnumJobsLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsLocation'>
    


  /**
   * Reference to a field of type 'JobsCompensation'
   */
  export type EnumJobsCompensationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsCompensation'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'MembersProfileVisibility'
   */
  export type EnumMembersProfileVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembersProfileVisibility'>
    


  /**
   * Reference to a field of type 'ProjectsPurpose'
   */
  export type EnumProjectsPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectsPurpose'>
    


  /**
   * Reference to a field of type 'ProjectsStatus'
   */
  export type EnumProjectsStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectsStatus'>
    


  /**
   * Reference to a field of type 'UsersAcademicYear'
   */
  export type EnumUsersAcademicYearFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsersAcademicYear'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type GenresWhereInput = {
    AND?: GenresWhereInput | GenresWhereInput[]
    OR?: GenresWhereInput[]
    NOT?: GenresWhereInput | GenresWhereInput[]
    typeId?: IntFilter<"Genres"> | number
    label?: StringFilter<"Genres"> | string
    projectGenres?: ProjectGenresListRelationFilter
  }

  export type GenresOrderByWithRelationInput = {
    typeId?: SortOrder
    label?: SortOrder
    projectGenres?: ProjectGenresOrderByRelationAggregateInput
    _relevance?: GenresOrderByRelevanceInput
  }

  export type GenresWhereUniqueInput = Prisma.AtLeast<{
    typeId?: number
    AND?: GenresWhereInput | GenresWhereInput[]
    OR?: GenresWhereInput[]
    NOT?: GenresWhereInput | GenresWhereInput[]
    label?: StringFilter<"Genres"> | string
    projectGenres?: ProjectGenresListRelationFilter
  }, "typeId">

  export type GenresOrderByWithAggregationInput = {
    typeId?: SortOrder
    label?: SortOrder
    _count?: GenresCountOrderByAggregateInput
    _avg?: GenresAvgOrderByAggregateInput
    _max?: GenresMaxOrderByAggregateInput
    _min?: GenresMinOrderByAggregateInput
    _sum?: GenresSumOrderByAggregateInput
  }

  export type GenresScalarWhereWithAggregatesInput = {
    AND?: GenresScalarWhereWithAggregatesInput | GenresScalarWhereWithAggregatesInput[]
    OR?: GenresScalarWhereWithAggregatesInput[]
    NOT?: GenresScalarWhereWithAggregatesInput | GenresScalarWhereWithAggregatesInput[]
    typeId?: IntWithAggregatesFilter<"Genres"> | number
    label?: StringWithAggregatesFilter<"Genres"> | string
  }

  export type JobTitlesWhereInput = {
    AND?: JobTitlesWhereInput | JobTitlesWhereInput[]
    OR?: JobTitlesWhereInput[]
    NOT?: JobTitlesWhereInput | JobTitlesWhereInput[]
    titleId?: IntFilter<"JobTitles"> | number
    label?: StringFilter<"JobTitles"> | string
    jobs?: JobsListRelationFilter
    members?: MembersListRelationFilter
    users?: UsersListRelationFilter
  }

  export type JobTitlesOrderByWithRelationInput = {
    titleId?: SortOrder
    label?: SortOrder
    jobs?: JobsOrderByRelationAggregateInput
    members?: MembersOrderByRelationAggregateInput
    users?: UsersOrderByRelationAggregateInput
    _relevance?: JobTitlesOrderByRelevanceInput
  }

  export type JobTitlesWhereUniqueInput = Prisma.AtLeast<{
    titleId?: number
    AND?: JobTitlesWhereInput | JobTitlesWhereInput[]
    OR?: JobTitlesWhereInput[]
    NOT?: JobTitlesWhereInput | JobTitlesWhereInput[]
    label?: StringFilter<"JobTitles"> | string
    jobs?: JobsListRelationFilter
    members?: MembersListRelationFilter
    users?: UsersListRelationFilter
  }, "titleId">

  export type JobTitlesOrderByWithAggregationInput = {
    titleId?: SortOrder
    label?: SortOrder
    _count?: JobTitlesCountOrderByAggregateInput
    _avg?: JobTitlesAvgOrderByAggregateInput
    _max?: JobTitlesMaxOrderByAggregateInput
    _min?: JobTitlesMinOrderByAggregateInput
    _sum?: JobTitlesSumOrderByAggregateInput
  }

  export type JobTitlesScalarWhereWithAggregatesInput = {
    AND?: JobTitlesScalarWhereWithAggregatesInput | JobTitlesScalarWhereWithAggregatesInput[]
    OR?: JobTitlesScalarWhereWithAggregatesInput[]
    NOT?: JobTitlesScalarWhereWithAggregatesInput | JobTitlesScalarWhereWithAggregatesInput[]
    titleId?: IntWithAggregatesFilter<"JobTitles"> | number
    label?: StringWithAggregatesFilter<"JobTitles"> | string
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    projectId?: IntFilter<"Jobs"> | number
    titleId?: IntFilter<"Jobs"> | number
    availability?: EnumJobsAvailabilityFilter<"Jobs"> | $Enums.JobsAvailability
    duration?: EnumJobsDurationFilter<"Jobs"> | $Enums.JobsDuration
    location?: EnumJobsLocationFilter<"Jobs"> | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFilter<"Jobs"> | $Enums.JobsCompensation
    description?: StringNullableFilter<"Jobs"> | string | null
    createdAt?: DateTimeFilter<"Jobs"> | Date | string
    updatedAt?: DateTimeFilter<"Jobs"> | Date | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    jobTitles?: XOR<JobTitlesScalarRelationFilter, JobTitlesWhereInput>
  }

  export type JobsOrderByWithRelationInput = {
    projectId?: SortOrder
    titleId?: SortOrder
    availability?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    compensation?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectsOrderByWithRelationInput
    jobTitles?: JobTitlesOrderByWithRelationInput
    _relevance?: JobsOrderByRelevanceInput
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    projectId_titleId?: JobsProjectIdTitleIdCompoundUniqueInput
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    projectId?: IntFilter<"Jobs"> | number
    titleId?: IntFilter<"Jobs"> | number
    availability?: EnumJobsAvailabilityFilter<"Jobs"> | $Enums.JobsAvailability
    duration?: EnumJobsDurationFilter<"Jobs"> | $Enums.JobsDuration
    location?: EnumJobsLocationFilter<"Jobs"> | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFilter<"Jobs"> | $Enums.JobsCompensation
    description?: StringNullableFilter<"Jobs"> | string | null
    createdAt?: DateTimeFilter<"Jobs"> | Date | string
    updatedAt?: DateTimeFilter<"Jobs"> | Date | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    jobTitles?: XOR<JobTitlesScalarRelationFilter, JobTitlesWhereInput>
  }, "projectId_titleId">

  export type JobsOrderByWithAggregationInput = {
    projectId?: SortOrder
    titleId?: SortOrder
    availability?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    compensation?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"Jobs"> | number
    titleId?: IntWithAggregatesFilter<"Jobs"> | number
    availability?: EnumJobsAvailabilityWithAggregatesFilter<"Jobs"> | $Enums.JobsAvailability
    duration?: EnumJobsDurationWithAggregatesFilter<"Jobs"> | $Enums.JobsDuration
    location?: EnumJobsLocationWithAggregatesFilter<"Jobs"> | $Enums.JobsLocation
    compensation?: EnumJobsCompensationWithAggregatesFilter<"Jobs"> | $Enums.JobsCompensation
    description?: StringNullableWithAggregatesFilter<"Jobs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Jobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Jobs"> | Date | string
  }

  export type MajorsWhereInput = {
    AND?: MajorsWhereInput | MajorsWhereInput[]
    OR?: MajorsWhereInput[]
    NOT?: MajorsWhereInput | MajorsWhereInput[]
    majorId?: IntFilter<"Majors"> | number
    label?: StringFilter<"Majors"> | string
    users?: UsersListRelationFilter
  }

  export type MajorsOrderByWithRelationInput = {
    majorId?: SortOrder
    label?: SortOrder
    users?: UsersOrderByRelationAggregateInput
    _relevance?: MajorsOrderByRelevanceInput
  }

  export type MajorsWhereUniqueInput = Prisma.AtLeast<{
    majorId?: number
    AND?: MajorsWhereInput | MajorsWhereInput[]
    OR?: MajorsWhereInput[]
    NOT?: MajorsWhereInput | MajorsWhereInput[]
    label?: StringFilter<"Majors"> | string
    users?: UsersListRelationFilter
  }, "majorId">

  export type MajorsOrderByWithAggregationInput = {
    majorId?: SortOrder
    label?: SortOrder
    _count?: MajorsCountOrderByAggregateInput
    _avg?: MajorsAvgOrderByAggregateInput
    _max?: MajorsMaxOrderByAggregateInput
    _min?: MajorsMinOrderByAggregateInput
    _sum?: MajorsSumOrderByAggregateInput
  }

  export type MajorsScalarWhereWithAggregatesInput = {
    AND?: MajorsScalarWhereWithAggregatesInput | MajorsScalarWhereWithAggregatesInput[]
    OR?: MajorsScalarWhereWithAggregatesInput[]
    NOT?: MajorsScalarWhereWithAggregatesInput | MajorsScalarWhereWithAggregatesInput[]
    majorId?: IntWithAggregatesFilter<"Majors"> | number
    label?: StringWithAggregatesFilter<"Majors"> | string
  }

  export type MembersWhereInput = {
    AND?: MembersWhereInput | MembersWhereInput[]
    OR?: MembersWhereInput[]
    NOT?: MembersWhereInput | MembersWhereInput[]
    projectId?: IntFilter<"Members"> | number
    userId?: IntFilter<"Members"> | number
    titleId?: IntFilter<"Members"> | number
    profileVisibility?: EnumMembersProfileVisibilityFilter<"Members"> | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFilter<"Members"> | Date | string
    jobTitles?: XOR<JobTitlesScalarRelationFilter, JobTitlesWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type MembersOrderByWithRelationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    jobTitles?: JobTitlesOrderByWithRelationInput
    projects?: ProjectsOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type MembersWhereUniqueInput = Prisma.AtLeast<{
    projectId_userId?: MembersProjectIdUserIdCompoundUniqueInput
    AND?: MembersWhereInput | MembersWhereInput[]
    OR?: MembersWhereInput[]
    NOT?: MembersWhereInput | MembersWhereInput[]
    projectId?: IntFilter<"Members"> | number
    userId?: IntFilter<"Members"> | number
    titleId?: IntFilter<"Members"> | number
    profileVisibility?: EnumMembersProfileVisibilityFilter<"Members"> | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFilter<"Members"> | Date | string
    jobTitles?: XOR<JobTitlesScalarRelationFilter, JobTitlesWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "projectId_userId">

  export type MembersOrderByWithAggregationInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    _count?: MembersCountOrderByAggregateInput
    _avg?: MembersAvgOrderByAggregateInput
    _max?: MembersMaxOrderByAggregateInput
    _min?: MembersMinOrderByAggregateInput
    _sum?: MembersSumOrderByAggregateInput
  }

  export type MembersScalarWhereWithAggregatesInput = {
    AND?: MembersScalarWhereWithAggregatesInput | MembersScalarWhereWithAggregatesInput[]
    OR?: MembersScalarWhereWithAggregatesInput[]
    NOT?: MembersScalarWhereWithAggregatesInput | MembersScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"Members"> | number
    userId?: IntWithAggregatesFilter<"Members"> | number
    titleId?: IntWithAggregatesFilter<"Members"> | number
    profileVisibility?: EnumMembersProfileVisibilityWithAggregatesFilter<"Members"> | $Enums.MembersProfileVisibility
    createdAt?: DateTimeWithAggregatesFilter<"Members"> | Date | string
  }

  export type ProjectFollowingsWhereInput = {
    AND?: ProjectFollowingsWhereInput | ProjectFollowingsWhereInput[]
    OR?: ProjectFollowingsWhereInput[]
    NOT?: ProjectFollowingsWhereInput | ProjectFollowingsWhereInput[]
    userId?: IntFilter<"ProjectFollowings"> | number
    projectId?: IntFilter<"ProjectFollowings"> | number
    followedAt?: DateTimeFilter<"ProjectFollowings"> | Date | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ProjectFollowingsOrderByWithRelationInput = {
    userId?: SortOrder
    projectId?: SortOrder
    followedAt?: SortOrder
    projects?: ProjectsOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type ProjectFollowingsWhereUniqueInput = Prisma.AtLeast<{
    userId_projectId?: ProjectFollowingsUserIdProjectIdCompoundUniqueInput
    AND?: ProjectFollowingsWhereInput | ProjectFollowingsWhereInput[]
    OR?: ProjectFollowingsWhereInput[]
    NOT?: ProjectFollowingsWhereInput | ProjectFollowingsWhereInput[]
    userId?: IntFilter<"ProjectFollowings"> | number
    projectId?: IntFilter<"ProjectFollowings"> | number
    followedAt?: DateTimeFilter<"ProjectFollowings"> | Date | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_projectId">

  export type ProjectFollowingsOrderByWithAggregationInput = {
    userId?: SortOrder
    projectId?: SortOrder
    followedAt?: SortOrder
    _count?: ProjectFollowingsCountOrderByAggregateInput
    _avg?: ProjectFollowingsAvgOrderByAggregateInput
    _max?: ProjectFollowingsMaxOrderByAggregateInput
    _min?: ProjectFollowingsMinOrderByAggregateInput
    _sum?: ProjectFollowingsSumOrderByAggregateInput
  }

  export type ProjectFollowingsScalarWhereWithAggregatesInput = {
    AND?: ProjectFollowingsScalarWhereWithAggregatesInput | ProjectFollowingsScalarWhereWithAggregatesInput[]
    OR?: ProjectFollowingsScalarWhereWithAggregatesInput[]
    NOT?: ProjectFollowingsScalarWhereWithAggregatesInput | ProjectFollowingsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"ProjectFollowings"> | number
    projectId?: IntWithAggregatesFilter<"ProjectFollowings"> | number
    followedAt?: DateTimeWithAggregatesFilter<"ProjectFollowings"> | Date | string
  }

  export type ProjectGenresWhereInput = {
    AND?: ProjectGenresWhereInput | ProjectGenresWhereInput[]
    OR?: ProjectGenresWhereInput[]
    NOT?: ProjectGenresWhereInput | ProjectGenresWhereInput[]
    projectId?: IntFilter<"ProjectGenres"> | number
    typeId?: IntFilter<"ProjectGenres"> | number
    genres?: XOR<GenresScalarRelationFilter, GenresWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
  }

  export type ProjectGenresOrderByWithRelationInput = {
    projectId?: SortOrder
    typeId?: SortOrder
    genres?: GenresOrderByWithRelationInput
    projects?: ProjectsOrderByWithRelationInput
  }

  export type ProjectGenresWhereUniqueInput = Prisma.AtLeast<{
    projectId_typeId?: ProjectGenresProjectIdTypeIdCompoundUniqueInput
    AND?: ProjectGenresWhereInput | ProjectGenresWhereInput[]
    OR?: ProjectGenresWhereInput[]
    NOT?: ProjectGenresWhereInput | ProjectGenresWhereInput[]
    projectId?: IntFilter<"ProjectGenres"> | number
    typeId?: IntFilter<"ProjectGenres"> | number
    genres?: XOR<GenresScalarRelationFilter, GenresWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
  }, "projectId_typeId">

  export type ProjectGenresOrderByWithAggregationInput = {
    projectId?: SortOrder
    typeId?: SortOrder
    _count?: ProjectGenresCountOrderByAggregateInput
    _avg?: ProjectGenresAvgOrderByAggregateInput
    _max?: ProjectGenresMaxOrderByAggregateInput
    _min?: ProjectGenresMinOrderByAggregateInput
    _sum?: ProjectGenresSumOrderByAggregateInput
  }

  export type ProjectGenresScalarWhereWithAggregatesInput = {
    AND?: ProjectGenresScalarWhereWithAggregatesInput | ProjectGenresScalarWhereWithAggregatesInput[]
    OR?: ProjectGenresScalarWhereWithAggregatesInput[]
    NOT?: ProjectGenresScalarWhereWithAggregatesInput | ProjectGenresScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"ProjectGenres"> | number
    typeId?: IntWithAggregatesFilter<"ProjectGenres"> | number
  }

  export type ProjectImagesWhereInput = {
    AND?: ProjectImagesWhereInput | ProjectImagesWhereInput[]
    OR?: ProjectImagesWhereInput[]
    NOT?: ProjectImagesWhereInput | ProjectImagesWhereInput[]
    imageId?: IntFilter<"ProjectImages"> | number
    image?: StringFilter<"ProjectImages"> | string
    position?: IntFilter<"ProjectImages"> | number
    projectId?: IntFilter<"ProjectImages"> | number
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
  }

  export type ProjectImagesOrderByWithRelationInput = {
    imageId?: SortOrder
    image?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
    projects?: ProjectsOrderByWithRelationInput
    _relevance?: ProjectImagesOrderByRelevanceInput
  }

  export type ProjectImagesWhereUniqueInput = Prisma.AtLeast<{
    imageId?: number
    AND?: ProjectImagesWhereInput | ProjectImagesWhereInput[]
    OR?: ProjectImagesWhereInput[]
    NOT?: ProjectImagesWhereInput | ProjectImagesWhereInput[]
    image?: StringFilter<"ProjectImages"> | string
    position?: IntFilter<"ProjectImages"> | number
    projectId?: IntFilter<"ProjectImages"> | number
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
  }, "imageId">

  export type ProjectImagesOrderByWithAggregationInput = {
    imageId?: SortOrder
    image?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
    _count?: ProjectImagesCountOrderByAggregateInput
    _avg?: ProjectImagesAvgOrderByAggregateInput
    _max?: ProjectImagesMaxOrderByAggregateInput
    _min?: ProjectImagesMinOrderByAggregateInput
    _sum?: ProjectImagesSumOrderByAggregateInput
  }

  export type ProjectImagesScalarWhereWithAggregatesInput = {
    AND?: ProjectImagesScalarWhereWithAggregatesInput | ProjectImagesScalarWhereWithAggregatesInput[]
    OR?: ProjectImagesScalarWhereWithAggregatesInput[]
    NOT?: ProjectImagesScalarWhereWithAggregatesInput | ProjectImagesScalarWhereWithAggregatesInput[]
    imageId?: IntWithAggregatesFilter<"ProjectImages"> | number
    image?: StringWithAggregatesFilter<"ProjectImages"> | string
    position?: IntWithAggregatesFilter<"ProjectImages"> | number
    projectId?: IntWithAggregatesFilter<"ProjectImages"> | number
  }

  export type ProjectSocialsWhereInput = {
    AND?: ProjectSocialsWhereInput | ProjectSocialsWhereInput[]
    OR?: ProjectSocialsWhereInput[]
    NOT?: ProjectSocialsWhereInput | ProjectSocialsWhereInput[]
    projectId?: IntFilter<"ProjectSocials"> | number
    websiteId?: IntFilter<"ProjectSocials"> | number
    url?: StringFilter<"ProjectSocials"> | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    socials?: XOR<SocialsScalarRelationFilter, SocialsWhereInput>
  }

  export type ProjectSocialsOrderByWithRelationInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
    projects?: ProjectsOrderByWithRelationInput
    socials?: SocialsOrderByWithRelationInput
    _relevance?: ProjectSocialsOrderByRelevanceInput
  }

  export type ProjectSocialsWhereUniqueInput = Prisma.AtLeast<{
    projectId_websiteId?: ProjectSocialsProjectIdWebsiteIdCompoundUniqueInput
    AND?: ProjectSocialsWhereInput | ProjectSocialsWhereInput[]
    OR?: ProjectSocialsWhereInput[]
    NOT?: ProjectSocialsWhereInput | ProjectSocialsWhereInput[]
    projectId?: IntFilter<"ProjectSocials"> | number
    websiteId?: IntFilter<"ProjectSocials"> | number
    url?: StringFilter<"ProjectSocials"> | string
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    socials?: XOR<SocialsScalarRelationFilter, SocialsWhereInput>
  }, "projectId_websiteId">

  export type ProjectSocialsOrderByWithAggregationInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
    _count?: ProjectSocialsCountOrderByAggregateInput
    _avg?: ProjectSocialsAvgOrderByAggregateInput
    _max?: ProjectSocialsMaxOrderByAggregateInput
    _min?: ProjectSocialsMinOrderByAggregateInput
    _sum?: ProjectSocialsSumOrderByAggregateInput
  }

  export type ProjectSocialsScalarWhereWithAggregatesInput = {
    AND?: ProjectSocialsScalarWhereWithAggregatesInput | ProjectSocialsScalarWhereWithAggregatesInput[]
    OR?: ProjectSocialsScalarWhereWithAggregatesInput[]
    NOT?: ProjectSocialsScalarWhereWithAggregatesInput | ProjectSocialsScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"ProjectSocials"> | number
    websiteId?: IntWithAggregatesFilter<"ProjectSocials"> | number
    url?: StringWithAggregatesFilter<"ProjectSocials"> | string
  }

  export type ProjectTagsWhereInput = {
    AND?: ProjectTagsWhereInput | ProjectTagsWhereInput[]
    OR?: ProjectTagsWhereInput[]
    NOT?: ProjectTagsWhereInput | ProjectTagsWhereInput[]
    projectId?: IntFilter<"ProjectTags"> | number
    tagId?: IntFilter<"ProjectTags"> | number
    position?: IntFilter<"ProjectTags"> | number
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    tags?: XOR<TagsScalarRelationFilter, TagsWhereInput>
  }

  export type ProjectTagsOrderByWithRelationInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    projects?: ProjectsOrderByWithRelationInput
    tags?: TagsOrderByWithRelationInput
  }

  export type ProjectTagsWhereUniqueInput = Prisma.AtLeast<{
    projectId_tagId?: ProjectTagsProjectIdTagIdCompoundUniqueInput
    AND?: ProjectTagsWhereInput | ProjectTagsWhereInput[]
    OR?: ProjectTagsWhereInput[]
    NOT?: ProjectTagsWhereInput | ProjectTagsWhereInput[]
    projectId?: IntFilter<"ProjectTags"> | number
    tagId?: IntFilter<"ProjectTags"> | number
    position?: IntFilter<"ProjectTags"> | number
    projects?: XOR<ProjectsScalarRelationFilter, ProjectsWhereInput>
    tags?: XOR<TagsScalarRelationFilter, TagsWhereInput>
  }, "projectId_tagId">

  export type ProjectTagsOrderByWithAggregationInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
    _count?: ProjectTagsCountOrderByAggregateInput
    _avg?: ProjectTagsAvgOrderByAggregateInput
    _max?: ProjectTagsMaxOrderByAggregateInput
    _min?: ProjectTagsMinOrderByAggregateInput
    _sum?: ProjectTagsSumOrderByAggregateInput
  }

  export type ProjectTagsScalarWhereWithAggregatesInput = {
    AND?: ProjectTagsScalarWhereWithAggregatesInput | ProjectTagsScalarWhereWithAggregatesInput[]
    OR?: ProjectTagsScalarWhereWithAggregatesInput[]
    NOT?: ProjectTagsScalarWhereWithAggregatesInput | ProjectTagsScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"ProjectTags"> | number
    tagId?: IntWithAggregatesFilter<"ProjectTags"> | number
    position?: IntWithAggregatesFilter<"ProjectTags"> | number
  }

  export type ProjectsWhereInput = {
    AND?: ProjectsWhereInput | ProjectsWhereInput[]
    OR?: ProjectsWhereInput[]
    NOT?: ProjectsWhereInput | ProjectsWhereInput[]
    projectId?: IntFilter<"Projects"> | number
    title?: StringFilter<"Projects"> | string
    hook?: StringFilter<"Projects"> | string
    description?: StringFilter<"Projects"> | string
    thumbnail?: StringNullableFilter<"Projects"> | string | null
    purpose?: EnumProjectsPurposeNullableFilter<"Projects"> | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFilter<"Projects"> | $Enums.ProjectsStatus
    audience?: StringNullableFilter<"Projects"> | string | null
    userId?: IntNullableFilter<"Projects"> | number | null
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
    jobs?: JobsListRelationFilter
    members?: MembersListRelationFilter
    projectFollowings?: ProjectFollowingsListRelationFilter
    projectGenres?: ProjectGenresListRelationFilter
    projectImages?: ProjectImagesListRelationFilter
    projectSocials?: ProjectSocialsListRelationFilter
    projectTags?: ProjectTagsListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }

  export type ProjectsOrderByWithRelationInput = {
    projectId?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    audience?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobs?: JobsOrderByRelationAggregateInput
    members?: MembersOrderByRelationAggregateInput
    projectFollowings?: ProjectFollowingsOrderByRelationAggregateInput
    projectGenres?: ProjectGenresOrderByRelationAggregateInput
    projectImages?: ProjectImagesOrderByRelationAggregateInput
    projectSocials?: ProjectSocialsOrderByRelationAggregateInput
    projectTags?: ProjectTagsOrderByRelationAggregateInput
    users?: UsersOrderByWithRelationInput
    _relevance?: ProjectsOrderByRelevanceInput
  }

  export type ProjectsWhereUniqueInput = Prisma.AtLeast<{
    projectId?: number
    AND?: ProjectsWhereInput | ProjectsWhereInput[]
    OR?: ProjectsWhereInput[]
    NOT?: ProjectsWhereInput | ProjectsWhereInput[]
    title?: StringFilter<"Projects"> | string
    hook?: StringFilter<"Projects"> | string
    description?: StringFilter<"Projects"> | string
    thumbnail?: StringNullableFilter<"Projects"> | string | null
    purpose?: EnumProjectsPurposeNullableFilter<"Projects"> | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFilter<"Projects"> | $Enums.ProjectsStatus
    audience?: StringNullableFilter<"Projects"> | string | null
    userId?: IntNullableFilter<"Projects"> | number | null
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
    jobs?: JobsListRelationFilter
    members?: MembersListRelationFilter
    projectFollowings?: ProjectFollowingsListRelationFilter
    projectGenres?: ProjectGenresListRelationFilter
    projectImages?: ProjectImagesListRelationFilter
    projectSocials?: ProjectSocialsListRelationFilter
    projectTags?: ProjectTagsListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }, "projectId">

  export type ProjectsOrderByWithAggregationInput = {
    projectId?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    audience?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectsCountOrderByAggregateInput
    _avg?: ProjectsAvgOrderByAggregateInput
    _max?: ProjectsMaxOrderByAggregateInput
    _min?: ProjectsMinOrderByAggregateInput
    _sum?: ProjectsSumOrderByAggregateInput
  }

  export type ProjectsScalarWhereWithAggregatesInput = {
    AND?: ProjectsScalarWhereWithAggregatesInput | ProjectsScalarWhereWithAggregatesInput[]
    OR?: ProjectsScalarWhereWithAggregatesInput[]
    NOT?: ProjectsScalarWhereWithAggregatesInput | ProjectsScalarWhereWithAggregatesInput[]
    projectId?: IntWithAggregatesFilter<"Projects"> | number
    title?: StringWithAggregatesFilter<"Projects"> | string
    hook?: StringWithAggregatesFilter<"Projects"> | string
    description?: StringWithAggregatesFilter<"Projects"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Projects"> | string | null
    purpose?: EnumProjectsPurposeNullableWithAggregatesFilter<"Projects"> | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusWithAggregatesFilter<"Projects"> | $Enums.ProjectsStatus
    audience?: StringNullableWithAggregatesFilter<"Projects"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Projects"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Projects"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Projects"> | Date | string
  }

  export type SocialsWhereInput = {
    AND?: SocialsWhereInput | SocialsWhereInput[]
    OR?: SocialsWhereInput[]
    NOT?: SocialsWhereInput | SocialsWhereInput[]
    websiteId?: IntFilter<"Socials"> | number
    label?: StringFilter<"Socials"> | string
    projectSocials?: ProjectSocialsListRelationFilter
    userSocials?: UserSocialsListRelationFilter
  }

  export type SocialsOrderByWithRelationInput = {
    websiteId?: SortOrder
    label?: SortOrder
    projectSocials?: ProjectSocialsOrderByRelationAggregateInput
    userSocials?: UserSocialsOrderByRelationAggregateInput
    _relevance?: SocialsOrderByRelevanceInput
  }

  export type SocialsWhereUniqueInput = Prisma.AtLeast<{
    websiteId?: number
    AND?: SocialsWhereInput | SocialsWhereInput[]
    OR?: SocialsWhereInput[]
    NOT?: SocialsWhereInput | SocialsWhereInput[]
    label?: StringFilter<"Socials"> | string
    projectSocials?: ProjectSocialsListRelationFilter
    userSocials?: UserSocialsListRelationFilter
  }, "websiteId">

  export type SocialsOrderByWithAggregationInput = {
    websiteId?: SortOrder
    label?: SortOrder
    _count?: SocialsCountOrderByAggregateInput
    _avg?: SocialsAvgOrderByAggregateInput
    _max?: SocialsMaxOrderByAggregateInput
    _min?: SocialsMinOrderByAggregateInput
    _sum?: SocialsSumOrderByAggregateInput
  }

  export type SocialsScalarWhereWithAggregatesInput = {
    AND?: SocialsScalarWhereWithAggregatesInput | SocialsScalarWhereWithAggregatesInput[]
    OR?: SocialsScalarWhereWithAggregatesInput[]
    NOT?: SocialsScalarWhereWithAggregatesInput | SocialsScalarWhereWithAggregatesInput[]
    websiteId?: IntWithAggregatesFilter<"Socials"> | number
    label?: StringWithAggregatesFilter<"Socials"> | string
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    tagId?: IntFilter<"Tags"> | number
    label?: StringFilter<"Tags"> | string
    type?: StringFilter<"Tags"> | string
    projectTags?: ProjectTagsListRelationFilter
  }

  export type TagsOrderByWithRelationInput = {
    tagId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    projectTags?: ProjectTagsOrderByRelationAggregateInput
    _relevance?: TagsOrderByRelevanceInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    tagId?: number
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    label?: StringFilter<"Tags"> | string
    type?: StringFilter<"Tags"> | string
    projectTags?: ProjectTagsListRelationFilter
  }, "tagId">

  export type TagsOrderByWithAggregationInput = {
    tagId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _avg?: TagsAvgOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
    _sum?: TagsSumOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    tagId?: IntWithAggregatesFilter<"Tags"> | number
    label?: StringWithAggregatesFilter<"Tags"> | string
    type?: StringWithAggregatesFilter<"Tags"> | string
  }

  export type UserFollowingsWhereInput = {
    AND?: UserFollowingsWhereInput | UserFollowingsWhereInput[]
    OR?: UserFollowingsWhereInput[]
    NOT?: UserFollowingsWhereInput | UserFollowingsWhereInput[]
    userId?: IntFilter<"UserFollowings"> | number
    followingId?: IntFilter<"UserFollowings"> | number
    followedAt?: DateTimeFilter<"UserFollowings"> | Date | string
    usersUserFollowingsFollowingIdTousers?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    usersUserFollowingsUserIdTousers?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UserFollowingsOrderByWithRelationInput = {
    userId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
    usersUserFollowingsFollowingIdTousers?: UsersOrderByWithRelationInput
    usersUserFollowingsUserIdTousers?: UsersOrderByWithRelationInput
  }

  export type UserFollowingsWhereUniqueInput = Prisma.AtLeast<{
    userId_followingId?: UserFollowingsUserIdFollowingIdCompoundUniqueInput
    AND?: UserFollowingsWhereInput | UserFollowingsWhereInput[]
    OR?: UserFollowingsWhereInput[]
    NOT?: UserFollowingsWhereInput | UserFollowingsWhereInput[]
    userId?: IntFilter<"UserFollowings"> | number
    followingId?: IntFilter<"UserFollowings"> | number
    followedAt?: DateTimeFilter<"UserFollowings"> | Date | string
    usersUserFollowingsFollowingIdTousers?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    usersUserFollowingsUserIdTousers?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_followingId">

  export type UserFollowingsOrderByWithAggregationInput = {
    userId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
    _count?: UserFollowingsCountOrderByAggregateInput
    _avg?: UserFollowingsAvgOrderByAggregateInput
    _max?: UserFollowingsMaxOrderByAggregateInput
    _min?: UserFollowingsMinOrderByAggregateInput
    _sum?: UserFollowingsSumOrderByAggregateInput
  }

  export type UserFollowingsScalarWhereWithAggregatesInput = {
    AND?: UserFollowingsScalarWhereWithAggregatesInput | UserFollowingsScalarWhereWithAggregatesInput[]
    OR?: UserFollowingsScalarWhereWithAggregatesInput[]
    NOT?: UserFollowingsScalarWhereWithAggregatesInput | UserFollowingsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserFollowings"> | number
    followingId?: IntWithAggregatesFilter<"UserFollowings"> | number
    followedAt?: DateTimeWithAggregatesFilter<"UserFollowings"> | Date | string
  }

  export type UserSkillsWhereInput = {
    AND?: UserSkillsWhereInput | UserSkillsWhereInput[]
    OR?: UserSkillsWhereInput[]
    NOT?: UserSkillsWhereInput | UserSkillsWhereInput[]
    userId?: IntFilter<"UserSkills"> | number
    skillId?: IntFilter<"UserSkills"> | number
    position?: IntFilter<"UserSkills"> | number
    skills?: XOR<SkillsScalarRelationFilter, SkillsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UserSkillsOrderByWithRelationInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
    skills?: SkillsOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type UserSkillsWhereUniqueInput = Prisma.AtLeast<{
    userId_skillId?: UserSkillsUserIdSkillIdCompoundUniqueInput
    AND?: UserSkillsWhereInput | UserSkillsWhereInput[]
    OR?: UserSkillsWhereInput[]
    NOT?: UserSkillsWhereInput | UserSkillsWhereInput[]
    userId?: IntFilter<"UserSkills"> | number
    skillId?: IntFilter<"UserSkills"> | number
    position?: IntFilter<"UserSkills"> | number
    skills?: XOR<SkillsScalarRelationFilter, SkillsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_skillId">

  export type UserSkillsOrderByWithAggregationInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
    _count?: UserSkillsCountOrderByAggregateInput
    _avg?: UserSkillsAvgOrderByAggregateInput
    _max?: UserSkillsMaxOrderByAggregateInput
    _min?: UserSkillsMinOrderByAggregateInput
    _sum?: UserSkillsSumOrderByAggregateInput
  }

  export type UserSkillsScalarWhereWithAggregatesInput = {
    AND?: UserSkillsScalarWhereWithAggregatesInput | UserSkillsScalarWhereWithAggregatesInput[]
    OR?: UserSkillsScalarWhereWithAggregatesInput[]
    NOT?: UserSkillsScalarWhereWithAggregatesInput | UserSkillsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserSkills"> | number
    skillId?: IntWithAggregatesFilter<"UserSkills"> | number
    position?: IntWithAggregatesFilter<"UserSkills"> | number
  }

  export type UserSocialsWhereInput = {
    AND?: UserSocialsWhereInput | UserSocialsWhereInput[]
    OR?: UserSocialsWhereInput[]
    NOT?: UserSocialsWhereInput | UserSocialsWhereInput[]
    userId?: IntFilter<"UserSocials"> | number
    websiteId?: IntFilter<"UserSocials"> | number
    url?: StringFilter<"UserSocials"> | string
    socials?: XOR<SocialsScalarRelationFilter, SocialsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UserSocialsOrderByWithRelationInput = {
    userId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
    socials?: SocialsOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
    _relevance?: UserSocialsOrderByRelevanceInput
  }

  export type UserSocialsWhereUniqueInput = Prisma.AtLeast<{
    userId_websiteId?: UserSocialsUserIdWebsiteIdCompoundUniqueInput
    AND?: UserSocialsWhereInput | UserSocialsWhereInput[]
    OR?: UserSocialsWhereInput[]
    NOT?: UserSocialsWhereInput | UserSocialsWhereInput[]
    userId?: IntFilter<"UserSocials"> | number
    websiteId?: IntFilter<"UserSocials"> | number
    url?: StringFilter<"UserSocials"> | string
    socials?: XOR<SocialsScalarRelationFilter, SocialsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_websiteId">

  export type UserSocialsOrderByWithAggregationInput = {
    userId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
    _count?: UserSocialsCountOrderByAggregateInput
    _avg?: UserSocialsAvgOrderByAggregateInput
    _max?: UserSocialsMaxOrderByAggregateInput
    _min?: UserSocialsMinOrderByAggregateInput
    _sum?: UserSocialsSumOrderByAggregateInput
  }

  export type UserSocialsScalarWhereWithAggregatesInput = {
    AND?: UserSocialsScalarWhereWithAggregatesInput | UserSocialsScalarWhereWithAggregatesInput[]
    OR?: UserSocialsScalarWhereWithAggregatesInput[]
    NOT?: UserSocialsScalarWhereWithAggregatesInput | UserSocialsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserSocials"> | number
    websiteId?: IntWithAggregatesFilter<"UserSocials"> | number
    url?: StringWithAggregatesFilter<"UserSocials"> | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    userId?: IntFilter<"Users"> | number
    username?: StringFilter<"Users"> | string
    ritEmail?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    profileImage?: StringNullableFilter<"Users"> | string | null
    headline?: StringNullableFilter<"Users"> | string | null
    pronouns?: StringNullableFilter<"Users"> | string | null
    jobTitleId?: IntNullableFilter<"Users"> | number | null
    majorId?: IntNullableFilter<"Users"> | number | null
    academicYear?: EnumUsersAcademicYearNullableFilter<"Users"> | $Enums.UsersAcademicYear | null
    location?: StringNullableFilter<"Users"> | string | null
    funFact?: StringNullableFilter<"Users"> | string | null
    bio?: StringNullableFilter<"Users"> | string | null
    visibility?: IntFilter<"Users"> | number
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    phoneNumber?: IntNullableFilter<"Users"> | number | null
    universityId?: StringNullableFilter<"Users"> | string | null
    members?: MembersListRelationFilter
    projectFollowings?: ProjectFollowingsListRelationFilter
    projects?: ProjectsListRelationFilter
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsListRelationFilter
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsListRelationFilter
    userSkills?: UserSkillsListRelationFilter
    userSocials?: UserSocialsListRelationFilter
    jobTitles?: XOR<JobTitlesNullableScalarRelationFilter, JobTitlesWhereInput> | null
    majors?: XOR<MajorsNullableScalarRelationFilter, MajorsWhereInput> | null
  }

  export type UsersOrderByWithRelationInput = {
    userId?: SortOrder
    username?: SortOrder
    ritEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    pronouns?: SortOrderInput | SortOrder
    jobTitleId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    academicYear?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    funFact?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    universityId?: SortOrderInput | SortOrder
    members?: MembersOrderByRelationAggregateInput
    projectFollowings?: ProjectFollowingsOrderByRelationAggregateInput
    projects?: ProjectsOrderByRelationAggregateInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsOrderByRelationAggregateInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsOrderByRelationAggregateInput
    userSkills?: UserSkillsOrderByRelationAggregateInput
    userSocials?: UserSocialsOrderByRelationAggregateInput
    jobTitles?: JobTitlesOrderByWithRelationInput
    majors?: MajorsOrderByWithRelationInput
    _relevance?: UsersOrderByRelevanceInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    universityId?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    username?: StringFilter<"Users"> | string
    ritEmail?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    profileImage?: StringNullableFilter<"Users"> | string | null
    headline?: StringNullableFilter<"Users"> | string | null
    pronouns?: StringNullableFilter<"Users"> | string | null
    jobTitleId?: IntNullableFilter<"Users"> | number | null
    majorId?: IntNullableFilter<"Users"> | number | null
    academicYear?: EnumUsersAcademicYearNullableFilter<"Users"> | $Enums.UsersAcademicYear | null
    location?: StringNullableFilter<"Users"> | string | null
    funFact?: StringNullableFilter<"Users"> | string | null
    bio?: StringNullableFilter<"Users"> | string | null
    visibility?: IntFilter<"Users"> | number
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    phoneNumber?: IntNullableFilter<"Users"> | number | null
    members?: MembersListRelationFilter
    projectFollowings?: ProjectFollowingsListRelationFilter
    projects?: ProjectsListRelationFilter
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsListRelationFilter
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsListRelationFilter
    userSkills?: UserSkillsListRelationFilter
    userSocials?: UserSocialsListRelationFilter
    jobTitles?: XOR<JobTitlesNullableScalarRelationFilter, JobTitlesWhereInput> | null
    majors?: XOR<MajorsNullableScalarRelationFilter, MajorsWhereInput> | null
  }, "userId" | "universityId">

  export type UsersOrderByWithAggregationInput = {
    userId?: SortOrder
    username?: SortOrder
    ritEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    pronouns?: SortOrderInput | SortOrder
    jobTitleId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    academicYear?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    funFact?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    universityId?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Users"> | number
    username?: StringWithAggregatesFilter<"Users"> | string
    ritEmail?: StringWithAggregatesFilter<"Users"> | string
    firstName?: StringWithAggregatesFilter<"Users"> | string
    lastName?: StringWithAggregatesFilter<"Users"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Users"> | string | null
    headline?: StringNullableWithAggregatesFilter<"Users"> | string | null
    pronouns?: StringNullableWithAggregatesFilter<"Users"> | string | null
    jobTitleId?: IntNullableWithAggregatesFilter<"Users"> | number | null
    majorId?: IntNullableWithAggregatesFilter<"Users"> | number | null
    academicYear?: EnumUsersAcademicYearNullableWithAggregatesFilter<"Users"> | $Enums.UsersAcademicYear | null
    location?: StringNullableWithAggregatesFilter<"Users"> | string | null
    funFact?: StringNullableWithAggregatesFilter<"Users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Users"> | string | null
    visibility?: IntWithAggregatesFilter<"Users"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    phoneNumber?: IntNullableWithAggregatesFilter<"Users"> | number | null
    universityId?: StringNullableWithAggregatesFilter<"Users"> | string | null
  }

  export type SkillsWhereInput = {
    AND?: SkillsWhereInput | SkillsWhereInput[]
    OR?: SkillsWhereInput[]
    NOT?: SkillsWhereInput | SkillsWhereInput[]
    skillId?: IntFilter<"Skills"> | number
    label?: StringFilter<"Skills"> | string
    type?: StringFilter<"Skills"> | string
    userSkills?: UserSkillsListRelationFilter
  }

  export type SkillsOrderByWithRelationInput = {
    skillId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    userSkills?: UserSkillsOrderByRelationAggregateInput
    _relevance?: SkillsOrderByRelevanceInput
  }

  export type SkillsWhereUniqueInput = Prisma.AtLeast<{
    skillId?: number
    AND?: SkillsWhereInput | SkillsWhereInput[]
    OR?: SkillsWhereInput[]
    NOT?: SkillsWhereInput | SkillsWhereInput[]
    label?: StringFilter<"Skills"> | string
    type?: StringFilter<"Skills"> | string
    userSkills?: UserSkillsListRelationFilter
  }, "skillId">

  export type SkillsOrderByWithAggregationInput = {
    skillId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    _count?: SkillsCountOrderByAggregateInput
    _avg?: SkillsAvgOrderByAggregateInput
    _max?: SkillsMaxOrderByAggregateInput
    _min?: SkillsMinOrderByAggregateInput
    _sum?: SkillsSumOrderByAggregateInput
  }

  export type SkillsScalarWhereWithAggregatesInput = {
    AND?: SkillsScalarWhereWithAggregatesInput | SkillsScalarWhereWithAggregatesInput[]
    OR?: SkillsScalarWhereWithAggregatesInput[]
    NOT?: SkillsScalarWhereWithAggregatesInput | SkillsScalarWhereWithAggregatesInput[]
    skillId?: IntWithAggregatesFilter<"Skills"> | number
    label?: StringWithAggregatesFilter<"Skills"> | string
    type?: StringWithAggregatesFilter<"Skills"> | string
  }

  export type GenresCreateInput = {
    label: string
    projectGenres?: ProjectGenresCreateNestedManyWithoutGenresInput
  }

  export type GenresUncheckedCreateInput = {
    typeId?: number
    label: string
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutGenresInput
  }

  export type GenresUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    projectGenres?: ProjectGenresUpdateManyWithoutGenresNestedInput
  }

  export type GenresUncheckedUpdateInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutGenresNestedInput
  }

  export type GenresCreateManyInput = {
    typeId?: number
    label: string
  }

  export type GenresUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GenresUncheckedUpdateManyInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type JobTitlesCreateInput = {
    label: string
    jobs?: JobsCreateNestedManyWithoutJobTitlesInput
    members?: MembersCreateNestedManyWithoutJobTitlesInput
    users?: UsersCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesUncheckedCreateInput = {
    titleId?: number
    label: string
    jobs?: JobsUncheckedCreateNestedManyWithoutJobTitlesInput
    members?: MembersUncheckedCreateNestedManyWithoutJobTitlesInput
    users?: UsersUncheckedCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUpdateManyWithoutJobTitlesNestedInput
    members?: MembersUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUpdateManyWithoutJobTitlesNestedInput
  }

  export type JobTitlesUncheckedUpdateInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUncheckedUpdateManyWithoutJobTitlesNestedInput
    members?: MembersUncheckedUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUncheckedUpdateManyWithoutJobTitlesNestedInput
  }

  export type JobTitlesCreateManyInput = {
    titleId?: number
    label: string
  }

  export type JobTitlesUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type JobTitlesUncheckedUpdateManyInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type JobsCreateInput = {
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects: ProjectsCreateNestedOneWithoutJobsInput
    jobTitles: JobTitlesCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateInput = {
    projectId: number
    titleId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobsUpdateInput = {
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectsUpdateOneRequiredWithoutJobsNestedInput
    jobTitles?: JobTitlesUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsCreateManyInput = {
    projectId: number
    titleId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobsUpdateManyMutationInput = {
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MajorsCreateInput = {
    label: string
    users?: UsersCreateNestedManyWithoutMajorsInput
  }

  export type MajorsUncheckedCreateInput = {
    majorId?: number
    label: string
    users?: UsersUncheckedCreateNestedManyWithoutMajorsInput
  }

  export type MajorsUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateManyWithoutMajorsNestedInput
  }

  export type MajorsUncheckedUpdateInput = {
    majorId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    users?: UsersUncheckedUpdateManyWithoutMajorsNestedInput
  }

  export type MajorsCreateManyInput = {
    majorId?: number
    label: string
  }

  export type MajorsUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type MajorsUncheckedUpdateManyInput = {
    majorId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type MembersCreateInput = {
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
    jobTitles: JobTitlesCreateNestedOneWithoutMembersInput
    projects: ProjectsCreateNestedOneWithoutMembersInput
    users: UsersCreateNestedOneWithoutMembersInput
  }

  export type MembersUncheckedCreateInput = {
    projectId: number
    userId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type MembersUpdateInput = {
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobTitles?: JobTitlesUpdateOneRequiredWithoutMembersNestedInput
    projects?: ProjectsUpdateOneRequiredWithoutMembersNestedInput
    users?: UsersUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MembersUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersCreateManyInput = {
    projectId: number
    userId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type MembersUpdateManyMutationInput = {
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsCreateInput = {
    followedAt?: Date | string
    projects: ProjectsCreateNestedOneWithoutProjectFollowingsInput
    users: UsersCreateNestedOneWithoutProjectFollowingsInput
  }

  export type ProjectFollowingsUncheckedCreateInput = {
    userId: number
    projectId: number
    followedAt?: Date | string
  }

  export type ProjectFollowingsUpdateInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectsUpdateOneRequiredWithoutProjectFollowingsNestedInput
    users?: UsersUpdateOneRequiredWithoutProjectFollowingsNestedInput
  }

  export type ProjectFollowingsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsCreateManyInput = {
    userId: number
    projectId: number
    followedAt?: Date | string
  }

  export type ProjectFollowingsUpdateManyMutationInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGenresCreateInput = {
    genres: GenresCreateNestedOneWithoutProjectGenresInput
    projects: ProjectsCreateNestedOneWithoutProjectGenresInput
  }

  export type ProjectGenresUncheckedCreateInput = {
    projectId: number
    typeId: number
  }

  export type ProjectGenresUpdateInput = {
    genres?: GenresUpdateOneRequiredWithoutProjectGenresNestedInput
    projects?: ProjectsUpdateOneRequiredWithoutProjectGenresNestedInput
  }

  export type ProjectGenresUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectGenresCreateManyInput = {
    projectId: number
    typeId: number
  }

  export type ProjectGenresUpdateManyMutationInput = {

  }

  export type ProjectGenresUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesCreateInput = {
    image: string
    position: number
    projects: ProjectsCreateNestedOneWithoutProjectImagesInput
  }

  export type ProjectImagesUncheckedCreateInput = {
    imageId?: number
    image: string
    position: number
    projectId: number
  }

  export type ProjectImagesUpdateInput = {
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    projects?: ProjectsUpdateOneRequiredWithoutProjectImagesNestedInput
  }

  export type ProjectImagesUncheckedUpdateInput = {
    imageId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesCreateManyInput = {
    imageId?: number
    image: string
    position: number
    projectId: number
  }

  export type ProjectImagesUpdateManyMutationInput = {
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesUncheckedUpdateManyInput = {
    imageId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSocialsCreateInput = {
    url: string
    projects: ProjectsCreateNestedOneWithoutProjectSocialsInput
    socials: SocialsCreateNestedOneWithoutProjectSocialsInput
  }

  export type ProjectSocialsUncheckedCreateInput = {
    projectId: number
    websiteId: number
    url: string
  }

  export type ProjectSocialsUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    projects?: ProjectsUpdateOneRequiredWithoutProjectSocialsNestedInput
    socials?: SocialsUpdateOneRequiredWithoutProjectSocialsNestedInput
  }

  export type ProjectSocialsUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSocialsCreateManyInput = {
    projectId: number
    websiteId: number
    url: string
  }

  export type ProjectSocialsUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSocialsUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTagsCreateInput = {
    position: number
    projects: ProjectsCreateNestedOneWithoutProjectTagsInput
    tags: TagsCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagsUncheckedCreateInput = {
    projectId: number
    tagId: number
    position: number
  }

  export type ProjectTagsUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    projects?: ProjectsUpdateOneRequiredWithoutProjectTagsNestedInput
    tags?: TagsUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagsUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagsCreateManyInput = {
    projectId: number
    tagId: number
    position: number
  }

  export type ProjectTagsUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagsUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectsCreateInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectsCreateManyInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUncheckedUpdateManyInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialsCreateInput = {
    label: string
    projectSocials?: ProjectSocialsCreateNestedManyWithoutSocialsInput
    userSocials?: UserSocialsCreateNestedManyWithoutSocialsInput
  }

  export type SocialsUncheckedCreateInput = {
    websiteId?: number
    label: string
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutSocialsInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutSocialsInput
  }

  export type SocialsUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    projectSocials?: ProjectSocialsUpdateManyWithoutSocialsNestedInput
    userSocials?: UserSocialsUpdateManyWithoutSocialsNestedInput
  }

  export type SocialsUncheckedUpdateInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutSocialsNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutSocialsNestedInput
  }

  export type SocialsCreateManyInput = {
    websiteId?: number
    label: string
  }

  export type SocialsUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type SocialsUncheckedUpdateManyInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type TagsCreateInput = {
    label: string
    type: string
    projectTags?: ProjectTagsCreateNestedManyWithoutTagsInput
  }

  export type TagsUncheckedCreateInput = {
    tagId?: number
    label: string
    type: string
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagsUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTags?: ProjectTagsUpdateManyWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagsCreateManyInput = {
    tagId?: number
    label: string
    type: string
  }

  export type TagsUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserFollowingsCreateInput = {
    followedAt?: Date | string
    usersUserFollowingsFollowingIdTousers: UsersCreateNestedOneWithoutUserFollowingsUserFollowingsFollowingIdTousersInput
    usersUserFollowingsUserIdTousers: UsersCreateNestedOneWithoutUserFollowingsUserFollowingsUserIdTousersInput
  }

  export type UserFollowingsUncheckedCreateInput = {
    userId: number
    followingId: number
    followedAt?: Date | string
  }

  export type UserFollowingsUpdateInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersUserFollowingsFollowingIdTousers?: UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsFollowingIdTousersNestedInput
    usersUserFollowingsUserIdTousers?: UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsUserIdTousersNestedInput
  }

  export type UserFollowingsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsCreateManyInput = {
    userId: number
    followingId: number
    followedAt?: Date | string
  }

  export type UserFollowingsUpdateManyMutationInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followingId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsCreateInput = {
    position: number
    skills: SkillsCreateNestedOneWithoutUserSkillsInput
    users: UsersCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillsUncheckedCreateInput = {
    userId: number
    skillId: number
    position: number
  }

  export type UserSkillsUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    skills?: SkillsUpdateOneRequiredWithoutUserSkillsNestedInput
    users?: UsersUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSkillsCreateManyInput = {
    userId: number
    skillId: number
    position: number
  }

  export type UserSkillsUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSkillsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSocialsCreateInput = {
    url: string
    socials: SocialsCreateNestedOneWithoutUserSocialsInput
    users: UsersCreateNestedOneWithoutUserSocialsInput
  }

  export type UserSocialsUncheckedCreateInput = {
    userId: number
    websiteId: number
    url: string
  }

  export type UserSocialsUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    socials?: SocialsUpdateOneRequiredWithoutUserSocialsNestedInput
    users?: UsersUpdateOneRequiredWithoutUserSocialsNestedInput
  }

  export type UserSocialsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialsCreateManyInput = {
    userId: number
    websiteId: number
    url: string
  }

  export type UserSocialsUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
  }

  export type UsersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SkillsCreateInput = {
    label: string
    type: string
    userSkills?: UserSkillsCreateNestedManyWithoutSkillsInput
  }

  export type SkillsUncheckedCreateInput = {
    skillId?: number
    label: string
    type: string
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type SkillsUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    userSkills?: UserSkillsUpdateManyWithoutSkillsNestedInput
  }

  export type SkillsUncheckedUpdateInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    userSkills?: UserSkillsUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type SkillsCreateManyInput = {
    skillId?: number
    label: string
    type: string
  }

  export type SkillsUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsUncheckedUpdateManyInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ProjectGenresListRelationFilter = {
    every?: ProjectGenresWhereInput
    some?: ProjectGenresWhereInput
    none?: ProjectGenresWhereInput
  }

  export type ProjectGenresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenresOrderByRelevanceInput = {
    fields: GenresOrderByRelevanceFieldEnum | GenresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GenresCountOrderByAggregateInput = {
    typeId?: SortOrder
    label?: SortOrder
  }

  export type GenresAvgOrderByAggregateInput = {
    typeId?: SortOrder
  }

  export type GenresMaxOrderByAggregateInput = {
    typeId?: SortOrder
    label?: SortOrder
  }

  export type GenresMinOrderByAggregateInput = {
    typeId?: SortOrder
    label?: SortOrder
  }

  export type GenresSumOrderByAggregateInput = {
    typeId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type JobsListRelationFilter = {
    every?: JobsWhereInput
    some?: JobsWhereInput
    none?: JobsWhereInput
  }

  export type MembersListRelationFilter = {
    every?: MembersWhereInput
    some?: MembersWhereInput
    none?: MembersWhereInput
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobTitlesOrderByRelevanceInput = {
    fields: JobTitlesOrderByRelevanceFieldEnum | JobTitlesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobTitlesCountOrderByAggregateInput = {
    titleId?: SortOrder
    label?: SortOrder
  }

  export type JobTitlesAvgOrderByAggregateInput = {
    titleId?: SortOrder
  }

  export type JobTitlesMaxOrderByAggregateInput = {
    titleId?: SortOrder
    label?: SortOrder
  }

  export type JobTitlesMinOrderByAggregateInput = {
    titleId?: SortOrder
    label?: SortOrder
  }

  export type JobTitlesSumOrderByAggregateInput = {
    titleId?: SortOrder
  }

  export type EnumJobsAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsAvailability | EnumJobsAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.JobsAvailability[]
    notIn?: $Enums.JobsAvailability[]
    not?: NestedEnumJobsAvailabilityFilter<$PrismaModel> | $Enums.JobsAvailability
  }

  export type EnumJobsDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsDuration | EnumJobsDurationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsDuration[]
    notIn?: $Enums.JobsDuration[]
    not?: NestedEnumJobsDurationFilter<$PrismaModel> | $Enums.JobsDuration
  }

  export type EnumJobsLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsLocation | EnumJobsLocationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsLocation[]
    notIn?: $Enums.JobsLocation[]
    not?: NestedEnumJobsLocationFilter<$PrismaModel> | $Enums.JobsLocation
  }

  export type EnumJobsCompensationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsCompensation | EnumJobsCompensationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsCompensation[]
    notIn?: $Enums.JobsCompensation[]
    not?: NestedEnumJobsCompensationFilter<$PrismaModel> | $Enums.JobsCompensation
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectsScalarRelationFilter = {
    is?: ProjectsWhereInput
    isNot?: ProjectsWhereInput
  }

  export type JobTitlesScalarRelationFilter = {
    is?: JobTitlesWhereInput
    isNot?: JobTitlesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JobsOrderByRelevanceInput = {
    fields: JobsOrderByRelevanceFieldEnum | JobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobsProjectIdTitleIdCompoundUniqueInput = {
    projectId: number
    titleId: number
  }

  export type JobsCountOrderByAggregateInput = {
    projectId?: SortOrder
    titleId?: SortOrder
    availability?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    compensation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    projectId?: SortOrder
    titleId?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    projectId?: SortOrder
    titleId?: SortOrder
    availability?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    compensation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    projectId?: SortOrder
    titleId?: SortOrder
    availability?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    compensation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    projectId?: SortOrder
    titleId?: SortOrder
  }

  export type EnumJobsAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsAvailability | EnumJobsAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.JobsAvailability[]
    notIn?: $Enums.JobsAvailability[]
    not?: NestedEnumJobsAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.JobsAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumJobsAvailabilityFilter<$PrismaModel>
  }

  export type EnumJobsDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsDuration | EnumJobsDurationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsDuration[]
    notIn?: $Enums.JobsDuration[]
    not?: NestedEnumJobsDurationWithAggregatesFilter<$PrismaModel> | $Enums.JobsDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsDurationFilter<$PrismaModel>
    _max?: NestedEnumJobsDurationFilter<$PrismaModel>
  }

  export type EnumJobsLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsLocation | EnumJobsLocationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsLocation[]
    notIn?: $Enums.JobsLocation[]
    not?: NestedEnumJobsLocationWithAggregatesFilter<$PrismaModel> | $Enums.JobsLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsLocationFilter<$PrismaModel>
    _max?: NestedEnumJobsLocationFilter<$PrismaModel>
  }

  export type EnumJobsCompensationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsCompensation | EnumJobsCompensationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsCompensation[]
    notIn?: $Enums.JobsCompensation[]
    not?: NestedEnumJobsCompensationWithAggregatesFilter<$PrismaModel> | $Enums.JobsCompensation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsCompensationFilter<$PrismaModel>
    _max?: NestedEnumJobsCompensationFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MajorsOrderByRelevanceInput = {
    fields: MajorsOrderByRelevanceFieldEnum | MajorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MajorsCountOrderByAggregateInput = {
    majorId?: SortOrder
    label?: SortOrder
  }

  export type MajorsAvgOrderByAggregateInput = {
    majorId?: SortOrder
  }

  export type MajorsMaxOrderByAggregateInput = {
    majorId?: SortOrder
    label?: SortOrder
  }

  export type MajorsMinOrderByAggregateInput = {
    majorId?: SortOrder
    label?: SortOrder
  }

  export type MajorsSumOrderByAggregateInput = {
    majorId?: SortOrder
  }

  export type EnumMembersProfileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.MembersProfileVisibility | EnumMembersProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.MembersProfileVisibility[]
    notIn?: $Enums.MembersProfileVisibility[]
    not?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel> | $Enums.MembersProfileVisibility
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type MembersProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: number
  }

  export type MembersCountOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
  }

  export type MembersAvgOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
  }

  export type MembersMaxOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
  }

  export type MembersMinOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
  }

  export type MembersSumOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
    titleId?: SortOrder
  }

  export type EnumMembersProfileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembersProfileVisibility | EnumMembersProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.MembersProfileVisibility[]
    notIn?: $Enums.MembersProfileVisibility[]
    not?: NestedEnumMembersProfileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.MembersProfileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel>
  }

  export type ProjectFollowingsUserIdProjectIdCompoundUniqueInput = {
    userId: number
    projectId: number
  }

  export type ProjectFollowingsCountOrderByAggregateInput = {
    userId?: SortOrder
    projectId?: SortOrder
    followedAt?: SortOrder
  }

  export type ProjectFollowingsAvgOrderByAggregateInput = {
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectFollowingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    projectId?: SortOrder
    followedAt?: SortOrder
  }

  export type ProjectFollowingsMinOrderByAggregateInput = {
    userId?: SortOrder
    projectId?: SortOrder
    followedAt?: SortOrder
  }

  export type ProjectFollowingsSumOrderByAggregateInput = {
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type GenresScalarRelationFilter = {
    is?: GenresWhereInput
    isNot?: GenresWhereInput
  }

  export type ProjectGenresProjectIdTypeIdCompoundUniqueInput = {
    projectId: number
    typeId: number
  }

  export type ProjectGenresCountOrderByAggregateInput = {
    projectId?: SortOrder
    typeId?: SortOrder
  }

  export type ProjectGenresAvgOrderByAggregateInput = {
    projectId?: SortOrder
    typeId?: SortOrder
  }

  export type ProjectGenresMaxOrderByAggregateInput = {
    projectId?: SortOrder
    typeId?: SortOrder
  }

  export type ProjectGenresMinOrderByAggregateInput = {
    projectId?: SortOrder
    typeId?: SortOrder
  }

  export type ProjectGenresSumOrderByAggregateInput = {
    projectId?: SortOrder
    typeId?: SortOrder
  }

  export type ProjectImagesOrderByRelevanceInput = {
    fields: ProjectImagesOrderByRelevanceFieldEnum | ProjectImagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectImagesCountOrderByAggregateInput = {
    imageId?: SortOrder
    image?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectImagesAvgOrderByAggregateInput = {
    imageId?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectImagesMaxOrderByAggregateInput = {
    imageId?: SortOrder
    image?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectImagesMinOrderByAggregateInput = {
    imageId?: SortOrder
    image?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectImagesSumOrderByAggregateInput = {
    imageId?: SortOrder
    position?: SortOrder
    projectId?: SortOrder
  }

  export type SocialsScalarRelationFilter = {
    is?: SocialsWhereInput
    isNot?: SocialsWhereInput
  }

  export type ProjectSocialsOrderByRelevanceInput = {
    fields: ProjectSocialsOrderByRelevanceFieldEnum | ProjectSocialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectSocialsProjectIdWebsiteIdCompoundUniqueInput = {
    projectId: number
    websiteId: number
  }

  export type ProjectSocialsCountOrderByAggregateInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type ProjectSocialsAvgOrderByAggregateInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
  }

  export type ProjectSocialsMaxOrderByAggregateInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type ProjectSocialsMinOrderByAggregateInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type ProjectSocialsSumOrderByAggregateInput = {
    projectId?: SortOrder
    websiteId?: SortOrder
  }

  export type TagsScalarRelationFilter = {
    is?: TagsWhereInput
    isNot?: TagsWhereInput
  }

  export type ProjectTagsProjectIdTagIdCompoundUniqueInput = {
    projectId: number
    tagId: number
  }

  export type ProjectTagsCountOrderByAggregateInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
  }

  export type ProjectTagsAvgOrderByAggregateInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
  }

  export type ProjectTagsMaxOrderByAggregateInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
  }

  export type ProjectTagsMinOrderByAggregateInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
  }

  export type ProjectTagsSumOrderByAggregateInput = {
    projectId?: SortOrder
    tagId?: SortOrder
    position?: SortOrder
  }

  export type EnumProjectsPurposeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsPurpose | EnumProjectsPurposeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectsPurpose[] | null
    notIn?: $Enums.ProjectsPurpose[] | null
    not?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel> | $Enums.ProjectsPurpose | null
  }

  export type EnumProjectsStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsStatus | EnumProjectsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectsStatus[]
    notIn?: $Enums.ProjectsStatus[]
    not?: NestedEnumProjectsStatusFilter<$PrismaModel> | $Enums.ProjectsStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectFollowingsListRelationFilter = {
    every?: ProjectFollowingsWhereInput
    some?: ProjectFollowingsWhereInput
    none?: ProjectFollowingsWhereInput
  }

  export type ProjectImagesListRelationFilter = {
    every?: ProjectImagesWhereInput
    some?: ProjectImagesWhereInput
    none?: ProjectImagesWhereInput
  }

  export type ProjectSocialsListRelationFilter = {
    every?: ProjectSocialsWhereInput
    some?: ProjectSocialsWhereInput
    none?: ProjectSocialsWhereInput
  }

  export type ProjectTagsListRelationFilter = {
    every?: ProjectTagsWhereInput
    some?: ProjectTagsWhereInput
    none?: ProjectTagsWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type ProjectFollowingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSocialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectsOrderByRelevanceInput = {
    fields: ProjectsOrderByRelevanceFieldEnum | ProjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectsCountOrderByAggregateInput = {
    projectId?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    audience?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectsAvgOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectsMaxOrderByAggregateInput = {
    projectId?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    audience?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectsMinOrderByAggregateInput = {
    projectId?: SortOrder
    title?: SortOrder
    hook?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    audience?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectsSumOrderByAggregateInput = {
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProjectsPurposeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsPurpose | EnumProjectsPurposeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectsPurpose[] | null
    notIn?: $Enums.ProjectsPurpose[] | null
    not?: NestedEnumProjectsPurposeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProjectsPurpose | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel>
    _max?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel>
  }

  export type EnumProjectsStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsStatus | EnumProjectsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectsStatus[]
    notIn?: $Enums.ProjectsStatus[]
    not?: NestedEnumProjectsStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectsStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectsStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectsStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserSocialsListRelationFilter = {
    every?: UserSocialsWhereInput
    some?: UserSocialsWhereInput
    none?: UserSocialsWhereInput
  }

  export type UserSocialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialsOrderByRelevanceInput = {
    fields: SocialsOrderByRelevanceFieldEnum | SocialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocialsCountOrderByAggregateInput = {
    websiteId?: SortOrder
    label?: SortOrder
  }

  export type SocialsAvgOrderByAggregateInput = {
    websiteId?: SortOrder
  }

  export type SocialsMaxOrderByAggregateInput = {
    websiteId?: SortOrder
    label?: SortOrder
  }

  export type SocialsMinOrderByAggregateInput = {
    websiteId?: SortOrder
    label?: SortOrder
  }

  export type SocialsSumOrderByAggregateInput = {
    websiteId?: SortOrder
  }

  export type TagsOrderByRelevanceInput = {
    fields: TagsOrderByRelevanceFieldEnum | TagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagsCountOrderByAggregateInput = {
    tagId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type TagsAvgOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    tagId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    tagId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type TagsSumOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type UserFollowingsUserIdFollowingIdCompoundUniqueInput = {
    userId: number
    followingId: number
  }

  export type UserFollowingsCountOrderByAggregateInput = {
    userId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type UserFollowingsAvgOrderByAggregateInput = {
    userId?: SortOrder
    followingId?: SortOrder
  }

  export type UserFollowingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type UserFollowingsMinOrderByAggregateInput = {
    userId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type UserFollowingsSumOrderByAggregateInput = {
    userId?: SortOrder
    followingId?: SortOrder
  }

  export type SkillsScalarRelationFilter = {
    is?: SkillsWhereInput
    isNot?: SkillsWhereInput
  }

  export type UserSkillsUserIdSkillIdCompoundUniqueInput = {
    userId: number
    skillId: number
  }

  export type UserSkillsCountOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
  }

  export type UserSkillsAvgOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
  }

  export type UserSkillsMaxOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
  }

  export type UserSkillsMinOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
  }

  export type UserSkillsSumOrderByAggregateInput = {
    userId?: SortOrder
    skillId?: SortOrder
    position?: SortOrder
  }

  export type UserSocialsOrderByRelevanceInput = {
    fields: UserSocialsOrderByRelevanceFieldEnum | UserSocialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSocialsUserIdWebsiteIdCompoundUniqueInput = {
    userId: number
    websiteId: number
  }

  export type UserSocialsCountOrderByAggregateInput = {
    userId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type UserSocialsAvgOrderByAggregateInput = {
    userId?: SortOrder
    websiteId?: SortOrder
  }

  export type UserSocialsMaxOrderByAggregateInput = {
    userId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type UserSocialsMinOrderByAggregateInput = {
    userId?: SortOrder
    websiteId?: SortOrder
    url?: SortOrder
  }

  export type UserSocialsSumOrderByAggregateInput = {
    userId?: SortOrder
    websiteId?: SortOrder
  }

  export type EnumUsersAcademicYearNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UsersAcademicYear | EnumUsersAcademicYearFieldRefInput<$PrismaModel> | null
    in?: $Enums.UsersAcademicYear[] | null
    notIn?: $Enums.UsersAcademicYear[] | null
    not?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel> | $Enums.UsersAcademicYear | null
  }

  export type ProjectsListRelationFilter = {
    every?: ProjectsWhereInput
    some?: ProjectsWhereInput
    none?: ProjectsWhereInput
  }

  export type UserFollowingsListRelationFilter = {
    every?: UserFollowingsWhereInput
    some?: UserFollowingsWhereInput
    none?: UserFollowingsWhereInput
  }

  export type UserSkillsListRelationFilter = {
    every?: UserSkillsWhereInput
    some?: UserSkillsWhereInput
    none?: UserSkillsWhereInput
  }

  export type JobTitlesNullableScalarRelationFilter = {
    is?: JobTitlesWhereInput | null
    isNot?: JobTitlesWhereInput | null
  }

  export type MajorsNullableScalarRelationFilter = {
    is?: MajorsWhereInput | null
    isNot?: MajorsWhereInput | null
  }

  export type ProjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFollowingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSkillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelevanceInput = {
    fields: UsersOrderByRelevanceFieldEnum | UsersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsersCountOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    ritEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    headline?: SortOrder
    pronouns?: SortOrder
    jobTitleId?: SortOrder
    majorId?: SortOrder
    academicYear?: SortOrder
    location?: SortOrder
    funFact?: SortOrder
    bio?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    universityId?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    userId?: SortOrder
    jobTitleId?: SortOrder
    majorId?: SortOrder
    visibility?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    ritEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    headline?: SortOrder
    pronouns?: SortOrder
    jobTitleId?: SortOrder
    majorId?: SortOrder
    academicYear?: SortOrder
    location?: SortOrder
    funFact?: SortOrder
    bio?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    universityId?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    userId?: SortOrder
    username?: SortOrder
    ritEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    headline?: SortOrder
    pronouns?: SortOrder
    jobTitleId?: SortOrder
    majorId?: SortOrder
    academicYear?: SortOrder
    location?: SortOrder
    funFact?: SortOrder
    bio?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    universityId?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    userId?: SortOrder
    jobTitleId?: SortOrder
    majorId?: SortOrder
    visibility?: SortOrder
    phoneNumber?: SortOrder
  }

  export type EnumUsersAcademicYearNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsersAcademicYear | EnumUsersAcademicYearFieldRefInput<$PrismaModel> | null
    in?: $Enums.UsersAcademicYear[] | null
    notIn?: $Enums.UsersAcademicYear[] | null
    not?: NestedEnumUsersAcademicYearNullableWithAggregatesFilter<$PrismaModel> | $Enums.UsersAcademicYear | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel>
    _max?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel>
  }

  export type SkillsOrderByRelevanceInput = {
    fields: SkillsOrderByRelevanceFieldEnum | SkillsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SkillsCountOrderByAggregateInput = {
    skillId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type SkillsAvgOrderByAggregateInput = {
    skillId?: SortOrder
  }

  export type SkillsMaxOrderByAggregateInput = {
    skillId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type SkillsMinOrderByAggregateInput = {
    skillId?: SortOrder
    label?: SortOrder
    type?: SortOrder
  }

  export type SkillsSumOrderByAggregateInput = {
    skillId?: SortOrder
  }

  export type ProjectGenresCreateNestedManyWithoutGenresInput = {
    create?: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput> | ProjectGenresCreateWithoutGenresInput[] | ProjectGenresUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutGenresInput | ProjectGenresCreateOrConnectWithoutGenresInput[]
    createMany?: ProjectGenresCreateManyGenresInputEnvelope
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
  }

  export type ProjectGenresUncheckedCreateNestedManyWithoutGenresInput = {
    create?: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput> | ProjectGenresCreateWithoutGenresInput[] | ProjectGenresUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutGenresInput | ProjectGenresCreateOrConnectWithoutGenresInput[]
    createMany?: ProjectGenresCreateManyGenresInputEnvelope
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProjectGenresUpdateManyWithoutGenresNestedInput = {
    create?: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput> | ProjectGenresCreateWithoutGenresInput[] | ProjectGenresUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutGenresInput | ProjectGenresCreateOrConnectWithoutGenresInput[]
    upsert?: ProjectGenresUpsertWithWhereUniqueWithoutGenresInput | ProjectGenresUpsertWithWhereUniqueWithoutGenresInput[]
    createMany?: ProjectGenresCreateManyGenresInputEnvelope
    set?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    disconnect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    delete?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    update?: ProjectGenresUpdateWithWhereUniqueWithoutGenresInput | ProjectGenresUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: ProjectGenresUpdateManyWithWhereWithoutGenresInput | ProjectGenresUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectGenresUncheckedUpdateManyWithoutGenresNestedInput = {
    create?: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput> | ProjectGenresCreateWithoutGenresInput[] | ProjectGenresUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutGenresInput | ProjectGenresCreateOrConnectWithoutGenresInput[]
    upsert?: ProjectGenresUpsertWithWhereUniqueWithoutGenresInput | ProjectGenresUpsertWithWhereUniqueWithoutGenresInput[]
    createMany?: ProjectGenresCreateManyGenresInputEnvelope
    set?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    disconnect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    delete?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    update?: ProjectGenresUpdateWithWhereUniqueWithoutGenresInput | ProjectGenresUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: ProjectGenresUpdateManyWithWhereWithoutGenresInput | ProjectGenresUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
  }

  export type JobsCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput> | JobsCreateWithoutJobTitlesInput[] | JobsUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutJobTitlesInput | JobsCreateOrConnectWithoutJobTitlesInput[]
    createMany?: JobsCreateManyJobTitlesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MembersCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput> | MembersCreateWithoutJobTitlesInput[] | MembersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutJobTitlesInput | MembersCreateOrConnectWithoutJobTitlesInput[]
    createMany?: MembersCreateManyJobTitlesInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type UsersCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput> | UsersCreateWithoutJobTitlesInput[] | UsersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutJobTitlesInput | UsersCreateOrConnectWithoutJobTitlesInput[]
    createMany?: UsersCreateManyJobTitlesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput> | JobsCreateWithoutJobTitlesInput[] | JobsUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutJobTitlesInput | JobsCreateOrConnectWithoutJobTitlesInput[]
    createMany?: JobsCreateManyJobTitlesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MembersUncheckedCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput> | MembersCreateWithoutJobTitlesInput[] | MembersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutJobTitlesInput | MembersCreateOrConnectWithoutJobTitlesInput[]
    createMany?: MembersCreateManyJobTitlesInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutJobTitlesInput = {
    create?: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput> | UsersCreateWithoutJobTitlesInput[] | UsersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutJobTitlesInput | UsersCreateOrConnectWithoutJobTitlesInput[]
    createMany?: UsersCreateManyJobTitlesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type JobsUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput> | JobsCreateWithoutJobTitlesInput[] | JobsUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutJobTitlesInput | JobsCreateOrConnectWithoutJobTitlesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutJobTitlesInput | JobsUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: JobsCreateManyJobTitlesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutJobTitlesInput | JobsUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutJobTitlesInput | JobsUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MembersUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput> | MembersCreateWithoutJobTitlesInput[] | MembersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutJobTitlesInput | MembersCreateOrConnectWithoutJobTitlesInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutJobTitlesInput | MembersUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: MembersCreateManyJobTitlesInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutJobTitlesInput | MembersUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutJobTitlesInput | MembersUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type UsersUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput> | UsersCreateWithoutJobTitlesInput[] | UsersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutJobTitlesInput | UsersCreateOrConnectWithoutJobTitlesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutJobTitlesInput | UsersUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: UsersCreateManyJobTitlesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutJobTitlesInput | UsersUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutJobTitlesInput | UsersUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput> | JobsCreateWithoutJobTitlesInput[] | JobsUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutJobTitlesInput | JobsCreateOrConnectWithoutJobTitlesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutJobTitlesInput | JobsUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: JobsCreateManyJobTitlesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutJobTitlesInput | JobsUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutJobTitlesInput | JobsUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MembersUncheckedUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput> | MembersCreateWithoutJobTitlesInput[] | MembersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutJobTitlesInput | MembersCreateOrConnectWithoutJobTitlesInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutJobTitlesInput | MembersUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: MembersCreateManyJobTitlesInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutJobTitlesInput | MembersUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutJobTitlesInput | MembersUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutJobTitlesNestedInput = {
    create?: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput> | UsersCreateWithoutJobTitlesInput[] | UsersUncheckedCreateWithoutJobTitlesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutJobTitlesInput | UsersCreateOrConnectWithoutJobTitlesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutJobTitlesInput | UsersUpsertWithWhereUniqueWithoutJobTitlesInput[]
    createMany?: UsersCreateManyJobTitlesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutJobTitlesInput | UsersUpdateWithWhereUniqueWithoutJobTitlesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutJobTitlesInput | UsersUpdateManyWithWhereWithoutJobTitlesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type ProjectsCreateNestedOneWithoutJobsInput = {
    create?: XOR<ProjectsCreateWithoutJobsInput, ProjectsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutJobsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type JobTitlesCreateNestedOneWithoutJobsInput = {
    create?: XOR<JobTitlesCreateWithoutJobsInput, JobTitlesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutJobsInput
    connect?: JobTitlesWhereUniqueInput
  }

  export type EnumJobsAvailabilityFieldUpdateOperationsInput = {
    set?: $Enums.JobsAvailability
  }

  export type EnumJobsDurationFieldUpdateOperationsInput = {
    set?: $Enums.JobsDuration
  }

  export type EnumJobsLocationFieldUpdateOperationsInput = {
    set?: $Enums.JobsLocation
  }

  export type EnumJobsCompensationFieldUpdateOperationsInput = {
    set?: $Enums.JobsCompensation
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<ProjectsCreateWithoutJobsInput, ProjectsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutJobsInput
    upsert?: ProjectsUpsertWithoutJobsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutJobsInput, ProjectsUpdateWithoutJobsInput>, ProjectsUncheckedUpdateWithoutJobsInput>
  }

  export type JobTitlesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<JobTitlesCreateWithoutJobsInput, JobTitlesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutJobsInput
    upsert?: JobTitlesUpsertWithoutJobsInput
    connect?: JobTitlesWhereUniqueInput
    update?: XOR<XOR<JobTitlesUpdateToOneWithWhereWithoutJobsInput, JobTitlesUpdateWithoutJobsInput>, JobTitlesUncheckedUpdateWithoutJobsInput>
  }

  export type UsersCreateNestedManyWithoutMajorsInput = {
    create?: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput> | UsersCreateWithoutMajorsInput[] | UsersUncheckedCreateWithoutMajorsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMajorsInput | UsersCreateOrConnectWithoutMajorsInput[]
    createMany?: UsersCreateManyMajorsInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutMajorsInput = {
    create?: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput> | UsersCreateWithoutMajorsInput[] | UsersUncheckedCreateWithoutMajorsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMajorsInput | UsersCreateOrConnectWithoutMajorsInput[]
    createMany?: UsersCreateManyMajorsInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput> | UsersCreateWithoutMajorsInput[] | UsersUncheckedCreateWithoutMajorsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMajorsInput | UsersCreateOrConnectWithoutMajorsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutMajorsInput | UsersUpsertWithWhereUniqueWithoutMajorsInput[]
    createMany?: UsersCreateManyMajorsInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutMajorsInput | UsersUpdateWithWhereUniqueWithoutMajorsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutMajorsInput | UsersUpdateManyWithWhereWithoutMajorsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput> | UsersCreateWithoutMajorsInput[] | UsersUncheckedCreateWithoutMajorsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMajorsInput | UsersCreateOrConnectWithoutMajorsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutMajorsInput | UsersUpsertWithWhereUniqueWithoutMajorsInput[]
    createMany?: UsersCreateManyMajorsInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutMajorsInput | UsersUpdateWithWhereUniqueWithoutMajorsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutMajorsInput | UsersUpdateManyWithWhereWithoutMajorsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type JobTitlesCreateNestedOneWithoutMembersInput = {
    create?: XOR<JobTitlesCreateWithoutMembersInput, JobTitlesUncheckedCreateWithoutMembersInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutMembersInput
    connect?: JobTitlesWhereUniqueInput
  }

  export type ProjectsCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectsCreateWithoutMembersInput, ProjectsUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutMembersInput
    connect?: ProjectsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutMembersInput = {
    create?: XOR<UsersCreateWithoutMembersInput, UsersUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMembersInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumMembersProfileVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.MembersProfileVisibility
  }

  export type JobTitlesUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<JobTitlesCreateWithoutMembersInput, JobTitlesUncheckedCreateWithoutMembersInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutMembersInput
    upsert?: JobTitlesUpsertWithoutMembersInput
    connect?: JobTitlesWhereUniqueInput
    update?: XOR<XOR<JobTitlesUpdateToOneWithWhereWithoutMembersInput, JobTitlesUpdateWithoutMembersInput>, JobTitlesUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectsUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectsCreateWithoutMembersInput, ProjectsUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutMembersInput
    upsert?: ProjectsUpsertWithoutMembersInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutMembersInput, ProjectsUpdateWithoutMembersInput>, ProjectsUncheckedUpdateWithoutMembersInput>
  }

  export type UsersUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UsersCreateWithoutMembersInput, UsersUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMembersInput
    upsert?: UsersUpsertWithoutMembersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMembersInput, UsersUpdateWithoutMembersInput>, UsersUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectFollowingsInput = {
    create?: XOR<ProjectsCreateWithoutProjectFollowingsInput, ProjectsUncheckedCreateWithoutProjectFollowingsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectFollowingsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutProjectFollowingsInput = {
    create?: XOR<UsersCreateWithoutProjectFollowingsInput, UsersUncheckedCreateWithoutProjectFollowingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutProjectFollowingsInput
    connect?: UsersWhereUniqueInput
  }

  export type ProjectsUpdateOneRequiredWithoutProjectFollowingsNestedInput = {
    create?: XOR<ProjectsCreateWithoutProjectFollowingsInput, ProjectsUncheckedCreateWithoutProjectFollowingsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectFollowingsInput
    upsert?: ProjectsUpsertWithoutProjectFollowingsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutProjectFollowingsInput, ProjectsUpdateWithoutProjectFollowingsInput>, ProjectsUncheckedUpdateWithoutProjectFollowingsInput>
  }

  export type UsersUpdateOneRequiredWithoutProjectFollowingsNestedInput = {
    create?: XOR<UsersCreateWithoutProjectFollowingsInput, UsersUncheckedCreateWithoutProjectFollowingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutProjectFollowingsInput
    upsert?: UsersUpsertWithoutProjectFollowingsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutProjectFollowingsInput, UsersUpdateWithoutProjectFollowingsInput>, UsersUncheckedUpdateWithoutProjectFollowingsInput>
  }

  export type GenresCreateNestedOneWithoutProjectGenresInput = {
    create?: XOR<GenresCreateWithoutProjectGenresInput, GenresUncheckedCreateWithoutProjectGenresInput>
    connectOrCreate?: GenresCreateOrConnectWithoutProjectGenresInput
    connect?: GenresWhereUniqueInput
  }

  export type ProjectsCreateNestedOneWithoutProjectGenresInput = {
    create?: XOR<ProjectsCreateWithoutProjectGenresInput, ProjectsUncheckedCreateWithoutProjectGenresInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectGenresInput
    connect?: ProjectsWhereUniqueInput
  }

  export type GenresUpdateOneRequiredWithoutProjectGenresNestedInput = {
    create?: XOR<GenresCreateWithoutProjectGenresInput, GenresUncheckedCreateWithoutProjectGenresInput>
    connectOrCreate?: GenresCreateOrConnectWithoutProjectGenresInput
    upsert?: GenresUpsertWithoutProjectGenresInput
    connect?: GenresWhereUniqueInput
    update?: XOR<XOR<GenresUpdateToOneWithWhereWithoutProjectGenresInput, GenresUpdateWithoutProjectGenresInput>, GenresUncheckedUpdateWithoutProjectGenresInput>
  }

  export type ProjectsUpdateOneRequiredWithoutProjectGenresNestedInput = {
    create?: XOR<ProjectsCreateWithoutProjectGenresInput, ProjectsUncheckedCreateWithoutProjectGenresInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectGenresInput
    upsert?: ProjectsUpsertWithoutProjectGenresInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutProjectGenresInput, ProjectsUpdateWithoutProjectGenresInput>, ProjectsUncheckedUpdateWithoutProjectGenresInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectImagesInput = {
    create?: XOR<ProjectsCreateWithoutProjectImagesInput, ProjectsUncheckedCreateWithoutProjectImagesInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectImagesInput
    connect?: ProjectsWhereUniqueInput
  }

  export type ProjectsUpdateOneRequiredWithoutProjectImagesNestedInput = {
    create?: XOR<ProjectsCreateWithoutProjectImagesInput, ProjectsUncheckedCreateWithoutProjectImagesInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectImagesInput
    upsert?: ProjectsUpsertWithoutProjectImagesInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutProjectImagesInput, ProjectsUpdateWithoutProjectImagesInput>, ProjectsUncheckedUpdateWithoutProjectImagesInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectSocialsInput = {
    create?: XOR<ProjectsCreateWithoutProjectSocialsInput, ProjectsUncheckedCreateWithoutProjectSocialsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectSocialsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type SocialsCreateNestedOneWithoutProjectSocialsInput = {
    create?: XOR<SocialsCreateWithoutProjectSocialsInput, SocialsUncheckedCreateWithoutProjectSocialsInput>
    connectOrCreate?: SocialsCreateOrConnectWithoutProjectSocialsInput
    connect?: SocialsWhereUniqueInput
  }

  export type ProjectsUpdateOneRequiredWithoutProjectSocialsNestedInput = {
    create?: XOR<ProjectsCreateWithoutProjectSocialsInput, ProjectsUncheckedCreateWithoutProjectSocialsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectSocialsInput
    upsert?: ProjectsUpsertWithoutProjectSocialsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutProjectSocialsInput, ProjectsUpdateWithoutProjectSocialsInput>, ProjectsUncheckedUpdateWithoutProjectSocialsInput>
  }

  export type SocialsUpdateOneRequiredWithoutProjectSocialsNestedInput = {
    create?: XOR<SocialsCreateWithoutProjectSocialsInput, SocialsUncheckedCreateWithoutProjectSocialsInput>
    connectOrCreate?: SocialsCreateOrConnectWithoutProjectSocialsInput
    upsert?: SocialsUpsertWithoutProjectSocialsInput
    connect?: SocialsWhereUniqueInput
    update?: XOR<XOR<SocialsUpdateToOneWithWhereWithoutProjectSocialsInput, SocialsUpdateWithoutProjectSocialsInput>, SocialsUncheckedUpdateWithoutProjectSocialsInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<ProjectsCreateWithoutProjectTagsInput, ProjectsUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectTagsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type TagsCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<TagsCreateWithoutProjectTagsInput, TagsUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagsCreateOrConnectWithoutProjectTagsInput
    connect?: TagsWhereUniqueInput
  }

  export type ProjectsUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<ProjectsCreateWithoutProjectTagsInput, ProjectsUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectTagsInput
    upsert?: ProjectsUpsertWithoutProjectTagsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutProjectTagsInput, ProjectsUpdateWithoutProjectTagsInput>, ProjectsUncheckedUpdateWithoutProjectTagsInput>
  }

  export type TagsUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<TagsCreateWithoutProjectTagsInput, TagsUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagsCreateOrConnectWithoutProjectTagsInput
    upsert?: TagsUpsertWithoutProjectTagsInput
    connect?: TagsWhereUniqueInput
    update?: XOR<XOR<TagsUpdateToOneWithWhereWithoutProjectTagsInput, TagsUpdateWithoutProjectTagsInput>, TagsUncheckedUpdateWithoutProjectTagsInput>
  }

  export type JobsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput> | JobsCreateWithoutProjectsInput[] | JobsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutProjectsInput | JobsCreateOrConnectWithoutProjectsInput[]
    createMany?: JobsCreateManyProjectsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MembersCreateNestedManyWithoutProjectsInput = {
    create?: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput> | MembersCreateWithoutProjectsInput[] | MembersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutProjectsInput | MembersCreateOrConnectWithoutProjectsInput[]
    createMany?: MembersCreateManyProjectsInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type ProjectFollowingsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput> | ProjectFollowingsCreateWithoutProjectsInput[] | ProjectFollowingsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutProjectsInput | ProjectFollowingsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectFollowingsCreateManyProjectsInputEnvelope
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
  }

  export type ProjectGenresCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput> | ProjectGenresCreateWithoutProjectsInput[] | ProjectGenresUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutProjectsInput | ProjectGenresCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectGenresCreateManyProjectsInputEnvelope
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
  }

  export type ProjectImagesCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput> | ProjectImagesCreateWithoutProjectsInput[] | ProjectImagesUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectImagesCreateOrConnectWithoutProjectsInput | ProjectImagesCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectImagesCreateManyProjectsInputEnvelope
    connect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
  }

  export type ProjectSocialsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput> | ProjectSocialsCreateWithoutProjectsInput[] | ProjectSocialsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutProjectsInput | ProjectSocialsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectSocialsCreateManyProjectsInputEnvelope
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
  }

  export type ProjectTagsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput> | ProjectTagsCreateWithoutProjectsInput[] | ProjectTagsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutProjectsInput | ProjectTagsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectTagsCreateManyProjectsInputEnvelope
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UsersCreateWithoutProjectsInput, UsersUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutProjectsInput
    connect?: UsersWhereUniqueInput
  }

  export type JobsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput> | JobsCreateWithoutProjectsInput[] | JobsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutProjectsInput | JobsCreateOrConnectWithoutProjectsInput[]
    createMany?: JobsCreateManyProjectsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MembersUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput> | MembersCreateWithoutProjectsInput[] | MembersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutProjectsInput | MembersCreateOrConnectWithoutProjectsInput[]
    createMany?: MembersCreateManyProjectsInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput> | ProjectFollowingsCreateWithoutProjectsInput[] | ProjectFollowingsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutProjectsInput | ProjectFollowingsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectFollowingsCreateManyProjectsInputEnvelope
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
  }

  export type ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput> | ProjectGenresCreateWithoutProjectsInput[] | ProjectGenresUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutProjectsInput | ProjectGenresCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectGenresCreateManyProjectsInputEnvelope
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
  }

  export type ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput> | ProjectImagesCreateWithoutProjectsInput[] | ProjectImagesUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectImagesCreateOrConnectWithoutProjectsInput | ProjectImagesCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectImagesCreateManyProjectsInputEnvelope
    connect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
  }

  export type ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput> | ProjectSocialsCreateWithoutProjectsInput[] | ProjectSocialsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutProjectsInput | ProjectSocialsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectSocialsCreateManyProjectsInputEnvelope
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
  }

  export type ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput> | ProjectTagsCreateWithoutProjectsInput[] | ProjectTagsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutProjectsInput | ProjectTagsCreateOrConnectWithoutProjectsInput[]
    createMany?: ProjectTagsCreateManyProjectsInputEnvelope
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
  }

  export type NullableEnumProjectsPurposeFieldUpdateOperationsInput = {
    set?: $Enums.ProjectsPurpose | null
  }

  export type EnumProjectsStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectsStatus
  }

  export type JobsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput> | JobsCreateWithoutProjectsInput[] | JobsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutProjectsInput | JobsCreateOrConnectWithoutProjectsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutProjectsInput | JobsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: JobsCreateManyProjectsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutProjectsInput | JobsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutProjectsInput | JobsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MembersUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput> | MembersCreateWithoutProjectsInput[] | MembersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutProjectsInput | MembersCreateOrConnectWithoutProjectsInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutProjectsInput | MembersUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: MembersCreateManyProjectsInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutProjectsInput | MembersUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutProjectsInput | MembersUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type ProjectFollowingsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput> | ProjectFollowingsCreateWithoutProjectsInput[] | ProjectFollowingsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutProjectsInput | ProjectFollowingsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectFollowingsUpsertWithWhereUniqueWithoutProjectsInput | ProjectFollowingsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectFollowingsCreateManyProjectsInputEnvelope
    set?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    disconnect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    delete?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    update?: ProjectFollowingsUpdateWithWhereUniqueWithoutProjectsInput | ProjectFollowingsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectFollowingsUpdateManyWithWhereWithoutProjectsInput | ProjectFollowingsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
  }

  export type ProjectGenresUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput> | ProjectGenresCreateWithoutProjectsInput[] | ProjectGenresUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutProjectsInput | ProjectGenresCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectGenresUpsertWithWhereUniqueWithoutProjectsInput | ProjectGenresUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectGenresCreateManyProjectsInputEnvelope
    set?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    disconnect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    delete?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    update?: ProjectGenresUpdateWithWhereUniqueWithoutProjectsInput | ProjectGenresUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectGenresUpdateManyWithWhereWithoutProjectsInput | ProjectGenresUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
  }

  export type ProjectImagesUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput> | ProjectImagesCreateWithoutProjectsInput[] | ProjectImagesUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectImagesCreateOrConnectWithoutProjectsInput | ProjectImagesCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectImagesUpsertWithWhereUniqueWithoutProjectsInput | ProjectImagesUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectImagesCreateManyProjectsInputEnvelope
    set?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    disconnect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    delete?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    connect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    update?: ProjectImagesUpdateWithWhereUniqueWithoutProjectsInput | ProjectImagesUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectImagesUpdateManyWithWhereWithoutProjectsInput | ProjectImagesUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectImagesScalarWhereInput | ProjectImagesScalarWhereInput[]
  }

  export type ProjectSocialsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput> | ProjectSocialsCreateWithoutProjectsInput[] | ProjectSocialsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutProjectsInput | ProjectSocialsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectSocialsUpsertWithWhereUniqueWithoutProjectsInput | ProjectSocialsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectSocialsCreateManyProjectsInputEnvelope
    set?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    disconnect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    delete?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    update?: ProjectSocialsUpdateWithWhereUniqueWithoutProjectsInput | ProjectSocialsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectSocialsUpdateManyWithWhereWithoutProjectsInput | ProjectSocialsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
  }

  export type ProjectTagsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput> | ProjectTagsCreateWithoutProjectsInput[] | ProjectTagsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutProjectsInput | ProjectTagsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectTagsUpsertWithWhereUniqueWithoutProjectsInput | ProjectTagsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectTagsCreateManyProjectsInputEnvelope
    set?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    disconnect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    delete?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    update?: ProjectTagsUpdateWithWhereUniqueWithoutProjectsInput | ProjectTagsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectTagsUpdateManyWithWhereWithoutProjectsInput | ProjectTagsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
  }

  export type UsersUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<UsersCreateWithoutProjectsInput, UsersUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutProjectsInput
    upsert?: UsersUpsertWithoutProjectsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutProjectsInput, UsersUpdateWithoutProjectsInput>, UsersUncheckedUpdateWithoutProjectsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput> | JobsCreateWithoutProjectsInput[] | JobsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutProjectsInput | JobsCreateOrConnectWithoutProjectsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutProjectsInput | JobsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: JobsCreateManyProjectsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutProjectsInput | JobsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutProjectsInput | JobsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MembersUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput> | MembersCreateWithoutProjectsInput[] | MembersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutProjectsInput | MembersCreateOrConnectWithoutProjectsInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutProjectsInput | MembersUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: MembersCreateManyProjectsInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutProjectsInput | MembersUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutProjectsInput | MembersUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput> | ProjectFollowingsCreateWithoutProjectsInput[] | ProjectFollowingsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutProjectsInput | ProjectFollowingsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectFollowingsUpsertWithWhereUniqueWithoutProjectsInput | ProjectFollowingsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectFollowingsCreateManyProjectsInputEnvelope
    set?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    disconnect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    delete?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    update?: ProjectFollowingsUpdateWithWhereUniqueWithoutProjectsInput | ProjectFollowingsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectFollowingsUpdateManyWithWhereWithoutProjectsInput | ProjectFollowingsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
  }

  export type ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput> | ProjectGenresCreateWithoutProjectsInput[] | ProjectGenresUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectGenresCreateOrConnectWithoutProjectsInput | ProjectGenresCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectGenresUpsertWithWhereUniqueWithoutProjectsInput | ProjectGenresUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectGenresCreateManyProjectsInputEnvelope
    set?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    disconnect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    delete?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    connect?: ProjectGenresWhereUniqueInput | ProjectGenresWhereUniqueInput[]
    update?: ProjectGenresUpdateWithWhereUniqueWithoutProjectsInput | ProjectGenresUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectGenresUpdateManyWithWhereWithoutProjectsInput | ProjectGenresUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
  }

  export type ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput> | ProjectImagesCreateWithoutProjectsInput[] | ProjectImagesUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectImagesCreateOrConnectWithoutProjectsInput | ProjectImagesCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectImagesUpsertWithWhereUniqueWithoutProjectsInput | ProjectImagesUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectImagesCreateManyProjectsInputEnvelope
    set?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    disconnect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    delete?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    connect?: ProjectImagesWhereUniqueInput | ProjectImagesWhereUniqueInput[]
    update?: ProjectImagesUpdateWithWhereUniqueWithoutProjectsInput | ProjectImagesUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectImagesUpdateManyWithWhereWithoutProjectsInput | ProjectImagesUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectImagesScalarWhereInput | ProjectImagesScalarWhereInput[]
  }

  export type ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput> | ProjectSocialsCreateWithoutProjectsInput[] | ProjectSocialsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutProjectsInput | ProjectSocialsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectSocialsUpsertWithWhereUniqueWithoutProjectsInput | ProjectSocialsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectSocialsCreateManyProjectsInputEnvelope
    set?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    disconnect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    delete?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    update?: ProjectSocialsUpdateWithWhereUniqueWithoutProjectsInput | ProjectSocialsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectSocialsUpdateManyWithWhereWithoutProjectsInput | ProjectSocialsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
  }

  export type ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput> | ProjectTagsCreateWithoutProjectsInput[] | ProjectTagsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutProjectsInput | ProjectTagsCreateOrConnectWithoutProjectsInput[]
    upsert?: ProjectTagsUpsertWithWhereUniqueWithoutProjectsInput | ProjectTagsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: ProjectTagsCreateManyProjectsInputEnvelope
    set?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    disconnect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    delete?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    update?: ProjectTagsUpdateWithWhereUniqueWithoutProjectsInput | ProjectTagsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: ProjectTagsUpdateManyWithWhereWithoutProjectsInput | ProjectTagsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
  }

  export type ProjectSocialsCreateNestedManyWithoutSocialsInput = {
    create?: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput> | ProjectSocialsCreateWithoutSocialsInput[] | ProjectSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutSocialsInput | ProjectSocialsCreateOrConnectWithoutSocialsInput[]
    createMany?: ProjectSocialsCreateManySocialsInputEnvelope
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
  }

  export type UserSocialsCreateNestedManyWithoutSocialsInput = {
    create?: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput> | UserSocialsCreateWithoutSocialsInput[] | UserSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutSocialsInput | UserSocialsCreateOrConnectWithoutSocialsInput[]
    createMany?: UserSocialsCreateManySocialsInputEnvelope
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
  }

  export type ProjectSocialsUncheckedCreateNestedManyWithoutSocialsInput = {
    create?: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput> | ProjectSocialsCreateWithoutSocialsInput[] | ProjectSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutSocialsInput | ProjectSocialsCreateOrConnectWithoutSocialsInput[]
    createMany?: ProjectSocialsCreateManySocialsInputEnvelope
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
  }

  export type UserSocialsUncheckedCreateNestedManyWithoutSocialsInput = {
    create?: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput> | UserSocialsCreateWithoutSocialsInput[] | UserSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutSocialsInput | UserSocialsCreateOrConnectWithoutSocialsInput[]
    createMany?: UserSocialsCreateManySocialsInputEnvelope
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
  }

  export type ProjectSocialsUpdateManyWithoutSocialsNestedInput = {
    create?: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput> | ProjectSocialsCreateWithoutSocialsInput[] | ProjectSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutSocialsInput | ProjectSocialsCreateOrConnectWithoutSocialsInput[]
    upsert?: ProjectSocialsUpsertWithWhereUniqueWithoutSocialsInput | ProjectSocialsUpsertWithWhereUniqueWithoutSocialsInput[]
    createMany?: ProjectSocialsCreateManySocialsInputEnvelope
    set?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    disconnect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    delete?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    update?: ProjectSocialsUpdateWithWhereUniqueWithoutSocialsInput | ProjectSocialsUpdateWithWhereUniqueWithoutSocialsInput[]
    updateMany?: ProjectSocialsUpdateManyWithWhereWithoutSocialsInput | ProjectSocialsUpdateManyWithWhereWithoutSocialsInput[]
    deleteMany?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
  }

  export type UserSocialsUpdateManyWithoutSocialsNestedInput = {
    create?: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput> | UserSocialsCreateWithoutSocialsInput[] | UserSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutSocialsInput | UserSocialsCreateOrConnectWithoutSocialsInput[]
    upsert?: UserSocialsUpsertWithWhereUniqueWithoutSocialsInput | UserSocialsUpsertWithWhereUniqueWithoutSocialsInput[]
    createMany?: UserSocialsCreateManySocialsInputEnvelope
    set?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    disconnect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    delete?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    update?: UserSocialsUpdateWithWhereUniqueWithoutSocialsInput | UserSocialsUpdateWithWhereUniqueWithoutSocialsInput[]
    updateMany?: UserSocialsUpdateManyWithWhereWithoutSocialsInput | UserSocialsUpdateManyWithWhereWithoutSocialsInput[]
    deleteMany?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
  }

  export type ProjectSocialsUncheckedUpdateManyWithoutSocialsNestedInput = {
    create?: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput> | ProjectSocialsCreateWithoutSocialsInput[] | ProjectSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: ProjectSocialsCreateOrConnectWithoutSocialsInput | ProjectSocialsCreateOrConnectWithoutSocialsInput[]
    upsert?: ProjectSocialsUpsertWithWhereUniqueWithoutSocialsInput | ProjectSocialsUpsertWithWhereUniqueWithoutSocialsInput[]
    createMany?: ProjectSocialsCreateManySocialsInputEnvelope
    set?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    disconnect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    delete?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    connect?: ProjectSocialsWhereUniqueInput | ProjectSocialsWhereUniqueInput[]
    update?: ProjectSocialsUpdateWithWhereUniqueWithoutSocialsInput | ProjectSocialsUpdateWithWhereUniqueWithoutSocialsInput[]
    updateMany?: ProjectSocialsUpdateManyWithWhereWithoutSocialsInput | ProjectSocialsUpdateManyWithWhereWithoutSocialsInput[]
    deleteMany?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
  }

  export type UserSocialsUncheckedUpdateManyWithoutSocialsNestedInput = {
    create?: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput> | UserSocialsCreateWithoutSocialsInput[] | UserSocialsUncheckedCreateWithoutSocialsInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutSocialsInput | UserSocialsCreateOrConnectWithoutSocialsInput[]
    upsert?: UserSocialsUpsertWithWhereUniqueWithoutSocialsInput | UserSocialsUpsertWithWhereUniqueWithoutSocialsInput[]
    createMany?: UserSocialsCreateManySocialsInputEnvelope
    set?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    disconnect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    delete?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    update?: UserSocialsUpdateWithWhereUniqueWithoutSocialsInput | UserSocialsUpdateWithWhereUniqueWithoutSocialsInput[]
    updateMany?: UserSocialsUpdateManyWithWhereWithoutSocialsInput | UserSocialsUpdateManyWithWhereWithoutSocialsInput[]
    deleteMany?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
  }

  export type ProjectTagsCreateNestedManyWithoutTagsInput = {
    create?: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput> | ProjectTagsCreateWithoutTagsInput[] | ProjectTagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutTagsInput | ProjectTagsCreateOrConnectWithoutTagsInput[]
    createMany?: ProjectTagsCreateManyTagsInputEnvelope
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
  }

  export type ProjectTagsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput> | ProjectTagsCreateWithoutTagsInput[] | ProjectTagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutTagsInput | ProjectTagsCreateOrConnectWithoutTagsInput[]
    createMany?: ProjectTagsCreateManyTagsInputEnvelope
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
  }

  export type ProjectTagsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput> | ProjectTagsCreateWithoutTagsInput[] | ProjectTagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutTagsInput | ProjectTagsCreateOrConnectWithoutTagsInput[]
    upsert?: ProjectTagsUpsertWithWhereUniqueWithoutTagsInput | ProjectTagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: ProjectTagsCreateManyTagsInputEnvelope
    set?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    disconnect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    delete?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    update?: ProjectTagsUpdateWithWhereUniqueWithoutTagsInput | ProjectTagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ProjectTagsUpdateManyWithWhereWithoutTagsInput | ProjectTagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
  }

  export type ProjectTagsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput> | ProjectTagsCreateWithoutTagsInput[] | ProjectTagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProjectTagsCreateOrConnectWithoutTagsInput | ProjectTagsCreateOrConnectWithoutTagsInput[]
    upsert?: ProjectTagsUpsertWithWhereUniqueWithoutTagsInput | ProjectTagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: ProjectTagsCreateManyTagsInputEnvelope
    set?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    disconnect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    delete?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    connect?: ProjectTagsWhereUniqueInput | ProjectTagsWhereUniqueInput[]
    update?: ProjectTagsUpdateWithWhereUniqueWithoutTagsInput | ProjectTagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ProjectTagsUpdateManyWithWhereWithoutTagsInput | ProjectTagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    create?: XOR<UsersCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserFollowingsUserFollowingsFollowingIdTousersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    create?: XOR<UsersCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserFollowingsUserFollowingsUserIdTousersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsFollowingIdTousersNestedInput = {
    create?: XOR<UsersCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserFollowingsUserFollowingsFollowingIdTousersInput
    upsert?: UsersUpsertWithoutUserFollowingsUserFollowingsFollowingIdTousersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
  }

  export type UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsUserIdTousersNestedInput = {
    create?: XOR<UsersCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserFollowingsUserFollowingsUserIdTousersInput
    upsert?: UsersUpsertWithoutUserFollowingsUserFollowingsUserIdTousersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput>, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
  }

  export type SkillsCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<SkillsCreateWithoutUserSkillsInput, SkillsUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillsCreateOrConnectWithoutUserSkillsInput
    connect?: SkillsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<UsersCreateWithoutUserSkillsInput, UsersUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSkillsInput
    connect?: UsersWhereUniqueInput
  }

  export type SkillsUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<SkillsCreateWithoutUserSkillsInput, SkillsUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillsCreateOrConnectWithoutUserSkillsInput
    upsert?: SkillsUpsertWithoutUserSkillsInput
    connect?: SkillsWhereUniqueInput
    update?: XOR<XOR<SkillsUpdateToOneWithWhereWithoutUserSkillsInput, SkillsUpdateWithoutUserSkillsInput>, SkillsUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UsersUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<UsersCreateWithoutUserSkillsInput, UsersUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSkillsInput
    upsert?: UsersUpsertWithoutUserSkillsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserSkillsInput, UsersUpdateWithoutUserSkillsInput>, UsersUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SocialsCreateNestedOneWithoutUserSocialsInput = {
    create?: XOR<SocialsCreateWithoutUserSocialsInput, SocialsUncheckedCreateWithoutUserSocialsInput>
    connectOrCreate?: SocialsCreateOrConnectWithoutUserSocialsInput
    connect?: SocialsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserSocialsInput = {
    create?: XOR<UsersCreateWithoutUserSocialsInput, UsersUncheckedCreateWithoutUserSocialsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSocialsInput
    connect?: UsersWhereUniqueInput
  }

  export type SocialsUpdateOneRequiredWithoutUserSocialsNestedInput = {
    create?: XOR<SocialsCreateWithoutUserSocialsInput, SocialsUncheckedCreateWithoutUserSocialsInput>
    connectOrCreate?: SocialsCreateOrConnectWithoutUserSocialsInput
    upsert?: SocialsUpsertWithoutUserSocialsInput
    connect?: SocialsWhereUniqueInput
    update?: XOR<XOR<SocialsUpdateToOneWithWhereWithoutUserSocialsInput, SocialsUpdateWithoutUserSocialsInput>, SocialsUncheckedUpdateWithoutUserSocialsInput>
  }

  export type UsersUpdateOneRequiredWithoutUserSocialsNestedInput = {
    create?: XOR<UsersCreateWithoutUserSocialsInput, UsersUncheckedCreateWithoutUserSocialsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSocialsInput
    upsert?: UsersUpsertWithoutUserSocialsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserSocialsInput, UsersUpdateWithoutUserSocialsInput>, UsersUncheckedUpdateWithoutUserSocialsInput>
  }

  export type MembersCreateNestedManyWithoutUsersInput = {
    create?: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput> | MembersCreateWithoutUsersInput[] | MembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutUsersInput | MembersCreateOrConnectWithoutUsersInput[]
    createMany?: MembersCreateManyUsersInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type ProjectFollowingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput> | ProjectFollowingsCreateWithoutUsersInput[] | ProjectFollowingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutUsersInput | ProjectFollowingsCreateOrConnectWithoutUsersInput[]
    createMany?: ProjectFollowingsCreateManyUsersInputEnvelope
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
  }

  export type ProjectsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    createMany?: ProjectsCreateManyUsersInputEnvelope
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInputEnvelope
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
  }

  export type UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInputEnvelope
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
  }

  export type UserSkillsCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput> | UserSkillsCreateWithoutUsersInput[] | UserSkillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUsersInput | UserSkillsCreateOrConnectWithoutUsersInput[]
    createMany?: UserSkillsCreateManyUsersInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type UserSocialsCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput> | UserSocialsCreateWithoutUsersInput[] | UserSocialsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutUsersInput | UserSocialsCreateOrConnectWithoutUsersInput[]
    createMany?: UserSocialsCreateManyUsersInputEnvelope
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
  }

  export type JobTitlesCreateNestedOneWithoutUsersInput = {
    create?: XOR<JobTitlesCreateWithoutUsersInput, JobTitlesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutUsersInput
    connect?: JobTitlesWhereUniqueInput
  }

  export type MajorsCreateNestedOneWithoutUsersInput = {
    create?: XOR<MajorsCreateWithoutUsersInput, MajorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MajorsCreateOrConnectWithoutUsersInput
    connect?: MajorsWhereUniqueInput
  }

  export type MembersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput> | MembersCreateWithoutUsersInput[] | MembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutUsersInput | MembersCreateOrConnectWithoutUsersInput[]
    createMany?: MembersCreateManyUsersInputEnvelope
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
  }

  export type ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput> | ProjectFollowingsCreateWithoutUsersInput[] | ProjectFollowingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutUsersInput | ProjectFollowingsCreateOrConnectWithoutUsersInput[]
    createMany?: ProjectFollowingsCreateManyUsersInputEnvelope
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
  }

  export type ProjectsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    createMany?: ProjectsCreateManyUsersInputEnvelope
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInputEnvelope
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
  }

  export type UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInputEnvelope
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
  }

  export type UserSkillsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput> | UserSkillsCreateWithoutUsersInput[] | UserSkillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUsersInput | UserSkillsCreateOrConnectWithoutUsersInput[]
    createMany?: UserSkillsCreateManyUsersInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type UserSocialsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput> | UserSocialsCreateWithoutUsersInput[] | UserSocialsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutUsersInput | UserSocialsCreateOrConnectWithoutUsersInput[]
    createMany?: UserSocialsCreateManyUsersInputEnvelope
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
  }

  export type NullableEnumUsersAcademicYearFieldUpdateOperationsInput = {
    set?: $Enums.UsersAcademicYear | null
  }

  export type MembersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput> | MembersCreateWithoutUsersInput[] | MembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutUsersInput | MembersCreateOrConnectWithoutUsersInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutUsersInput | MembersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MembersCreateManyUsersInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutUsersInput | MembersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutUsersInput | MembersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type ProjectFollowingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput> | ProjectFollowingsCreateWithoutUsersInput[] | ProjectFollowingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutUsersInput | ProjectFollowingsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectFollowingsUpsertWithWhereUniqueWithoutUsersInput | ProjectFollowingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ProjectFollowingsCreateManyUsersInputEnvelope
    set?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    disconnect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    delete?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    update?: ProjectFollowingsUpdateWithWhereUniqueWithoutUsersInput | ProjectFollowingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectFollowingsUpdateManyWithWhereWithoutUsersInput | ProjectFollowingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
  }

  export type ProjectsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutUsersInput | ProjectsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ProjectsCreateManyUsersInputEnvelope
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutUsersInput | ProjectsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutUsersInput | ProjectsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput[]
    upsert?: UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInputEnvelope
    set?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    disconnect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    delete?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    update?: UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput[]
    updateMany?: UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsFollowingIdTousersInput[]
    deleteMany?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
  }

  export type UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput[]
    upsert?: UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInputEnvelope
    set?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    disconnect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    delete?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    update?: UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput[]
    updateMany?: UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsUserIdTousersInput[]
    deleteMany?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
  }

  export type UserSkillsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput> | UserSkillsCreateWithoutUsersInput[] | UserSkillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUsersInput | UserSkillsCreateOrConnectWithoutUsersInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutUsersInput | UserSkillsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSkillsCreateManyUsersInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutUsersInput | UserSkillsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutUsersInput | UserSkillsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type UserSocialsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput> | UserSocialsCreateWithoutUsersInput[] | UserSocialsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutUsersInput | UserSocialsCreateOrConnectWithoutUsersInput[]
    upsert?: UserSocialsUpsertWithWhereUniqueWithoutUsersInput | UserSocialsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSocialsCreateManyUsersInputEnvelope
    set?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    disconnect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    delete?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    update?: UserSocialsUpdateWithWhereUniqueWithoutUsersInput | UserSocialsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSocialsUpdateManyWithWhereWithoutUsersInput | UserSocialsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
  }

  export type JobTitlesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<JobTitlesCreateWithoutUsersInput, JobTitlesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: JobTitlesCreateOrConnectWithoutUsersInput
    upsert?: JobTitlesUpsertWithoutUsersInput
    disconnect?: JobTitlesWhereInput | boolean
    delete?: JobTitlesWhereInput | boolean
    connect?: JobTitlesWhereUniqueInput
    update?: XOR<XOR<JobTitlesUpdateToOneWithWhereWithoutUsersInput, JobTitlesUpdateWithoutUsersInput>, JobTitlesUncheckedUpdateWithoutUsersInput>
  }

  export type MajorsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MajorsCreateWithoutUsersInput, MajorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MajorsCreateOrConnectWithoutUsersInput
    upsert?: MajorsUpsertWithoutUsersInput
    disconnect?: MajorsWhereInput | boolean
    delete?: MajorsWhereInput | boolean
    connect?: MajorsWhereUniqueInput
    update?: XOR<XOR<MajorsUpdateToOneWithWhereWithoutUsersInput, MajorsUpdateWithoutUsersInput>, MajorsUncheckedUpdateWithoutUsersInput>
  }

  export type MembersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput> | MembersCreateWithoutUsersInput[] | MembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MembersCreateOrConnectWithoutUsersInput | MembersCreateOrConnectWithoutUsersInput[]
    upsert?: MembersUpsertWithWhereUniqueWithoutUsersInput | MembersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MembersCreateManyUsersInputEnvelope
    set?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    disconnect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    delete?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    connect?: MembersWhereUniqueInput | MembersWhereUniqueInput[]
    update?: MembersUpdateWithWhereUniqueWithoutUsersInput | MembersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MembersUpdateManyWithWhereWithoutUsersInput | MembersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MembersScalarWhereInput | MembersScalarWhereInput[]
  }

  export type ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput> | ProjectFollowingsCreateWithoutUsersInput[] | ProjectFollowingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectFollowingsCreateOrConnectWithoutUsersInput | ProjectFollowingsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectFollowingsUpsertWithWhereUniqueWithoutUsersInput | ProjectFollowingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ProjectFollowingsCreateManyUsersInputEnvelope
    set?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    disconnect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    delete?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    connect?: ProjectFollowingsWhereUniqueInput | ProjectFollowingsWhereUniqueInput[]
    update?: ProjectFollowingsUpdateWithWhereUniqueWithoutUsersInput | ProjectFollowingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectFollowingsUpdateManyWithWhereWithoutUsersInput | ProjectFollowingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
  }

  export type ProjectsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutUsersInput | ProjectsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ProjectsCreateManyUsersInputEnvelope
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutUsersInput | ProjectsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutUsersInput | ProjectsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput[]
    upsert?: UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInputEnvelope
    set?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    disconnect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    delete?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    update?: UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput[]
    updateMany?: UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsFollowingIdTousersInput | UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsFollowingIdTousersInput[]
    deleteMany?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
  }

  export type UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput = {
    create?: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput> | UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput[] | UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput[]
    connectOrCreate?: UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput[]
    upsert?: UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput[]
    createMany?: UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInputEnvelope
    set?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    disconnect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    delete?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    connect?: UserFollowingsWhereUniqueInput | UserFollowingsWhereUniqueInput[]
    update?: UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput[]
    updateMany?: UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsUserIdTousersInput | UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsUserIdTousersInput[]
    deleteMany?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
  }

  export type UserSkillsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput> | UserSkillsCreateWithoutUsersInput[] | UserSkillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUsersInput | UserSkillsCreateOrConnectWithoutUsersInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutUsersInput | UserSkillsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSkillsCreateManyUsersInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutUsersInput | UserSkillsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutUsersInput | UserSkillsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type UserSocialsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput> | UserSocialsCreateWithoutUsersInput[] | UserSocialsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSocialsCreateOrConnectWithoutUsersInput | UserSocialsCreateOrConnectWithoutUsersInput[]
    upsert?: UserSocialsUpsertWithWhereUniqueWithoutUsersInput | UserSocialsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSocialsCreateManyUsersInputEnvelope
    set?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    disconnect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    delete?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    connect?: UserSocialsWhereUniqueInput | UserSocialsWhereUniqueInput[]
    update?: UserSocialsUpdateWithWhereUniqueWithoutUsersInput | UserSocialsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSocialsUpdateManyWithWhereWithoutUsersInput | UserSocialsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
  }

  export type UserSkillsCreateNestedManyWithoutSkillsInput = {
    create?: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput> | UserSkillsCreateWithoutSkillsInput[] | UserSkillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillsInput | UserSkillsCreateOrConnectWithoutSkillsInput[]
    createMany?: UserSkillsCreateManySkillsInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type UserSkillsUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput> | UserSkillsCreateWithoutSkillsInput[] | UserSkillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillsInput | UserSkillsCreateOrConnectWithoutSkillsInput[]
    createMany?: UserSkillsCreateManySkillsInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type UserSkillsUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput> | UserSkillsCreateWithoutSkillsInput[] | UserSkillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillsInput | UserSkillsCreateOrConnectWithoutSkillsInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutSkillsInput | UserSkillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: UserSkillsCreateManySkillsInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutSkillsInput | UserSkillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutSkillsInput | UserSkillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type UserSkillsUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput> | UserSkillsCreateWithoutSkillsInput[] | UserSkillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillsInput | UserSkillsCreateOrConnectWithoutSkillsInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutSkillsInput | UserSkillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: UserSkillsCreateManySkillsInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutSkillsInput | UserSkillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutSkillsInput | UserSkillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumJobsAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsAvailability | EnumJobsAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.JobsAvailability[]
    notIn?: $Enums.JobsAvailability[]
    not?: NestedEnumJobsAvailabilityFilter<$PrismaModel> | $Enums.JobsAvailability
  }

  export type NestedEnumJobsDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsDuration | EnumJobsDurationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsDuration[]
    notIn?: $Enums.JobsDuration[]
    not?: NestedEnumJobsDurationFilter<$PrismaModel> | $Enums.JobsDuration
  }

  export type NestedEnumJobsLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsLocation | EnumJobsLocationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsLocation[]
    notIn?: $Enums.JobsLocation[]
    not?: NestedEnumJobsLocationFilter<$PrismaModel> | $Enums.JobsLocation
  }

  export type NestedEnumJobsCompensationFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsCompensation | EnumJobsCompensationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsCompensation[]
    notIn?: $Enums.JobsCompensation[]
    not?: NestedEnumJobsCompensationFilter<$PrismaModel> | $Enums.JobsCompensation
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumJobsAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsAvailability | EnumJobsAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.JobsAvailability[]
    notIn?: $Enums.JobsAvailability[]
    not?: NestedEnumJobsAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.JobsAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumJobsAvailabilityFilter<$PrismaModel>
  }

  export type NestedEnumJobsDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsDuration | EnumJobsDurationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsDuration[]
    notIn?: $Enums.JobsDuration[]
    not?: NestedEnumJobsDurationWithAggregatesFilter<$PrismaModel> | $Enums.JobsDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsDurationFilter<$PrismaModel>
    _max?: NestedEnumJobsDurationFilter<$PrismaModel>
  }

  export type NestedEnumJobsLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsLocation | EnumJobsLocationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsLocation[]
    notIn?: $Enums.JobsLocation[]
    not?: NestedEnumJobsLocationWithAggregatesFilter<$PrismaModel> | $Enums.JobsLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsLocationFilter<$PrismaModel>
    _max?: NestedEnumJobsLocationFilter<$PrismaModel>
  }

  export type NestedEnumJobsCompensationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsCompensation | EnumJobsCompensationFieldRefInput<$PrismaModel>
    in?: $Enums.JobsCompensation[]
    notIn?: $Enums.JobsCompensation[]
    not?: NestedEnumJobsCompensationWithAggregatesFilter<$PrismaModel> | $Enums.JobsCompensation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsCompensationFilter<$PrismaModel>
    _max?: NestedEnumJobsCompensationFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMembersProfileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.MembersProfileVisibility | EnumMembersProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.MembersProfileVisibility[]
    notIn?: $Enums.MembersProfileVisibility[]
    not?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel> | $Enums.MembersProfileVisibility
  }

  export type NestedEnumMembersProfileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembersProfileVisibility | EnumMembersProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.MembersProfileVisibility[]
    notIn?: $Enums.MembersProfileVisibility[]
    not?: NestedEnumMembersProfileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.MembersProfileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumMembersProfileVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumProjectsPurposeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsPurpose | EnumProjectsPurposeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectsPurpose[] | null
    notIn?: $Enums.ProjectsPurpose[] | null
    not?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel> | $Enums.ProjectsPurpose | null
  }

  export type NestedEnumProjectsStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsStatus | EnumProjectsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectsStatus[]
    notIn?: $Enums.ProjectsStatus[]
    not?: NestedEnumProjectsStatusFilter<$PrismaModel> | $Enums.ProjectsStatus
  }

  export type NestedEnumProjectsPurposeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsPurpose | EnumProjectsPurposeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectsPurpose[] | null
    notIn?: $Enums.ProjectsPurpose[] | null
    not?: NestedEnumProjectsPurposeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProjectsPurpose | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel>
    _max?: NestedEnumProjectsPurposeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectsStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectsStatus | EnumProjectsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectsStatus[]
    notIn?: $Enums.ProjectsStatus[]
    not?: NestedEnumProjectsStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectsStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectsStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectsStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUsersAcademicYearNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UsersAcademicYear | EnumUsersAcademicYearFieldRefInput<$PrismaModel> | null
    in?: $Enums.UsersAcademicYear[] | null
    notIn?: $Enums.UsersAcademicYear[] | null
    not?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel> | $Enums.UsersAcademicYear | null
  }

  export type NestedEnumUsersAcademicYearNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsersAcademicYear | EnumUsersAcademicYearFieldRefInput<$PrismaModel> | null
    in?: $Enums.UsersAcademicYear[] | null
    notIn?: $Enums.UsersAcademicYear[] | null
    not?: NestedEnumUsersAcademicYearNullableWithAggregatesFilter<$PrismaModel> | $Enums.UsersAcademicYear | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel>
    _max?: NestedEnumUsersAcademicYearNullableFilter<$PrismaModel>
  }

  export type ProjectGenresCreateWithoutGenresInput = {
    projects: ProjectsCreateNestedOneWithoutProjectGenresInput
  }

  export type ProjectGenresUncheckedCreateWithoutGenresInput = {
    projectId: number
  }

  export type ProjectGenresCreateOrConnectWithoutGenresInput = {
    where: ProjectGenresWhereUniqueInput
    create: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput>
  }

  export type ProjectGenresCreateManyGenresInputEnvelope = {
    data: ProjectGenresCreateManyGenresInput | ProjectGenresCreateManyGenresInput[]
    skipDuplicates?: boolean
  }

  export type ProjectGenresUpsertWithWhereUniqueWithoutGenresInput = {
    where: ProjectGenresWhereUniqueInput
    update: XOR<ProjectGenresUpdateWithoutGenresInput, ProjectGenresUncheckedUpdateWithoutGenresInput>
    create: XOR<ProjectGenresCreateWithoutGenresInput, ProjectGenresUncheckedCreateWithoutGenresInput>
  }

  export type ProjectGenresUpdateWithWhereUniqueWithoutGenresInput = {
    where: ProjectGenresWhereUniqueInput
    data: XOR<ProjectGenresUpdateWithoutGenresInput, ProjectGenresUncheckedUpdateWithoutGenresInput>
  }

  export type ProjectGenresUpdateManyWithWhereWithoutGenresInput = {
    where: ProjectGenresScalarWhereInput
    data: XOR<ProjectGenresUpdateManyMutationInput, ProjectGenresUncheckedUpdateManyWithoutGenresInput>
  }

  export type ProjectGenresScalarWhereInput = {
    AND?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
    OR?: ProjectGenresScalarWhereInput[]
    NOT?: ProjectGenresScalarWhereInput | ProjectGenresScalarWhereInput[]
    projectId?: IntFilter<"ProjectGenres"> | number
    typeId?: IntFilter<"ProjectGenres"> | number
  }

  export type JobsCreateWithoutJobTitlesInput = {
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects: ProjectsCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutJobTitlesInput = {
    projectId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobsCreateOrConnectWithoutJobTitlesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput>
  }

  export type JobsCreateManyJobTitlesInputEnvelope = {
    data: JobsCreateManyJobTitlesInput | JobsCreateManyJobTitlesInput[]
    skipDuplicates?: boolean
  }

  export type MembersCreateWithoutJobTitlesInput = {
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
    projects: ProjectsCreateNestedOneWithoutMembersInput
    users: UsersCreateNestedOneWithoutMembersInput
  }

  export type MembersUncheckedCreateWithoutJobTitlesInput = {
    projectId: number
    userId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type MembersCreateOrConnectWithoutJobTitlesInput = {
    where: MembersWhereUniqueInput
    create: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput>
  }

  export type MembersCreateManyJobTitlesInputEnvelope = {
    data: MembersCreateManyJobTitlesInput | MembersCreateManyJobTitlesInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutJobTitlesInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutJobTitlesInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutJobTitlesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput>
  }

  export type UsersCreateManyJobTitlesInputEnvelope = {
    data: UsersCreateManyJobTitlesInput | UsersCreateManyJobTitlesInput[]
    skipDuplicates?: boolean
  }

  export type JobsUpsertWithWhereUniqueWithoutJobTitlesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutJobTitlesInput, JobsUncheckedUpdateWithoutJobTitlesInput>
    create: XOR<JobsCreateWithoutJobTitlesInput, JobsUncheckedCreateWithoutJobTitlesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutJobTitlesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutJobTitlesInput, JobsUncheckedUpdateWithoutJobTitlesInput>
  }

  export type JobsUpdateManyWithWhereWithoutJobTitlesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobTitlesInput>
  }

  export type JobsScalarWhereInput = {
    AND?: JobsScalarWhereInput | JobsScalarWhereInput[]
    OR?: JobsScalarWhereInput[]
    NOT?: JobsScalarWhereInput | JobsScalarWhereInput[]
    projectId?: IntFilter<"Jobs"> | number
    titleId?: IntFilter<"Jobs"> | number
    availability?: EnumJobsAvailabilityFilter<"Jobs"> | $Enums.JobsAvailability
    duration?: EnumJobsDurationFilter<"Jobs"> | $Enums.JobsDuration
    location?: EnumJobsLocationFilter<"Jobs"> | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFilter<"Jobs"> | $Enums.JobsCompensation
    description?: StringNullableFilter<"Jobs"> | string | null
    createdAt?: DateTimeFilter<"Jobs"> | Date | string
    updatedAt?: DateTimeFilter<"Jobs"> | Date | string
  }

  export type MembersUpsertWithWhereUniqueWithoutJobTitlesInput = {
    where: MembersWhereUniqueInput
    update: XOR<MembersUpdateWithoutJobTitlesInput, MembersUncheckedUpdateWithoutJobTitlesInput>
    create: XOR<MembersCreateWithoutJobTitlesInput, MembersUncheckedCreateWithoutJobTitlesInput>
  }

  export type MembersUpdateWithWhereUniqueWithoutJobTitlesInput = {
    where: MembersWhereUniqueInput
    data: XOR<MembersUpdateWithoutJobTitlesInput, MembersUncheckedUpdateWithoutJobTitlesInput>
  }

  export type MembersUpdateManyWithWhereWithoutJobTitlesInput = {
    where: MembersScalarWhereInput
    data: XOR<MembersUpdateManyMutationInput, MembersUncheckedUpdateManyWithoutJobTitlesInput>
  }

  export type MembersScalarWhereInput = {
    AND?: MembersScalarWhereInput | MembersScalarWhereInput[]
    OR?: MembersScalarWhereInput[]
    NOT?: MembersScalarWhereInput | MembersScalarWhereInput[]
    projectId?: IntFilter<"Members"> | number
    userId?: IntFilter<"Members"> | number
    titleId?: IntFilter<"Members"> | number
    profileVisibility?: EnumMembersProfileVisibilityFilter<"Members"> | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFilter<"Members"> | Date | string
  }

  export type UsersUpsertWithWhereUniqueWithoutJobTitlesInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutJobTitlesInput, UsersUncheckedUpdateWithoutJobTitlesInput>
    create: XOR<UsersCreateWithoutJobTitlesInput, UsersUncheckedCreateWithoutJobTitlesInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutJobTitlesInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutJobTitlesInput, UsersUncheckedUpdateWithoutJobTitlesInput>
  }

  export type UsersUpdateManyWithWhereWithoutJobTitlesInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutJobTitlesInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    userId?: IntFilter<"Users"> | number
    username?: StringFilter<"Users"> | string
    ritEmail?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    profileImage?: StringNullableFilter<"Users"> | string | null
    headline?: StringNullableFilter<"Users"> | string | null
    pronouns?: StringNullableFilter<"Users"> | string | null
    jobTitleId?: IntNullableFilter<"Users"> | number | null
    majorId?: IntNullableFilter<"Users"> | number | null
    academicYear?: EnumUsersAcademicYearNullableFilter<"Users"> | $Enums.UsersAcademicYear | null
    location?: StringNullableFilter<"Users"> | string | null
    funFact?: StringNullableFilter<"Users"> | string | null
    bio?: StringNullableFilter<"Users"> | string | null
    visibility?: IntFilter<"Users"> | number
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    phoneNumber?: IntNullableFilter<"Users"> | number | null
    universityId?: StringNullableFilter<"Users"> | string | null
  }

  export type ProjectsCreateWithoutJobsInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutJobsInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutJobsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutJobsInput, ProjectsUncheckedCreateWithoutJobsInput>
  }

  export type JobTitlesCreateWithoutJobsInput = {
    label: string
    members?: MembersCreateNestedManyWithoutJobTitlesInput
    users?: UsersCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesUncheckedCreateWithoutJobsInput = {
    titleId?: number
    label: string
    members?: MembersUncheckedCreateNestedManyWithoutJobTitlesInput
    users?: UsersUncheckedCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesCreateOrConnectWithoutJobsInput = {
    where: JobTitlesWhereUniqueInput
    create: XOR<JobTitlesCreateWithoutJobsInput, JobTitlesUncheckedCreateWithoutJobsInput>
  }

  export type ProjectsUpsertWithoutJobsInput = {
    update: XOR<ProjectsUpdateWithoutJobsInput, ProjectsUncheckedUpdateWithoutJobsInput>
    create: XOR<ProjectsCreateWithoutJobsInput, ProjectsUncheckedCreateWithoutJobsInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutJobsInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutJobsInput, ProjectsUncheckedUpdateWithoutJobsInput>
  }

  export type ProjectsUpdateWithoutJobsInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutJobsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type JobTitlesUpsertWithoutJobsInput = {
    update: XOR<JobTitlesUpdateWithoutJobsInput, JobTitlesUncheckedUpdateWithoutJobsInput>
    create: XOR<JobTitlesCreateWithoutJobsInput, JobTitlesUncheckedCreateWithoutJobsInput>
    where?: JobTitlesWhereInput
  }

  export type JobTitlesUpdateToOneWithWhereWithoutJobsInput = {
    where?: JobTitlesWhereInput
    data: XOR<JobTitlesUpdateWithoutJobsInput, JobTitlesUncheckedUpdateWithoutJobsInput>
  }

  export type JobTitlesUpdateWithoutJobsInput = {
    label?: StringFieldUpdateOperationsInput | string
    members?: MembersUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUpdateManyWithoutJobTitlesNestedInput
  }

  export type JobTitlesUncheckedUpdateWithoutJobsInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    members?: MembersUncheckedUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUncheckedUpdateManyWithoutJobTitlesNestedInput
  }

  export type UsersCreateWithoutMajorsInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMajorsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMajorsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput>
  }

  export type UsersCreateManyMajorsInputEnvelope = {
    data: UsersCreateManyMajorsInput | UsersCreateManyMajorsInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutMajorsInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutMajorsInput, UsersUncheckedUpdateWithoutMajorsInput>
    create: XOR<UsersCreateWithoutMajorsInput, UsersUncheckedCreateWithoutMajorsInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutMajorsInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutMajorsInput, UsersUncheckedUpdateWithoutMajorsInput>
  }

  export type UsersUpdateManyWithWhereWithoutMajorsInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutMajorsInput>
  }

  export type JobTitlesCreateWithoutMembersInput = {
    label: string
    jobs?: JobsCreateNestedManyWithoutJobTitlesInput
    users?: UsersCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesUncheckedCreateWithoutMembersInput = {
    titleId?: number
    label: string
    jobs?: JobsUncheckedCreateNestedManyWithoutJobTitlesInput
    users?: UsersUncheckedCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesCreateOrConnectWithoutMembersInput = {
    where: JobTitlesWhereUniqueInput
    create: XOR<JobTitlesCreateWithoutMembersInput, JobTitlesUncheckedCreateWithoutMembersInput>
  }

  export type ProjectsCreateWithoutMembersInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutMembersInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutMembersInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutMembersInput, ProjectsUncheckedCreateWithoutMembersInput>
  }

  export type UsersCreateWithoutMembersInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMembersInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMembersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMembersInput, UsersUncheckedCreateWithoutMembersInput>
  }

  export type JobTitlesUpsertWithoutMembersInput = {
    update: XOR<JobTitlesUpdateWithoutMembersInput, JobTitlesUncheckedUpdateWithoutMembersInput>
    create: XOR<JobTitlesCreateWithoutMembersInput, JobTitlesUncheckedCreateWithoutMembersInput>
    where?: JobTitlesWhereInput
  }

  export type JobTitlesUpdateToOneWithWhereWithoutMembersInput = {
    where?: JobTitlesWhereInput
    data: XOR<JobTitlesUpdateWithoutMembersInput, JobTitlesUncheckedUpdateWithoutMembersInput>
  }

  export type JobTitlesUpdateWithoutMembersInput = {
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUpdateManyWithoutJobTitlesNestedInput
  }

  export type JobTitlesUncheckedUpdateWithoutMembersInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUncheckedUpdateManyWithoutJobTitlesNestedInput
    users?: UsersUncheckedUpdateManyWithoutJobTitlesNestedInput
  }

  export type ProjectsUpsertWithoutMembersInput = {
    update: XOR<ProjectsUpdateWithoutMembersInput, ProjectsUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectsCreateWithoutMembersInput, ProjectsUncheckedCreateWithoutMembersInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutMembersInput, ProjectsUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectsUpdateWithoutMembersInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutMembersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UsersUpsertWithoutMembersInput = {
    update: XOR<UsersUpdateWithoutMembersInput, UsersUncheckedUpdateWithoutMembersInput>
    create: XOR<UsersCreateWithoutMembersInput, UsersUncheckedCreateWithoutMembersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMembersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMembersInput, UsersUncheckedUpdateWithoutMembersInput>
  }

  export type UsersUpdateWithoutMembersInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMembersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ProjectsCreateWithoutProjectFollowingsInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectFollowingsInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectFollowingsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectFollowingsInput, ProjectsUncheckedCreateWithoutProjectFollowingsInput>
  }

  export type UsersCreateWithoutProjectFollowingsInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutProjectFollowingsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutProjectFollowingsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutProjectFollowingsInput, UsersUncheckedCreateWithoutProjectFollowingsInput>
  }

  export type ProjectsUpsertWithoutProjectFollowingsInput = {
    update: XOR<ProjectsUpdateWithoutProjectFollowingsInput, ProjectsUncheckedUpdateWithoutProjectFollowingsInput>
    create: XOR<ProjectsCreateWithoutProjectFollowingsInput, ProjectsUncheckedCreateWithoutProjectFollowingsInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutProjectFollowingsInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutProjectFollowingsInput, ProjectsUncheckedUpdateWithoutProjectFollowingsInput>
  }

  export type ProjectsUpdateWithoutProjectFollowingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectFollowingsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UsersUpsertWithoutProjectFollowingsInput = {
    update: XOR<UsersUpdateWithoutProjectFollowingsInput, UsersUncheckedUpdateWithoutProjectFollowingsInput>
    create: XOR<UsersCreateWithoutProjectFollowingsInput, UsersUncheckedCreateWithoutProjectFollowingsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutProjectFollowingsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutProjectFollowingsInput, UsersUncheckedUpdateWithoutProjectFollowingsInput>
  }

  export type UsersUpdateWithoutProjectFollowingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutProjectFollowingsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type GenresCreateWithoutProjectGenresInput = {
    label: string
  }

  export type GenresUncheckedCreateWithoutProjectGenresInput = {
    typeId?: number
    label: string
  }

  export type GenresCreateOrConnectWithoutProjectGenresInput = {
    where: GenresWhereUniqueInput
    create: XOR<GenresCreateWithoutProjectGenresInput, GenresUncheckedCreateWithoutProjectGenresInput>
  }

  export type ProjectsCreateWithoutProjectGenresInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectGenresInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectGenresInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectGenresInput, ProjectsUncheckedCreateWithoutProjectGenresInput>
  }

  export type GenresUpsertWithoutProjectGenresInput = {
    update: XOR<GenresUpdateWithoutProjectGenresInput, GenresUncheckedUpdateWithoutProjectGenresInput>
    create: XOR<GenresCreateWithoutProjectGenresInput, GenresUncheckedCreateWithoutProjectGenresInput>
    where?: GenresWhereInput
  }

  export type GenresUpdateToOneWithWhereWithoutProjectGenresInput = {
    where?: GenresWhereInput
    data: XOR<GenresUpdateWithoutProjectGenresInput, GenresUncheckedUpdateWithoutProjectGenresInput>
  }

  export type GenresUpdateWithoutProjectGenresInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type GenresUncheckedUpdateWithoutProjectGenresInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectsUpsertWithoutProjectGenresInput = {
    update: XOR<ProjectsUpdateWithoutProjectGenresInput, ProjectsUncheckedUpdateWithoutProjectGenresInput>
    create: XOR<ProjectsCreateWithoutProjectGenresInput, ProjectsUncheckedCreateWithoutProjectGenresInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutProjectGenresInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutProjectGenresInput, ProjectsUncheckedUpdateWithoutProjectGenresInput>
  }

  export type ProjectsUpdateWithoutProjectGenresInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectGenresInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectsCreateWithoutProjectImagesInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectImagesInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectImagesInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectImagesInput, ProjectsUncheckedCreateWithoutProjectImagesInput>
  }

  export type ProjectsUpsertWithoutProjectImagesInput = {
    update: XOR<ProjectsUpdateWithoutProjectImagesInput, ProjectsUncheckedUpdateWithoutProjectImagesInput>
    create: XOR<ProjectsCreateWithoutProjectImagesInput, ProjectsUncheckedCreateWithoutProjectImagesInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutProjectImagesInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutProjectImagesInput, ProjectsUncheckedUpdateWithoutProjectImagesInput>
  }

  export type ProjectsUpdateWithoutProjectImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectImagesInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectsCreateWithoutProjectSocialsInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectSocialsInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectSocialsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectSocialsInput, ProjectsUncheckedCreateWithoutProjectSocialsInput>
  }

  export type SocialsCreateWithoutProjectSocialsInput = {
    label: string
    userSocials?: UserSocialsCreateNestedManyWithoutSocialsInput
  }

  export type SocialsUncheckedCreateWithoutProjectSocialsInput = {
    websiteId?: number
    label: string
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutSocialsInput
  }

  export type SocialsCreateOrConnectWithoutProjectSocialsInput = {
    where: SocialsWhereUniqueInput
    create: XOR<SocialsCreateWithoutProjectSocialsInput, SocialsUncheckedCreateWithoutProjectSocialsInput>
  }

  export type ProjectsUpsertWithoutProjectSocialsInput = {
    update: XOR<ProjectsUpdateWithoutProjectSocialsInput, ProjectsUncheckedUpdateWithoutProjectSocialsInput>
    create: XOR<ProjectsCreateWithoutProjectSocialsInput, ProjectsUncheckedCreateWithoutProjectSocialsInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutProjectSocialsInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutProjectSocialsInput, ProjectsUncheckedUpdateWithoutProjectSocialsInput>
  }

  export type ProjectsUpdateWithoutProjectSocialsInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectSocialsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type SocialsUpsertWithoutProjectSocialsInput = {
    update: XOR<SocialsUpdateWithoutProjectSocialsInput, SocialsUncheckedUpdateWithoutProjectSocialsInput>
    create: XOR<SocialsCreateWithoutProjectSocialsInput, SocialsUncheckedCreateWithoutProjectSocialsInput>
    where?: SocialsWhereInput
  }

  export type SocialsUpdateToOneWithWhereWithoutProjectSocialsInput = {
    where?: SocialsWhereInput
    data: XOR<SocialsUpdateWithoutProjectSocialsInput, SocialsUncheckedUpdateWithoutProjectSocialsInput>
  }

  export type SocialsUpdateWithoutProjectSocialsInput = {
    label?: StringFieldUpdateOperationsInput | string
    userSocials?: UserSocialsUpdateManyWithoutSocialsNestedInput
  }

  export type SocialsUncheckedUpdateWithoutProjectSocialsInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    userSocials?: UserSocialsUncheckedUpdateManyWithoutSocialsNestedInput
  }

  export type ProjectsCreateWithoutProjectTagsInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    users?: UsersCreateNestedOneWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectTagsInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectTagsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectTagsInput, ProjectsUncheckedCreateWithoutProjectTagsInput>
  }

  export type TagsCreateWithoutProjectTagsInput = {
    label: string
    type: string
  }

  export type TagsUncheckedCreateWithoutProjectTagsInput = {
    tagId?: number
    label: string
    type: string
  }

  export type TagsCreateOrConnectWithoutProjectTagsInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutProjectTagsInput, TagsUncheckedCreateWithoutProjectTagsInput>
  }

  export type ProjectsUpsertWithoutProjectTagsInput = {
    update: XOR<ProjectsUpdateWithoutProjectTagsInput, ProjectsUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<ProjectsCreateWithoutProjectTagsInput, ProjectsUncheckedCreateWithoutProjectTagsInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutProjectTagsInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutProjectTagsInput, ProjectsUncheckedUpdateWithoutProjectTagsInput>
  }

  export type ProjectsUpdateWithoutProjectTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    users?: UsersUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectTagsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type TagsUpsertWithoutProjectTagsInput = {
    update: XOR<TagsUpdateWithoutProjectTagsInput, TagsUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<TagsCreateWithoutProjectTagsInput, TagsUncheckedCreateWithoutProjectTagsInput>
    where?: TagsWhereInput
  }

  export type TagsUpdateToOneWithWhereWithoutProjectTagsInput = {
    where?: TagsWhereInput
    data: XOR<TagsUpdateWithoutProjectTagsInput, TagsUncheckedUpdateWithoutProjectTagsInput>
  }

  export type TagsUpdateWithoutProjectTagsInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateWithoutProjectTagsInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobsCreateWithoutProjectsInput = {
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobTitles: JobTitlesCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutProjectsInput = {
    titleId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobsCreateOrConnectWithoutProjectsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput>
  }

  export type JobsCreateManyProjectsInputEnvelope = {
    data: JobsCreateManyProjectsInput | JobsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type MembersCreateWithoutProjectsInput = {
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
    jobTitles: JobTitlesCreateNestedOneWithoutMembersInput
    users: UsersCreateNestedOneWithoutMembersInput
  }

  export type MembersUncheckedCreateWithoutProjectsInput = {
    userId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type MembersCreateOrConnectWithoutProjectsInput = {
    where: MembersWhereUniqueInput
    create: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput>
  }

  export type MembersCreateManyProjectsInputEnvelope = {
    data: MembersCreateManyProjectsInput | MembersCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectFollowingsCreateWithoutProjectsInput = {
    followedAt?: Date | string
    users: UsersCreateNestedOneWithoutProjectFollowingsInput
  }

  export type ProjectFollowingsUncheckedCreateWithoutProjectsInput = {
    userId: number
    followedAt?: Date | string
  }

  export type ProjectFollowingsCreateOrConnectWithoutProjectsInput = {
    where: ProjectFollowingsWhereUniqueInput
    create: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectFollowingsCreateManyProjectsInputEnvelope = {
    data: ProjectFollowingsCreateManyProjectsInput | ProjectFollowingsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectGenresCreateWithoutProjectsInput = {
    genres: GenresCreateNestedOneWithoutProjectGenresInput
  }

  export type ProjectGenresUncheckedCreateWithoutProjectsInput = {
    typeId: number
  }

  export type ProjectGenresCreateOrConnectWithoutProjectsInput = {
    where: ProjectGenresWhereUniqueInput
    create: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectGenresCreateManyProjectsInputEnvelope = {
    data: ProjectGenresCreateManyProjectsInput | ProjectGenresCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectImagesCreateWithoutProjectsInput = {
    image: string
    position: number
  }

  export type ProjectImagesUncheckedCreateWithoutProjectsInput = {
    imageId?: number
    image: string
    position: number
  }

  export type ProjectImagesCreateOrConnectWithoutProjectsInput = {
    where: ProjectImagesWhereUniqueInput
    create: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectImagesCreateManyProjectsInputEnvelope = {
    data: ProjectImagesCreateManyProjectsInput | ProjectImagesCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSocialsCreateWithoutProjectsInput = {
    url: string
    socials: SocialsCreateNestedOneWithoutProjectSocialsInput
  }

  export type ProjectSocialsUncheckedCreateWithoutProjectsInput = {
    websiteId: number
    url: string
  }

  export type ProjectSocialsCreateOrConnectWithoutProjectsInput = {
    where: ProjectSocialsWhereUniqueInput
    create: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectSocialsCreateManyProjectsInputEnvelope = {
    data: ProjectSocialsCreateManyProjectsInput | ProjectSocialsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTagsCreateWithoutProjectsInput = {
    position: number
    tags: TagsCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagsUncheckedCreateWithoutProjectsInput = {
    tagId: number
    position: number
  }

  export type ProjectTagsCreateOrConnectWithoutProjectsInput = {
    where: ProjectTagsWhereUniqueInput
    create: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTagsCreateManyProjectsInputEnvelope = {
    data: ProjectTagsCreateManyProjectsInput | ProjectTagsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutProjectsInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutProjectsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutProjectsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutProjectsInput, UsersUncheckedCreateWithoutProjectsInput>
  }

  export type JobsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutProjectsInput, JobsUncheckedUpdateWithoutProjectsInput>
    create: XOR<JobsCreateWithoutProjectsInput, JobsUncheckedCreateWithoutProjectsInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutProjectsInput, JobsUncheckedUpdateWithoutProjectsInput>
  }

  export type JobsUpdateManyWithWhereWithoutProjectsInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type MembersUpsertWithWhereUniqueWithoutProjectsInput = {
    where: MembersWhereUniqueInput
    update: XOR<MembersUpdateWithoutProjectsInput, MembersUncheckedUpdateWithoutProjectsInput>
    create: XOR<MembersCreateWithoutProjectsInput, MembersUncheckedCreateWithoutProjectsInput>
  }

  export type MembersUpdateWithWhereUniqueWithoutProjectsInput = {
    where: MembersWhereUniqueInput
    data: XOR<MembersUpdateWithoutProjectsInput, MembersUncheckedUpdateWithoutProjectsInput>
  }

  export type MembersUpdateManyWithWhereWithoutProjectsInput = {
    where: MembersScalarWhereInput
    data: XOR<MembersUpdateManyMutationInput, MembersUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectFollowingsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectFollowingsWhereUniqueInput
    update: XOR<ProjectFollowingsUpdateWithoutProjectsInput, ProjectFollowingsUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectFollowingsCreateWithoutProjectsInput, ProjectFollowingsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectFollowingsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectFollowingsWhereUniqueInput
    data: XOR<ProjectFollowingsUpdateWithoutProjectsInput, ProjectFollowingsUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectFollowingsUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectFollowingsScalarWhereInput
    data: XOR<ProjectFollowingsUpdateManyMutationInput, ProjectFollowingsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectFollowingsScalarWhereInput = {
    AND?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
    OR?: ProjectFollowingsScalarWhereInput[]
    NOT?: ProjectFollowingsScalarWhereInput | ProjectFollowingsScalarWhereInput[]
    userId?: IntFilter<"ProjectFollowings"> | number
    projectId?: IntFilter<"ProjectFollowings"> | number
    followedAt?: DateTimeFilter<"ProjectFollowings"> | Date | string
  }

  export type ProjectGenresUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectGenresWhereUniqueInput
    update: XOR<ProjectGenresUpdateWithoutProjectsInput, ProjectGenresUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectGenresCreateWithoutProjectsInput, ProjectGenresUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectGenresUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectGenresWhereUniqueInput
    data: XOR<ProjectGenresUpdateWithoutProjectsInput, ProjectGenresUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectGenresUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectGenresScalarWhereInput
    data: XOR<ProjectGenresUpdateManyMutationInput, ProjectGenresUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectImagesUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectImagesWhereUniqueInput
    update: XOR<ProjectImagesUpdateWithoutProjectsInput, ProjectImagesUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectImagesCreateWithoutProjectsInput, ProjectImagesUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectImagesUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectImagesWhereUniqueInput
    data: XOR<ProjectImagesUpdateWithoutProjectsInput, ProjectImagesUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectImagesUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectImagesScalarWhereInput
    data: XOR<ProjectImagesUpdateManyMutationInput, ProjectImagesUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectImagesScalarWhereInput = {
    AND?: ProjectImagesScalarWhereInput | ProjectImagesScalarWhereInput[]
    OR?: ProjectImagesScalarWhereInput[]
    NOT?: ProjectImagesScalarWhereInput | ProjectImagesScalarWhereInput[]
    imageId?: IntFilter<"ProjectImages"> | number
    image?: StringFilter<"ProjectImages"> | string
    position?: IntFilter<"ProjectImages"> | number
    projectId?: IntFilter<"ProjectImages"> | number
  }

  export type ProjectSocialsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectSocialsWhereUniqueInput
    update: XOR<ProjectSocialsUpdateWithoutProjectsInput, ProjectSocialsUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectSocialsCreateWithoutProjectsInput, ProjectSocialsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectSocialsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectSocialsWhereUniqueInput
    data: XOR<ProjectSocialsUpdateWithoutProjectsInput, ProjectSocialsUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectSocialsUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectSocialsScalarWhereInput
    data: XOR<ProjectSocialsUpdateManyMutationInput, ProjectSocialsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectSocialsScalarWhereInput = {
    AND?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
    OR?: ProjectSocialsScalarWhereInput[]
    NOT?: ProjectSocialsScalarWhereInput | ProjectSocialsScalarWhereInput[]
    projectId?: IntFilter<"ProjectSocials"> | number
    websiteId?: IntFilter<"ProjectSocials"> | number
    url?: StringFilter<"ProjectSocials"> | string
  }

  export type ProjectTagsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectTagsWhereUniqueInput
    update: XOR<ProjectTagsUpdateWithoutProjectsInput, ProjectTagsUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectTagsCreateWithoutProjectsInput, ProjectTagsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTagsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectTagsWhereUniqueInput
    data: XOR<ProjectTagsUpdateWithoutProjectsInput, ProjectTagsUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTagsUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectTagsScalarWhereInput
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectTagsScalarWhereInput = {
    AND?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
    OR?: ProjectTagsScalarWhereInput[]
    NOT?: ProjectTagsScalarWhereInput | ProjectTagsScalarWhereInput[]
    projectId?: IntFilter<"ProjectTags"> | number
    tagId?: IntFilter<"ProjectTags"> | number
    position?: IntFilter<"ProjectTags"> | number
  }

  export type UsersUpsertWithoutProjectsInput = {
    update: XOR<UsersUpdateWithoutProjectsInput, UsersUncheckedUpdateWithoutProjectsInput>
    create: XOR<UsersCreateWithoutProjectsInput, UsersUncheckedCreateWithoutProjectsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutProjectsInput, UsersUncheckedUpdateWithoutProjectsInput>
  }

  export type UsersUpdateWithoutProjectsInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutProjectsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ProjectSocialsCreateWithoutSocialsInput = {
    url: string
    projects: ProjectsCreateNestedOneWithoutProjectSocialsInput
  }

  export type ProjectSocialsUncheckedCreateWithoutSocialsInput = {
    projectId: number
    url: string
  }

  export type ProjectSocialsCreateOrConnectWithoutSocialsInput = {
    where: ProjectSocialsWhereUniqueInput
    create: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput>
  }

  export type ProjectSocialsCreateManySocialsInputEnvelope = {
    data: ProjectSocialsCreateManySocialsInput | ProjectSocialsCreateManySocialsInput[]
    skipDuplicates?: boolean
  }

  export type UserSocialsCreateWithoutSocialsInput = {
    url: string
    users: UsersCreateNestedOneWithoutUserSocialsInput
  }

  export type UserSocialsUncheckedCreateWithoutSocialsInput = {
    userId: number
    url: string
  }

  export type UserSocialsCreateOrConnectWithoutSocialsInput = {
    where: UserSocialsWhereUniqueInput
    create: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput>
  }

  export type UserSocialsCreateManySocialsInputEnvelope = {
    data: UserSocialsCreateManySocialsInput | UserSocialsCreateManySocialsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSocialsUpsertWithWhereUniqueWithoutSocialsInput = {
    where: ProjectSocialsWhereUniqueInput
    update: XOR<ProjectSocialsUpdateWithoutSocialsInput, ProjectSocialsUncheckedUpdateWithoutSocialsInput>
    create: XOR<ProjectSocialsCreateWithoutSocialsInput, ProjectSocialsUncheckedCreateWithoutSocialsInput>
  }

  export type ProjectSocialsUpdateWithWhereUniqueWithoutSocialsInput = {
    where: ProjectSocialsWhereUniqueInput
    data: XOR<ProjectSocialsUpdateWithoutSocialsInput, ProjectSocialsUncheckedUpdateWithoutSocialsInput>
  }

  export type ProjectSocialsUpdateManyWithWhereWithoutSocialsInput = {
    where: ProjectSocialsScalarWhereInput
    data: XOR<ProjectSocialsUpdateManyMutationInput, ProjectSocialsUncheckedUpdateManyWithoutSocialsInput>
  }

  export type UserSocialsUpsertWithWhereUniqueWithoutSocialsInput = {
    where: UserSocialsWhereUniqueInput
    update: XOR<UserSocialsUpdateWithoutSocialsInput, UserSocialsUncheckedUpdateWithoutSocialsInput>
    create: XOR<UserSocialsCreateWithoutSocialsInput, UserSocialsUncheckedCreateWithoutSocialsInput>
  }

  export type UserSocialsUpdateWithWhereUniqueWithoutSocialsInput = {
    where: UserSocialsWhereUniqueInput
    data: XOR<UserSocialsUpdateWithoutSocialsInput, UserSocialsUncheckedUpdateWithoutSocialsInput>
  }

  export type UserSocialsUpdateManyWithWhereWithoutSocialsInput = {
    where: UserSocialsScalarWhereInput
    data: XOR<UserSocialsUpdateManyMutationInput, UserSocialsUncheckedUpdateManyWithoutSocialsInput>
  }

  export type UserSocialsScalarWhereInput = {
    AND?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
    OR?: UserSocialsScalarWhereInput[]
    NOT?: UserSocialsScalarWhereInput | UserSocialsScalarWhereInput[]
    userId?: IntFilter<"UserSocials"> | number
    websiteId?: IntFilter<"UserSocials"> | number
    url?: StringFilter<"UserSocials"> | string
  }

  export type ProjectTagsCreateWithoutTagsInput = {
    position: number
    projects: ProjectsCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagsUncheckedCreateWithoutTagsInput = {
    projectId: number
    position: number
  }

  export type ProjectTagsCreateOrConnectWithoutTagsInput = {
    where: ProjectTagsWhereUniqueInput
    create: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput>
  }

  export type ProjectTagsCreateManyTagsInputEnvelope = {
    data: ProjectTagsCreateManyTagsInput | ProjectTagsCreateManyTagsInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTagsUpsertWithWhereUniqueWithoutTagsInput = {
    where: ProjectTagsWhereUniqueInput
    update: XOR<ProjectTagsUpdateWithoutTagsInput, ProjectTagsUncheckedUpdateWithoutTagsInput>
    create: XOR<ProjectTagsCreateWithoutTagsInput, ProjectTagsUncheckedCreateWithoutTagsInput>
  }

  export type ProjectTagsUpdateWithWhereUniqueWithoutTagsInput = {
    where: ProjectTagsWhereUniqueInput
    data: XOR<ProjectTagsUpdateWithoutTagsInput, ProjectTagsUncheckedUpdateWithoutTagsInput>
  }

  export type ProjectTagsUpdateManyWithWhereWithoutTagsInput = {
    where: ProjectTagsScalarWhereInput
    data: XOR<ProjectTagsUpdateManyMutationInput, ProjectTagsUncheckedUpdateManyWithoutTagsInput>
  }

  export type UsersCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
  }

  export type UsersCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
  }

  export type UsersUpsertWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    update: XOR<UsersUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
    create: XOR<UsersCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput>
  }

  export type UsersUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsFollowingIdTousersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    update: XOR<UsersUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
    create: XOR<UsersCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedCreateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput, UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput>
  }

  export type UsersUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserFollowingsUserFollowingsUserIdTousersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SkillsCreateWithoutUserSkillsInput = {
    label: string
    type: string
  }

  export type SkillsUncheckedCreateWithoutUserSkillsInput = {
    skillId?: number
    label: string
    type: string
  }

  export type SkillsCreateOrConnectWithoutUserSkillsInput = {
    where: SkillsWhereUniqueInput
    create: XOR<SkillsCreateWithoutUserSkillsInput, SkillsUncheckedCreateWithoutUserSkillsInput>
  }

  export type UsersCreateWithoutUserSkillsInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSocials?: UserSocialsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserSkillsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSocials?: UserSocialsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserSkillsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserSkillsInput, UsersUncheckedCreateWithoutUserSkillsInput>
  }

  export type SkillsUpsertWithoutUserSkillsInput = {
    update: XOR<SkillsUpdateWithoutUserSkillsInput, SkillsUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<SkillsCreateWithoutUserSkillsInput, SkillsUncheckedCreateWithoutUserSkillsInput>
    where?: SkillsWhereInput
  }

  export type SkillsUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: SkillsWhereInput
    data: XOR<SkillsUpdateWithoutUserSkillsInput, SkillsUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillsUpdateWithoutUserSkillsInput = {
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsUncheckedUpdateWithoutUserSkillsInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpsertWithoutUserSkillsInput = {
    update: XOR<UsersUpdateWithoutUserSkillsInput, UsersUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<UsersCreateWithoutUserSkillsInput, UsersUncheckedCreateWithoutUserSkillsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserSkillsInput, UsersUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UsersUpdateWithoutUserSkillsInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserSkillsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SocialsCreateWithoutUserSocialsInput = {
    label: string
    projectSocials?: ProjectSocialsCreateNestedManyWithoutSocialsInput
  }

  export type SocialsUncheckedCreateWithoutUserSocialsInput = {
    websiteId?: number
    label: string
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutSocialsInput
  }

  export type SocialsCreateOrConnectWithoutUserSocialsInput = {
    where: SocialsWhereUniqueInput
    create: XOR<SocialsCreateWithoutUserSocialsInput, SocialsUncheckedCreateWithoutUserSocialsInput>
  }

  export type UsersCreateWithoutUserSocialsInput = {
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsCreateNestedManyWithoutUsersInput
    jobTitles?: JobTitlesCreateNestedOneWithoutUsersInput
    majors?: MajorsCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserSocialsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
    members?: MembersUncheckedCreateNestedManyWithoutUsersInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsFollowingIdTousersInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedCreateNestedManyWithoutUsersUserFollowingsUserIdTousersInput
    userSkills?: UserSkillsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserSocialsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserSocialsInput, UsersUncheckedCreateWithoutUserSocialsInput>
  }

  export type SocialsUpsertWithoutUserSocialsInput = {
    update: XOR<SocialsUpdateWithoutUserSocialsInput, SocialsUncheckedUpdateWithoutUserSocialsInput>
    create: XOR<SocialsCreateWithoutUserSocialsInput, SocialsUncheckedCreateWithoutUserSocialsInput>
    where?: SocialsWhereInput
  }

  export type SocialsUpdateToOneWithWhereWithoutUserSocialsInput = {
    where?: SocialsWhereInput
    data: XOR<SocialsUpdateWithoutUserSocialsInput, SocialsUncheckedUpdateWithoutUserSocialsInput>
  }

  export type SocialsUpdateWithoutUserSocialsInput = {
    label?: StringFieldUpdateOperationsInput | string
    projectSocials?: ProjectSocialsUpdateManyWithoutSocialsNestedInput
  }

  export type SocialsUncheckedUpdateWithoutUserSocialsInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutSocialsNestedInput
  }

  export type UsersUpsertWithoutUserSocialsInput = {
    update: XOR<UsersUpdateWithoutUserSocialsInput, UsersUncheckedUpdateWithoutUserSocialsInput>
    create: XOR<UsersCreateWithoutUserSocialsInput, UsersUncheckedCreateWithoutUserSocialsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserSocialsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserSocialsInput, UsersUncheckedUpdateWithoutUserSocialsInput>
  }

  export type UsersUpdateWithoutUserSocialsInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserSocialsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type MembersCreateWithoutUsersInput = {
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
    jobTitles: JobTitlesCreateNestedOneWithoutMembersInput
    projects: ProjectsCreateNestedOneWithoutMembersInput
  }

  export type MembersUncheckedCreateWithoutUsersInput = {
    projectId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type MembersCreateOrConnectWithoutUsersInput = {
    where: MembersWhereUniqueInput
    create: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput>
  }

  export type MembersCreateManyUsersInputEnvelope = {
    data: MembersCreateManyUsersInput | MembersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ProjectFollowingsCreateWithoutUsersInput = {
    followedAt?: Date | string
    projects: ProjectsCreateNestedOneWithoutProjectFollowingsInput
  }

  export type ProjectFollowingsUncheckedCreateWithoutUsersInput = {
    projectId: number
    followedAt?: Date | string
  }

  export type ProjectFollowingsCreateOrConnectWithoutUsersInput = {
    where: ProjectFollowingsWhereUniqueInput
    create: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput>
  }

  export type ProjectFollowingsCreateManyUsersInputEnvelope = {
    data: ProjectFollowingsCreateManyUsersInput | ProjectFollowingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ProjectsCreateWithoutUsersInput = {
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsCreateNestedManyWithoutProjectsInput
    members?: MembersCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutUsersInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobsUncheckedCreateNestedManyWithoutProjectsInput
    members?: MembersUncheckedCreateNestedManyWithoutProjectsInput
    projectFollowings?: ProjectFollowingsUncheckedCreateNestedManyWithoutProjectsInput
    projectGenres?: ProjectGenresUncheckedCreateNestedManyWithoutProjectsInput
    projectImages?: ProjectImagesUncheckedCreateNestedManyWithoutProjectsInput
    projectSocials?: ProjectSocialsUncheckedCreateNestedManyWithoutProjectsInput
    projectTags?: ProjectTagsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput>
  }

  export type ProjectsCreateManyUsersInputEnvelope = {
    data: ProjectsCreateManyUsersInput | ProjectsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput = {
    followedAt?: Date | string
    usersUserFollowingsUserIdTousers: UsersCreateNestedOneWithoutUserFollowingsUserFollowingsUserIdTousersInput
  }

  export type UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput = {
    userId: number
    followedAt?: Date | string
  }

  export type UserFollowingsCreateOrConnectWithoutUsersUserFollowingsFollowingIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    create: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput>
  }

  export type UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInputEnvelope = {
    data: UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInput | UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput = {
    followedAt?: Date | string
    usersUserFollowingsFollowingIdTousers: UsersCreateNestedOneWithoutUserFollowingsUserFollowingsFollowingIdTousersInput
  }

  export type UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput = {
    followingId: number
    followedAt?: Date | string
  }

  export type UserFollowingsCreateOrConnectWithoutUsersUserFollowingsUserIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    create: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput>
  }

  export type UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInputEnvelope = {
    data: UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInput | UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillsCreateWithoutUsersInput = {
    position: number
    skills: SkillsCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillsUncheckedCreateWithoutUsersInput = {
    skillId: number
    position: number
  }

  export type UserSkillsCreateOrConnectWithoutUsersInput = {
    where: UserSkillsWhereUniqueInput
    create: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput>
  }

  export type UserSkillsCreateManyUsersInputEnvelope = {
    data: UserSkillsCreateManyUsersInput | UserSkillsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserSocialsCreateWithoutUsersInput = {
    url: string
    socials: SocialsCreateNestedOneWithoutUserSocialsInput
  }

  export type UserSocialsUncheckedCreateWithoutUsersInput = {
    websiteId: number
    url: string
  }

  export type UserSocialsCreateOrConnectWithoutUsersInput = {
    where: UserSocialsWhereUniqueInput
    create: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput>
  }

  export type UserSocialsCreateManyUsersInputEnvelope = {
    data: UserSocialsCreateManyUsersInput | UserSocialsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type JobTitlesCreateWithoutUsersInput = {
    label: string
    jobs?: JobsCreateNestedManyWithoutJobTitlesInput
    members?: MembersCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesUncheckedCreateWithoutUsersInput = {
    titleId?: number
    label: string
    jobs?: JobsUncheckedCreateNestedManyWithoutJobTitlesInput
    members?: MembersUncheckedCreateNestedManyWithoutJobTitlesInput
  }

  export type JobTitlesCreateOrConnectWithoutUsersInput = {
    where: JobTitlesWhereUniqueInput
    create: XOR<JobTitlesCreateWithoutUsersInput, JobTitlesUncheckedCreateWithoutUsersInput>
  }

  export type MajorsCreateWithoutUsersInput = {
    label: string
  }

  export type MajorsUncheckedCreateWithoutUsersInput = {
    majorId?: number
    label: string
  }

  export type MajorsCreateOrConnectWithoutUsersInput = {
    where: MajorsWhereUniqueInput
    create: XOR<MajorsCreateWithoutUsersInput, MajorsUncheckedCreateWithoutUsersInput>
  }

  export type MembersUpsertWithWhereUniqueWithoutUsersInput = {
    where: MembersWhereUniqueInput
    update: XOR<MembersUpdateWithoutUsersInput, MembersUncheckedUpdateWithoutUsersInput>
    create: XOR<MembersCreateWithoutUsersInput, MembersUncheckedCreateWithoutUsersInput>
  }

  export type MembersUpdateWithWhereUniqueWithoutUsersInput = {
    where: MembersWhereUniqueInput
    data: XOR<MembersUpdateWithoutUsersInput, MembersUncheckedUpdateWithoutUsersInput>
  }

  export type MembersUpdateManyWithWhereWithoutUsersInput = {
    where: MembersScalarWhereInput
    data: XOR<MembersUpdateManyMutationInput, MembersUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProjectFollowingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ProjectFollowingsWhereUniqueInput
    update: XOR<ProjectFollowingsUpdateWithoutUsersInput, ProjectFollowingsUncheckedUpdateWithoutUsersInput>
    create: XOR<ProjectFollowingsCreateWithoutUsersInput, ProjectFollowingsUncheckedCreateWithoutUsersInput>
  }

  export type ProjectFollowingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ProjectFollowingsWhereUniqueInput
    data: XOR<ProjectFollowingsUpdateWithoutUsersInput, ProjectFollowingsUncheckedUpdateWithoutUsersInput>
  }

  export type ProjectFollowingsUpdateManyWithWhereWithoutUsersInput = {
    where: ProjectFollowingsScalarWhereInput
    data: XOR<ProjectFollowingsUpdateManyMutationInput, ProjectFollowingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProjectsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    update: XOR<ProjectsUpdateWithoutUsersInput, ProjectsUncheckedUpdateWithoutUsersInput>
    create: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput>
  }

  export type ProjectsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    data: XOR<ProjectsUpdateWithoutUsersInput, ProjectsUncheckedUpdateWithoutUsersInput>
  }

  export type ProjectsUpdateManyWithWhereWithoutUsersInput = {
    where: ProjectsScalarWhereInput
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProjectsScalarWhereInput = {
    AND?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
    OR?: ProjectsScalarWhereInput[]
    NOT?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
    projectId?: IntFilter<"Projects"> | number
    title?: StringFilter<"Projects"> | string
    hook?: StringFilter<"Projects"> | string
    description?: StringFilter<"Projects"> | string
    thumbnail?: StringNullableFilter<"Projects"> | string | null
    purpose?: EnumProjectsPurposeNullableFilter<"Projects"> | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFilter<"Projects"> | $Enums.ProjectsStatus
    audience?: StringNullableFilter<"Projects"> | string | null
    userId?: IntNullableFilter<"Projects"> | number | null
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
  }

  export type UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    update: XOR<UserFollowingsUpdateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsFollowingIdTousersInput>
    create: XOR<UserFollowingsCreateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsFollowingIdTousersInput>
  }

  export type UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsFollowingIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    data: XOR<UserFollowingsUpdateWithoutUsersUserFollowingsFollowingIdTousersInput, UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsFollowingIdTousersInput>
  }

  export type UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsFollowingIdTousersInput = {
    where: UserFollowingsScalarWhereInput
    data: XOR<UserFollowingsUpdateManyMutationInput, UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersInput>
  }

  export type UserFollowingsScalarWhereInput = {
    AND?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
    OR?: UserFollowingsScalarWhereInput[]
    NOT?: UserFollowingsScalarWhereInput | UserFollowingsScalarWhereInput[]
    userId?: IntFilter<"UserFollowings"> | number
    followingId?: IntFilter<"UserFollowings"> | number
    followedAt?: DateTimeFilter<"UserFollowings"> | Date | string
  }

  export type UserFollowingsUpsertWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    update: XOR<UserFollowingsUpdateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsUserIdTousersInput>
    create: XOR<UserFollowingsCreateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedCreateWithoutUsersUserFollowingsUserIdTousersInput>
  }

  export type UserFollowingsUpdateWithWhereUniqueWithoutUsersUserFollowingsUserIdTousersInput = {
    where: UserFollowingsWhereUniqueInput
    data: XOR<UserFollowingsUpdateWithoutUsersUserFollowingsUserIdTousersInput, UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsUserIdTousersInput>
  }

  export type UserFollowingsUpdateManyWithWhereWithoutUsersUserFollowingsUserIdTousersInput = {
    where: UserFollowingsScalarWhereInput
    data: XOR<UserFollowingsUpdateManyMutationInput, UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersInput>
  }

  export type UserSkillsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserSkillsWhereUniqueInput
    update: XOR<UserSkillsUpdateWithoutUsersInput, UserSkillsUncheckedUpdateWithoutUsersInput>
    create: XOR<UserSkillsCreateWithoutUsersInput, UserSkillsUncheckedCreateWithoutUsersInput>
  }

  export type UserSkillsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserSkillsWhereUniqueInput
    data: XOR<UserSkillsUpdateWithoutUsersInput, UserSkillsUncheckedUpdateWithoutUsersInput>
  }

  export type UserSkillsUpdateManyWithWhereWithoutUsersInput = {
    where: UserSkillsScalarWhereInput
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserSkillsScalarWhereInput = {
    AND?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
    OR?: UserSkillsScalarWhereInput[]
    NOT?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
    userId?: IntFilter<"UserSkills"> | number
    skillId?: IntFilter<"UserSkills"> | number
    position?: IntFilter<"UserSkills"> | number
  }

  export type UserSocialsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserSocialsWhereUniqueInput
    update: XOR<UserSocialsUpdateWithoutUsersInput, UserSocialsUncheckedUpdateWithoutUsersInput>
    create: XOR<UserSocialsCreateWithoutUsersInput, UserSocialsUncheckedCreateWithoutUsersInput>
  }

  export type UserSocialsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserSocialsWhereUniqueInput
    data: XOR<UserSocialsUpdateWithoutUsersInput, UserSocialsUncheckedUpdateWithoutUsersInput>
  }

  export type UserSocialsUpdateManyWithWhereWithoutUsersInput = {
    where: UserSocialsScalarWhereInput
    data: XOR<UserSocialsUpdateManyMutationInput, UserSocialsUncheckedUpdateManyWithoutUsersInput>
  }

  export type JobTitlesUpsertWithoutUsersInput = {
    update: XOR<JobTitlesUpdateWithoutUsersInput, JobTitlesUncheckedUpdateWithoutUsersInput>
    create: XOR<JobTitlesCreateWithoutUsersInput, JobTitlesUncheckedCreateWithoutUsersInput>
    where?: JobTitlesWhereInput
  }

  export type JobTitlesUpdateToOneWithWhereWithoutUsersInput = {
    where?: JobTitlesWhereInput
    data: XOR<JobTitlesUpdateWithoutUsersInput, JobTitlesUncheckedUpdateWithoutUsersInput>
  }

  export type JobTitlesUpdateWithoutUsersInput = {
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUpdateManyWithoutJobTitlesNestedInput
    members?: MembersUpdateManyWithoutJobTitlesNestedInput
  }

  export type JobTitlesUncheckedUpdateWithoutUsersInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    jobs?: JobsUncheckedUpdateManyWithoutJobTitlesNestedInput
    members?: MembersUncheckedUpdateManyWithoutJobTitlesNestedInput
  }

  export type MajorsUpsertWithoutUsersInput = {
    update: XOR<MajorsUpdateWithoutUsersInput, MajorsUncheckedUpdateWithoutUsersInput>
    create: XOR<MajorsCreateWithoutUsersInput, MajorsUncheckedCreateWithoutUsersInput>
    where?: MajorsWhereInput
  }

  export type MajorsUpdateToOneWithWhereWithoutUsersInput = {
    where?: MajorsWhereInput
    data: XOR<MajorsUpdateWithoutUsersInput, MajorsUncheckedUpdateWithoutUsersInput>
  }

  export type MajorsUpdateWithoutUsersInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type MajorsUncheckedUpdateWithoutUsersInput = {
    majorId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkillsCreateWithoutSkillsInput = {
    position: number
    users: UsersCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillsUncheckedCreateWithoutSkillsInput = {
    userId: number
    position: number
  }

  export type UserSkillsCreateOrConnectWithoutSkillsInput = {
    where: UserSkillsWhereUniqueInput
    create: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput>
  }

  export type UserSkillsCreateManySkillsInputEnvelope = {
    data: UserSkillsCreateManySkillsInput | UserSkillsCreateManySkillsInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillsUpsertWithWhereUniqueWithoutSkillsInput = {
    where: UserSkillsWhereUniqueInput
    update: XOR<UserSkillsUpdateWithoutSkillsInput, UserSkillsUncheckedUpdateWithoutSkillsInput>
    create: XOR<UserSkillsCreateWithoutSkillsInput, UserSkillsUncheckedCreateWithoutSkillsInput>
  }

  export type UserSkillsUpdateWithWhereUniqueWithoutSkillsInput = {
    where: UserSkillsWhereUniqueInput
    data: XOR<UserSkillsUpdateWithoutSkillsInput, UserSkillsUncheckedUpdateWithoutSkillsInput>
  }

  export type UserSkillsUpdateManyWithWhereWithoutSkillsInput = {
    where: UserSkillsScalarWhereInput
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyWithoutSkillsInput>
  }

  export type ProjectGenresCreateManyGenresInput = {
    projectId: number
  }

  export type ProjectGenresUpdateWithoutGenresInput = {
    projects?: ProjectsUpdateOneRequiredWithoutProjectGenresNestedInput
  }

  export type ProjectGenresUncheckedUpdateWithoutGenresInput = {
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectGenresUncheckedUpdateManyWithoutGenresInput = {
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type JobsCreateManyJobTitlesInput = {
    projectId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembersCreateManyJobTitlesInput = {
    projectId: number
    userId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type UsersCreateManyJobTitlesInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    majorId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
  }

  export type JobsUpdateWithoutJobTitlesInput = {
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectsUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutJobTitlesInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUncheckedUpdateManyWithoutJobTitlesInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUpdateWithoutJobTitlesInput = {
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectsUpdateOneRequiredWithoutMembersNestedInput
    users?: UsersUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MembersUncheckedUpdateWithoutJobTitlesInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUncheckedUpdateManyWithoutJobTitlesInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpdateWithoutJobTitlesInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    majors?: MajorsUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutJobTitlesInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutJobTitlesInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateManyMajorsInput = {
    userId?: number
    username: string
    ritEmail: string
    firstName: string
    lastName: string
    profileImage?: string | null
    headline?: string | null
    pronouns?: string | null
    jobTitleId?: number | null
    academicYear?: $Enums.UsersAcademicYear | null
    location?: string | null
    funFact?: string | null
    bio?: string | null
    visibility?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: number | null
    universityId?: string | null
  }

  export type UsersUpdateWithoutMajorsInput = {
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUpdateManyWithoutUsersNestedInput
    jobTitles?: JobTitlesUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMajorsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MembersUncheckedUpdateManyWithoutUsersNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    userFollowingsUserFollowingsFollowingIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersNestedInput
    userFollowingsUserFollowingsUserIdTousers?: UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersNestedInput
    userSkills?: UserSkillsUncheckedUpdateManyWithoutUsersNestedInput
    userSocials?: UserSocialsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutMajorsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    ritEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    pronouns?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitleId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: NullableEnumUsersAcademicYearFieldUpdateOperationsInput | $Enums.UsersAcademicYear | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    funFact?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobsCreateManyProjectsInput = {
    titleId: number
    availability: $Enums.JobsAvailability
    duration: $Enums.JobsDuration
    location: $Enums.JobsLocation
    compensation: $Enums.JobsCompensation
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembersCreateManyProjectsInput = {
    userId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type ProjectFollowingsCreateManyProjectsInput = {
    userId: number
    followedAt?: Date | string
  }

  export type ProjectGenresCreateManyProjectsInput = {
    typeId: number
  }

  export type ProjectImagesCreateManyProjectsInput = {
    imageId?: number
    image: string
    position: number
  }

  export type ProjectSocialsCreateManyProjectsInput = {
    websiteId: number
    url: string
  }

  export type ProjectTagsCreateManyProjectsInput = {
    tagId: number
    position: number
  }

  export type JobsUpdateWithoutProjectsInput = {
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobTitles?: JobTitlesUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutProjectsInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUncheckedUpdateManyWithoutProjectsInput = {
    titleId?: IntFieldUpdateOperationsInput | number
    availability?: EnumJobsAvailabilityFieldUpdateOperationsInput | $Enums.JobsAvailability
    duration?: EnumJobsDurationFieldUpdateOperationsInput | $Enums.JobsDuration
    location?: EnumJobsLocationFieldUpdateOperationsInput | $Enums.JobsLocation
    compensation?: EnumJobsCompensationFieldUpdateOperationsInput | $Enums.JobsCompensation
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUpdateWithoutProjectsInput = {
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobTitles?: JobTitlesUpdateOneRequiredWithoutMembersNestedInput
    users?: UsersUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MembersUncheckedUpdateWithoutProjectsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUncheckedUpdateManyWithoutProjectsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsUpdateWithoutProjectsInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutProjectFollowingsNestedInput
  }

  export type ProjectFollowingsUncheckedUpdateWithoutProjectsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsUncheckedUpdateManyWithoutProjectsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGenresUpdateWithoutProjectsInput = {
    genres?: GenresUpdateOneRequiredWithoutProjectGenresNestedInput
  }

  export type ProjectGenresUncheckedUpdateWithoutProjectsInput = {
    typeId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectGenresUncheckedUpdateManyWithoutProjectsInput = {
    typeId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesUpdateWithoutProjectsInput = {
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesUncheckedUpdateWithoutProjectsInput = {
    imageId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectImagesUncheckedUpdateManyWithoutProjectsInput = {
    imageId?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSocialsUpdateWithoutProjectsInput = {
    url?: StringFieldUpdateOperationsInput | string
    socials?: SocialsUpdateOneRequiredWithoutProjectSocialsNestedInput
  }

  export type ProjectSocialsUncheckedUpdateWithoutProjectsInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSocialsUncheckedUpdateManyWithoutProjectsInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTagsUpdateWithoutProjectsInput = {
    position?: IntFieldUpdateOperationsInput | number
    tags?: TagsUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagsUncheckedUpdateWithoutProjectsInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagsUncheckedUpdateManyWithoutProjectsInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSocialsCreateManySocialsInput = {
    projectId: number
    url: string
  }

  export type UserSocialsCreateManySocialsInput = {
    userId: number
    url: string
  }

  export type ProjectSocialsUpdateWithoutSocialsInput = {
    url?: StringFieldUpdateOperationsInput | string
    projects?: ProjectsUpdateOneRequiredWithoutProjectSocialsNestedInput
  }

  export type ProjectSocialsUncheckedUpdateWithoutSocialsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSocialsUncheckedUpdateManyWithoutSocialsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialsUpdateWithoutSocialsInput = {
    url?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateOneRequiredWithoutUserSocialsNestedInput
  }

  export type UserSocialsUncheckedUpdateWithoutSocialsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialsUncheckedUpdateManyWithoutSocialsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTagsCreateManyTagsInput = {
    projectId: number
    position: number
  }

  export type ProjectTagsUpdateWithoutTagsInput = {
    position?: IntFieldUpdateOperationsInput | number
    projects?: ProjectsUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagsUncheckedUpdateWithoutTagsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagsUncheckedUpdateManyWithoutTagsInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type MembersCreateManyUsersInput = {
    projectId: number
    titleId: number
    profileVisibility?: $Enums.MembersProfileVisibility
    createdAt?: Date | string
  }

  export type ProjectFollowingsCreateManyUsersInput = {
    projectId: number
    followedAt?: Date | string
  }

  export type ProjectsCreateManyUsersInput = {
    projectId?: number
    title: string
    hook: string
    description: string
    thumbnail?: string | null
    purpose?: $Enums.ProjectsPurpose | null
    status: $Enums.ProjectsStatus
    audience?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFollowingsCreateManyUsersUserFollowingsFollowingIdTousersInput = {
    userId: number
    followedAt?: Date | string
  }

  export type UserFollowingsCreateManyUsersUserFollowingsUserIdTousersInput = {
    followingId: number
    followedAt?: Date | string
  }

  export type UserSkillsCreateManyUsersInput = {
    skillId: number
    position: number
  }

  export type UserSocialsCreateManyUsersInput = {
    websiteId: number
    url: string
  }

  export type MembersUpdateWithoutUsersInput = {
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobTitles?: JobTitlesUpdateOneRequiredWithoutMembersNestedInput
    projects?: ProjectsUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MembersUncheckedUpdateWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersUncheckedUpdateManyWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: EnumMembersProfileVisibilityFieldUpdateOperationsInput | $Enums.MembersProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsUpdateWithoutUsersInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectsUpdateOneRequiredWithoutProjectFollowingsNestedInput
  }

  export type ProjectFollowingsUncheckedUpdateWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFollowingsUncheckedUpdateManyWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUpdateManyWithoutProjectsNestedInput
    members?: MembersUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobsUncheckedUpdateManyWithoutProjectsNestedInput
    members?: MembersUncheckedUpdateManyWithoutProjectsNestedInput
    projectFollowings?: ProjectFollowingsUncheckedUpdateManyWithoutProjectsNestedInput
    projectGenres?: ProjectGenresUncheckedUpdateManyWithoutProjectsNestedInput
    projectImages?: ProjectImagesUncheckedUpdateManyWithoutProjectsNestedInput
    projectSocials?: ProjectSocialsUncheckedUpdateManyWithoutProjectsNestedInput
    projectTags?: ProjectTagsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateManyWithoutUsersInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    hook?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableEnumProjectsPurposeFieldUpdateOperationsInput | $Enums.ProjectsPurpose | null
    status?: EnumProjectsStatusFieldUpdateOperationsInput | $Enums.ProjectsStatus
    audience?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsUpdateWithoutUsersUserFollowingsFollowingIdTousersInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersUserFollowingsUserIdTousers?: UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsUserIdTousersNestedInput
  }

  export type UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsFollowingIdTousersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsFollowingIdTousersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsUpdateWithoutUsersUserFollowingsUserIdTousersInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersUserFollowingsFollowingIdTousers?: UsersUpdateOneRequiredWithoutUserFollowingsUserFollowingsFollowingIdTousersNestedInput
  }

  export type UserFollowingsUncheckedUpdateWithoutUsersUserFollowingsUserIdTousersInput = {
    followingId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowingsUncheckedUpdateManyWithoutUsersUserFollowingsUserIdTousersInput = {
    followingId?: IntFieldUpdateOperationsInput | number
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsUpdateWithoutUsersInput = {
    position?: IntFieldUpdateOperationsInput | number
    skills?: SkillsUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateWithoutUsersInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSkillsUncheckedUpdateManyWithoutUsersInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSocialsUpdateWithoutUsersInput = {
    url?: StringFieldUpdateOperationsInput | string
    socials?: SocialsUpdateOneRequiredWithoutUserSocialsNestedInput
  }

  export type UserSocialsUncheckedUpdateWithoutUsersInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialsUncheckedUpdateManyWithoutUsersInput = {
    websiteId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkillsCreateManySkillsInput = {
    userId: number
    position: number
  }

  export type UserSkillsUpdateWithoutSkillsInput = {
    position?: IntFieldUpdateOperationsInput | number
    users?: UsersUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateWithoutSkillsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserSkillsUncheckedUpdateManyWithoutSkillsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}